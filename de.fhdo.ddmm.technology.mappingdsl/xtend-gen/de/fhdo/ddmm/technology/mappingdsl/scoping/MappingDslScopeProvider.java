/**
 * generated by Xtext 2.12.0
 */
package de.fhdo.ddmm.technology.mappingdsl.scoping;

import com.google.common.base.Function;
import com.google.common.base.Objects;
import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;
import de.fhdo.ddmm.data.ComplexType;
import de.fhdo.ddmm.data.DataModel;
import de.fhdo.ddmm.data.DataStructure;
import de.fhdo.ddmm.data.Enumeration;
import de.fhdo.ddmm.data.ListType;
import de.fhdo.ddmm.data.PrimitiveType;
import de.fhdo.ddmm.data.Type;
import de.fhdo.ddmm.service.Import;
import de.fhdo.ddmm.service.ImportType;
import de.fhdo.ddmm.service.ImportedType;
import de.fhdo.ddmm.service.Interface;
import de.fhdo.ddmm.service.Microservice;
import de.fhdo.ddmm.service.Operation;
import de.fhdo.ddmm.service.Parameter;
import de.fhdo.ddmm.service.ReferredOperation;
import de.fhdo.ddmm.service.ServiceModel;
import de.fhdo.ddmm.technology.CommunicationType;
import de.fhdo.ddmm.technology.DataFormat;
import de.fhdo.ddmm.technology.ExchangePattern;
import de.fhdo.ddmm.technology.JoinPointType;
import de.fhdo.ddmm.technology.Protocol;
import de.fhdo.ddmm.technology.ServiceAspect;
import de.fhdo.ddmm.technology.Technology;
import de.fhdo.ddmm.technology.TechnologyPackage;
import de.fhdo.ddmm.technology.TechnologySpecificDataStructure;
import de.fhdo.ddmm.technology.TechnologySpecificListType;
import de.fhdo.ddmm.technology.TechnologySpecificPrimitiveType;
import de.fhdo.ddmm.technology.TechnologySpecificPropertyValueAssignment;
import de.fhdo.ddmm.technology.mapping.ComplexParameterMapping;
import de.fhdo.ddmm.technology.mapping.ComplexTypeMapping;
import de.fhdo.ddmm.technology.mapping.ImportedComplexType;
import de.fhdo.ddmm.technology.mapping.ImportedMicroservice;
import de.fhdo.ddmm.technology.mapping.InterfaceMapping;
import de.fhdo.ddmm.technology.mapping.MappingPackage;
import de.fhdo.ddmm.technology.mapping.MicroserviceMapping;
import de.fhdo.ddmm.technology.mapping.OperationMapping;
import de.fhdo.ddmm.technology.mapping.ParameterMapping;
import de.fhdo.ddmm.technology.mapping.PrimitiveParameterMapping;
import de.fhdo.ddmm.technology.mapping.ReferredOperationMapping;
import de.fhdo.ddmm.technology.mapping.TechnologyMapping;
import de.fhdo.ddmm.technology.mapping.TechnologySpecificEndpoint;
import de.fhdo.ddmm.technology.mapping.TechnologySpecificFieldMapping;
import de.fhdo.ddmm.technology.mapping.TechnologySpecificImportedServiceAspect;
import de.fhdo.ddmm.technology.mapping.TechnologySpecificProtocol;
import de.fhdo.ddmm.technology.mapping.TechnologySpecificProtocolSpecification;
import de.fhdo.ddmm.technology.mappingdsl.scoping.AbstractMappingDslScopeProvider;
import de.fhdo.ddmm.utils.DdmmUtils;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.ExclusiveRange;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.Pair;

/**
 * This class implements a custom scope provider for the Mapping DSL.
 * 
 * @author <a href="mailto:florian.rademacher@fh-dortmund.de">Florian Rademacher</a>
 */
@SuppressWarnings("all")
public class MappingDslScopeProvider extends AbstractMappingDslScopeProvider {
  /**
   * Build scope for a given context and a given reference
   */
  @Override
  public IScope getScope(final EObject context, final EReference reference) {
    IScope _switchResult = null;
    boolean _matched = false;
    if (context instanceof ImportedComplexType) {
      _matched=true;
      _switchResult = this.getScope(((ImportedComplexType)context), reference);
    }
    if (!_matched) {
      if (context instanceof ComplexTypeMapping) {
        _matched=true;
        _switchResult = this.getScope(((ComplexTypeMapping)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof MicroserviceMapping) {
        _matched=true;
        _switchResult = this.getScope(((MicroserviceMapping)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof ImportedMicroservice) {
        _matched=true;
        _switchResult = this.getScope(((ImportedMicroservice)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof TechnologySpecificProtocolSpecification) {
        _matched=true;
        _switchResult = this.getScope(((TechnologySpecificProtocolSpecification)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof TechnologySpecificProtocol) {
        _matched=true;
        _switchResult = this.getScope(((TechnologySpecificProtocol)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof TechnologySpecificEndpoint) {
        _matched=true;
        _switchResult = this.getScope(((TechnologySpecificEndpoint)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof InterfaceMapping) {
        _matched=true;
        _switchResult = this.getScope(((InterfaceMapping)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof OperationMapping) {
        _matched=true;
        _switchResult = this.getScope(((OperationMapping)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof ReferredOperationMapping) {
        _matched=true;
        _switchResult = this.getScope(((ReferredOperationMapping)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof PrimitiveParameterMapping) {
        _matched=true;
        _switchResult = this.getScope(((PrimitiveParameterMapping)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof ComplexParameterMapping) {
        _matched=true;
        _switchResult = this.getScope(((ComplexParameterMapping)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof TechnologySpecificFieldMapping) {
        _matched=true;
        _switchResult = this.getScope(((TechnologySpecificFieldMapping)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof TechnologySpecificImportedServiceAspect) {
        _matched=true;
        _switchResult = this.getScope(((TechnologySpecificImportedServiceAspect)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof TechnologySpecificPropertyValueAssignment) {
        _matched=true;
        _switchResult = this.getScope(((TechnologySpecificPropertyValueAssignment)context), reference);
      }
    }
    final IScope scope = _switchResult;
    if ((scope != null)) {
      return scope;
    } else {
      if ((scope == null)) {
        return super.getScope(context, reference);
      }
    }
    return null;
  }
  
  /**
   * Build scope for imported complex types
   */
  private IScope getScope(final ImportedComplexType type, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.IMPORTED_COMPLEX_TYPE__SERVICE_MODEL_IMPORT)) {
      _matched=true;
      return this.getScopeForImportsOfType(type.getTypeMapping(), ServiceModel.class);
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.IMPORTED_COMPLEX_TYPE__DATA_MODEL_IMPORT)) {
        _matched=true;
        return this.getScopeForDomainModelImports(type);
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.IMPORTED_COMPLEX_TYPE__TYPE)) {
        _matched=true;
        return this.getScopeForComplexTypes(type);
      }
    }
    return null;
  }
  
  /**
   * Build scope for complex type mappings and the given reference
   */
  private IScope getScope(final ComplexTypeMapping mapping, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.IMPORTED_COMPLEX_TYPE__SERVICE_MODEL_IMPORT)) {
      _matched=true;
      return this.getScopeForImportsOfType(mapping, ServiceModel.class);
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForAnnotatedTechnologies(mapping);
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_FIELD_MAPPING__ENUMERATION_FIELD)) {
        _matched=true;
        return this.getScopeForComplexFields(mapping);
      }
    }
    return null;
  }
  
  /**
   * Build scope for microservice mappings and the given reference
   */
  private IScope getScope(final MicroserviceMapping mapping, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.IMPORTED_MICROSERVICE__IMPORT)) {
      _matched=true;
      return this.getScopeForImportsOfType(mapping, ServiceModel.class);
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_PROTOCOL__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForAnnotatedTechnologies(mapping);
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForAnnotatedTechnologies(mapping);
      }
    }
    return null;
  }
  
  /**
   * Build scope for interface mappings and the given reference
   */
  private IScope getScope(final InterfaceMapping mapping, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.INTERFACE_MAPPING__INTERFACE)) {
      _matched=true;
      return this.getScopeForInterfaces(mapping);
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_PROTOCOL__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForAnnotatedTechnologies(mapping.getMicroserviceMapping());
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForAnnotatedTechnologies(mapping.getMicroserviceMapping());
      }
    }
    return null;
  }
  
  /**
   * Build scope for operation mappings and the given reference
   */
  private IScope getScope(final OperationMapping mapping, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.OPERATION_MAPPING__OPERATION)) {
      _matched=true;
      return this.getScopeForOperations(mapping);
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_PROTOCOL__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForAnnotatedTechnologies(mapping.getMicroserviceMapping());
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForAnnotatedTechnologies(mapping.getMicroserviceMapping());
      }
    }
    return null;
  }
  
  /**
   * Build scope for referred operation mappings and the given reference
   */
  private IScope getScope(final ReferredOperationMapping mapping, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.REFERRED_OPERATION_MAPPING__OPERATION)) {
      _matched=true;
      return this.getScopeForReferredOperations(mapping);
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_PROTOCOL__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForAnnotatedTechnologies(mapping.getMicroserviceMapping());
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForAnnotatedTechnologies(mapping.getMicroserviceMapping());
      }
    }
    return null;
  }
  
  /**
   * Build scope for imported microservices
   */
  private IScope getScope(final ImportedMicroservice microservice, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.IMPORTED_MICROSERVICE__IMPORT)) {
      _matched=true;
      return this.getScopeForImportsOfType(microservice, ServiceModel.class);
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.IMPORTED_MICROSERVICE__MICROSERVICE)) {
        _matched=true;
        return this.getScopeForImportedMicroservices(microservice.getImport());
      }
    }
    return null;
  }
  
  /**
   * Build scope for technology-specific protocols and the given reference
   */
  private IScope getScope(final TechnologySpecificProtocolSpecification protocolSpecification, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_PROTOCOL__TECHNOLOGY)) {
      _matched=true;
      return this.getScopeForAnnotatedTechnologies(EcoreUtil2.<MicroserviceMapping>getContainerOfType(protocolSpecification, MicroserviceMapping.class));
    }
    return null;
  }
  
  /**
   * Build scope that comprises annotated technologies of an annotatable concept instance
   */
  private IScope getScopeForAnnotatedTechnologies(final EObject mapping) {
    IScope _xifexpression = null;
    if ((mapping instanceof ComplexTypeMapping)) {
      _xifexpression = Scopes.scopeFor(((ComplexTypeMapping)mapping).getTechnologies());
    } else {
      IScope _xifexpression_1 = null;
      if ((mapping instanceof MicroserviceMapping)) {
        _xifexpression_1 = Scopes.scopeFor(((MicroserviceMapping)mapping).getTechnologies());
      } else {
        _xifexpression_1 = null;
      }
      _xifexpression = _xifexpression_1;
    }
    return _xifexpression;
  }
  
  /**
   * Build scope for technology protocols and the given reference
   */
  private IScope getScope(final TechnologySpecificProtocol protocol, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_PROTOCOL__PROTOCOL)) {
      _matched=true;
      return this.getScopeForTechnologySpecificProtocols(protocol);
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_PROTOCOL__DATA_FORMAT)) {
        _matched=true;
        return this.getScopeForDataFormats(protocol);
      }
    }
    return null;
  }
  
  /**
   * Build scope for technology-specific endpoints and the given reference
   */
  private IScope getScope(final TechnologySpecificEndpoint endpoint, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_PROTOCOL__TECHNOLOGY)) {
      _matched=true;
      return this.getScopeForAnnotatedTechnologies(EcoreUtil2.<MicroserviceMapping>getContainerOfType(endpoint, MicroserviceMapping.class));
    }
    return null;
  }
  
  /**
   * Build scope for primitive parameter mappings and the given reference
   */
  private IScope getScope(final PrimitiveParameterMapping mapping, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.PARAMETER_MAPPING__PARAMETER)) {
      _matched=true;
      return this.getScopeForPrimitiveParameters(mapping);
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.PRIMITIVE_PARAMETER_MAPPING__PRIMITIVE_TYPE)) {
        _matched=true;
        return this.getScopeForMappingTypes(mapping);
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForAnnotatedTechnologies(EcoreUtil2.<MicroserviceMapping>getContainerOfType(mapping, MicroserviceMapping.class));
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.PRIMITIVE_PARAMETER_MAPPING__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForTypeDefinitionTechnology(mapping);
      }
    }
    return null;
  }
  
  /**
   * Build scope for complex parameter mappings and the given reference
   */
  private IScope getScope(final ComplexParameterMapping mapping, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.PARAMETER_MAPPING__PARAMETER)) {
      _matched=true;
      return this.getScopeForComplexParameters(mapping);
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForAnnotatedTechnologies(EcoreUtil2.<MicroserviceMapping>getContainerOfType(mapping, MicroserviceMapping.class));
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.COMPLEX_PARAMETER_MAPPING__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForTypeDefinitionTechnology(mapping);
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.COMPLEX_PARAMETER_MAPPING__TECHNOLOGY_SPECIFIC_COMPLEX_TYPE)) {
        _matched=true;
        return this.getScopeForMappingTypes(mapping);
      }
    }
    return null;
  }
  
  /**
   * Build scope for technology-specific field mappings and the given reference
   */
  private IScope getScope(final TechnologySpecificFieldMapping mapping, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_FIELD_MAPPING__DATA_FIELD)) {
      _matched=true;
      return this.getScopeForComplexFields(mapping.eContainer());
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_FIELD_MAPPING__ENUMERATION_FIELD)) {
        _matched=true;
        return this.getScopeForComplexFields(mapping.eContainer());
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_FIELD_MAPPING__TECHNOLOGY)) {
        _matched=true;
      }
      if (!_matched) {
        if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__TECHNOLOGY)) {
          _matched=true;
        }
      }
      if (_matched) {
        return this.getScopeForTypeDefinitionTechnology(mapping);
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_FIELD_MAPPING__TYPE)) {
        _matched=true;
        return this.getScopeForMappingTypes(mapping);
      }
    }
    return null;
  }
  
  /**
   * Build scope for domain model imports of imported complex types
   */
  private IScope getScopeForDomainModelImports(final ImportedComplexType type) {
    final ServiceModel serviceModel = DdmmUtils.<ServiceModel>getImportedModelRoot(type.eResource(), 
      type.getServiceModelImport().getImportURI(), ServiceModel.class);
    final Function1<Import, Boolean> _function = (Import it) -> {
      ImportType _importType = it.getImportType();
      return Boolean.valueOf(Objects.equal(_importType, ImportType.DATATYPES));
    };
    final Iterable<Import> dataModels = IterableExtensions.<Import>filter(serviceModel.getImports(), _function);
    return Scopes.scopeFor(dataModels);
  }
  
  /**
   * Build scope for complex types to be imported
   */
  private IScope getScopeForComplexTypes(final ImportedComplexType type) {
    Import _dataModelImport = type.getDataModelImport();
    boolean _tripleEquals = (_dataModelImport == null);
    if (_tripleEquals) {
      return IScope.NULLSCOPE;
    }
    final Function<DataModel, List<ComplexType>> _function = (DataModel it) -> {
      return IterableExtensions.<ComplexType>toList(it.getContainedComplexTypes());
    };
    final Function<ComplexType, List<String>> _function_1 = (ComplexType it) -> {
      return it.getQualifiedNameParts();
    };
    return DdmmUtils.<Import, DataModel, ComplexType>getScopeForPossiblyImportedConcept(
      type.getDataModelImport(), 
      null, 
      DataModel.class, 
      type.getDataModelImport().getImportURI(), _function, _function_1);
  }
  
  /**
   * Build scope for interfaces
   */
  private IScope getScopeForInterfaces(final InterfaceMapping mapping) {
    final MicroserviceMapping microserviceMapping = mapping.getMicroserviceMapping();
    final Microservice microservice = microserviceMapping.getMicroservice().getMicroservice();
    return Scopes.scopeFor(microservice.getInterfaces());
  }
  
  /**
   * Build scope for operations
   */
  private IScope getScopeForOperations(final OperationMapping mapping) {
    final MicroserviceMapping microserviceMapping = mapping.getMicroserviceMapping();
    final Microservice microservice = microserviceMapping.getMicroservice().getMicroservice();
    if ((microservice == null)) {
      return IScope.NULLSCOPE;
    }
    final Function1<Interface, EList<Operation>> _function = (Interface it) -> {
      return it.getOperations();
    };
    final Iterable<Operation> operations = Iterables.<Operation>concat(ListExtensions.<Interface, EList<Operation>>map(microservice.getInterfaces(), _function));
    final Function<Operation, QualifiedName> _function_1 = (Operation it) -> {
      return QualifiedName.create(it.getInterface().getName(), it.getName());
    };
    return Scopes.<Operation>scopeFor(operations, _function_1, 
      IScope.NULLSCOPE);
  }
  
  /**
   * Build scope for primitive parameters of operations
   */
  private IScope getScopeForPrimitiveParameters(final PrimitiveParameterMapping mapping) {
    final Function1<Parameter, Boolean> _function = (Parameter it) -> {
      PrimitiveType _primitiveType = it.getPrimitiveType();
      return Boolean.valueOf((_primitiveType != null));
    };
    final List<Parameter> primitiveParameters = IterableExtensions.<Parameter>toList(IterableExtensions.<Parameter>filter(mapping.getOperationMapping().getOperation().getParameters(), _function));
    final Function1<Parameter, Boolean> _function_1 = (Parameter it) -> {
      return Boolean.valueOf(((it.getImportedType() != null) && (it.getImportedType().getType() instanceof TechnologySpecificPrimitiveType)));
    };
    Iterables.<Parameter>addAll(primitiveParameters, 
      IterableExtensions.<Parameter>filter(mapping.getOperationMapping().getOperation().getParameters(), _function_1));
    return Scopes.scopeFor(primitiveParameters);
  }
  
  /**
   * Build scope for complex parameters of operations
   */
  private IScope getScopeForComplexParameters(final ComplexParameterMapping mapping) {
    final Function1<Parameter, Boolean> _function = (Parameter it) -> {
      return Boolean.valueOf(((it.getImportedType() != null) && (it.getImportedType().getType() instanceof ComplexType)));
    };
    final Iterable<Parameter> complexParameters = IterableExtensions.<Parameter>filter(mapping.getOperationMapping().getOperation().getParameters(), _function);
    return Scopes.scopeFor(complexParameters);
  }
  
  /**
   * Build scope for technology-specific types of field in complex type mappings or parameters
   */
  private IScope getScopeForMappingTypes(final EObject mapping) {
    Type parameterType = null;
    Import technology = null;
    boolean _matched = false;
    if (mapping instanceof PrimitiveParameterMapping) {
      _matched=true;
      parameterType = ((PrimitiveParameterMapping)mapping).getParameter().getEffectiveType();
      technology = ((PrimitiveParameterMapping)mapping).getTechnology();
    }
    if (!_matched) {
      if (mapping instanceof ComplexParameterMapping) {
        _matched=true;
        Parameter _parameter = null;
        if (((ComplexParameterMapping)mapping)!=null) {
          _parameter=((ComplexParameterMapping)mapping).getParameter();
        }
        ImportedType _importedType = null;
        if (_parameter!=null) {
          _importedType=_parameter.getImportedType();
        }
        Type _type = null;
        if (_importedType!=null) {
          _type=_importedType.getType();
        }
        parameterType = _type;
        technology = ((ComplexParameterMapping)mapping).getTechnology();
      }
    }
    if (!_matched) {
      if (mapping instanceof TechnologySpecificFieldMapping) {
        _matched=true;
        parameterType = ((TechnologySpecificFieldMapping)mapping).getDataField().getEffectiveType();
        technology = ((TechnologySpecificFieldMapping)mapping).getTechnology();
      }
    }
    if (!_matched) {
      return IScope.NULLSCOPE;
    }
    if ((parameterType == null)) {
      return IScope.NULLSCOPE;
    }
    Function<Technology, List<Type>> getImportedConcepts = null;
    Function<Type, List<String>> getConceptNameParts = null;
    if ((parameterType instanceof PrimitiveType)) {
      final Function<Technology, List<Type>> _function = (Technology it) -> {
        final Function1<TechnologySpecificPrimitiveType, Type> _function_1 = (TechnologySpecificPrimitiveType it_1) -> {
          return ((Type) it_1);
        };
        return ListExtensions.<TechnologySpecificPrimitiveType, Type>map(it.getPrimitiveTypes(), _function_1);
      };
      getImportedConcepts = _function;
      final Function<Type, List<String>> _function_1 = (Type it) -> {
        return ((TechnologySpecificPrimitiveType) it).getQualifiedNameParts();
      };
      getConceptNameParts = _function_1;
    } else {
      if ((parameterType instanceof ComplexType)) {
        boolean _isIsStructure = ((ComplexType)parameterType).isIsStructure();
        if (_isIsStructure) {
          final Function<Technology, List<Type>> _function_2 = (Technology it) -> {
            final Function1<TechnologySpecificDataStructure, Type> _function_3 = (TechnologySpecificDataStructure it_1) -> {
              return ((Type) it_1);
            };
            return ListExtensions.<TechnologySpecificDataStructure, Type>map(it.getDataStructures(), _function_3);
          };
          getImportedConcepts = _function_2;
          final Function<Type, List<String>> _function_3 = (Type it) -> {
            return ((TechnologySpecificDataStructure) it).getQualifiedNameParts();
          };
          getConceptNameParts = _function_3;
        } else {
          if ((((ComplexType)parameterType).isIsStructuredList() || ((ComplexType)parameterType).isIsPrimitiveList())) {
            final Function<Technology, List<Type>> _function_4 = (Technology it) -> {
              final Function1<TechnologySpecificListType, Type> _function_5 = (TechnologySpecificListType it_1) -> {
                return ((Type) it_1);
              };
              return ListExtensions.<TechnologySpecificListType, Type>map(it.getListTypes(), _function_5);
            };
            getImportedConcepts = _function_4;
            final Function<Type, List<String>> _function_5 = (Type it) -> {
              return ((TechnologySpecificListType) it).getQualifiedNameParts();
            };
            getConceptNameParts = _function_5;
          } else {
            boolean _isIsEnumeration = ((ComplexType)parameterType).isIsEnumeration();
            if (_isIsEnumeration) {
              return IScope.NULLSCOPE;
            }
          }
        }
      }
    }
    return DdmmUtils.<Import, Technology, Type>getScopeForPossiblyImportedConcept(technology, 
      null, 
      Technology.class, 
      technology.getImportURI(), getImportedConcepts, getConceptNameParts);
  }
  
  /**
   * Build scope for microservice mapping technology that defines types
   */
  private IScope getScopeForTypeDefinitionTechnology(final EObject context) {
    EList<Import> _xifexpression = null;
    if ((context instanceof MicroserviceMapping)) {
      _xifexpression = ((MicroserviceMapping)context).getTechnologies();
    } else {
      EList<Import> _xifexpression_1 = null;
      if ((context instanceof ComplexTypeMapping)) {
        _xifexpression_1 = ((ComplexTypeMapping)context).getTechnologies();
      } else {
        EList<Import> _elvis = null;
        MicroserviceMapping _containerOfType = EcoreUtil2.<MicroserviceMapping>getContainerOfType(context, MicroserviceMapping.class);
        EList<Import> _technologies = null;
        if (_containerOfType!=null) {
          _technologies=_containerOfType.getTechnologies();
        }
        if (_technologies != null) {
          _elvis = _technologies;
        } else {
          ComplexTypeMapping _containerOfType_1 = EcoreUtil2.<ComplexTypeMapping>getContainerOfType(context, ComplexTypeMapping.class);
          EList<Import> _technologies_1 = null;
          if (_containerOfType_1!=null) {
            _technologies_1=_containerOfType_1.getTechnologies();
          }
          _elvis = _technologies_1;
        }
        _xifexpression_1 = _elvis;
      }
      _xifexpression = _xifexpression_1;
    }
    final EList<Import> technologies = _xifexpression;
    if ((technologies == null)) {
      return IScope.NULLSCOPE;
    }
    final Function1<Import, Boolean> _function = (Import it) -> {
      boolean _xblockexpression = false;
      {
        final Technology modelRoot = DdmmUtils.<Technology>getImportedModelRoot(it.eResource(), it.getImportURI(), Technology.class);
        _xblockexpression = ((modelRoot != null) && (!modelRoot.getPrimitiveTypes().isEmpty()));
      }
      return Boolean.valueOf(_xblockexpression);
    };
    final Import typeDefinitionTechnology = IterableExtensions.<Import>findFirst(technologies, _function);
    if ((typeDefinitionTechnology == null)) {
      return IScope.NULLSCOPE;
    }
    return Scopes.scopeFor(Collections.<EObject>unmodifiableList(CollectionLiterals.<EObject>newArrayList(typeDefinitionTechnology)));
  }
  
  /**
   * Build scope for enumeration and data fields in complex type and parameter mappings
   */
  private IScope getScopeForComplexFields(final EObject mapping) {
    ComplexType _xifexpression = null;
    if ((mapping instanceof ComplexParameterMapping)) {
      ComplexType _xifexpression_1 = null;
      ImportedType _importedType = ((ComplexParameterMapping)mapping).getParameter().getImportedType();
      boolean _tripleNotEquals = (_importedType != null);
      if (_tripleNotEquals) {
        Type _type = ((ComplexParameterMapping)mapping).getParameter().getImportedType().getType();
        _xifexpression_1 = ((ComplexType) _type);
      }
      _xifexpression = _xifexpression_1;
    } else {
      ComplexType _xifexpression_2 = null;
      if ((mapping instanceof ComplexTypeMapping)) {
        ComplexType _type_1 = ((ComplexTypeMapping)mapping).getType().getType();
        _xifexpression_2 = ((ComplexType) _type_1);
      }
      _xifexpression = _xifexpression_2;
    }
    ComplexType complexType = _xifexpression;
    IScope _xifexpression_3 = null;
    if ((complexType == null)) {
      _xifexpression_3 = IScope.NULLSCOPE;
    } else {
      IScope _xifexpression_4 = null;
      if ((complexType instanceof Enumeration)) {
        _xifexpression_4 = Scopes.scopeFor(((Enumeration)complexType).getFields());
      } else {
        IScope _xifexpression_5 = null;
        boolean _isIsStructure = complexType.isIsStructure();
        if (_isIsStructure) {
          _xifexpression_5 = Scopes.scopeFor(((DataStructure) complexType).getDataFields());
        } else {
          IScope _xifexpression_6 = null;
          boolean _isIsStructuredList = complexType.isIsStructuredList();
          if (_isIsStructuredList) {
            _xifexpression_6 = Scopes.scopeFor(((ListType) complexType).getDataFields());
          } else {
            _xifexpression_6 = IScope.NULLSCOPE;
          }
          _xifexpression_5 = _xifexpression_6;
        }
        _xifexpression_4 = _xifexpression_5;
      }
      _xifexpression_3 = _xifexpression_4;
    }
    return _xifexpression_3;
  }
  
  /**
   * Build scope for referred operations
   */
  private IScope getScopeForReferredOperations(final ReferredOperationMapping mapping) {
    final MicroserviceMapping microserviceMapping = mapping.getMicroserviceMapping();
    final Microservice microservice = microserviceMapping.getMicroservice().getMicroservice();
    final Function1<Interface, EList<ReferredOperation>> _function = (Interface it) -> {
      return it.getReferredOperations();
    };
    final Iterable<ReferredOperation> operations = Iterables.<ReferredOperation>concat(ListExtensions.<Interface, EList<ReferredOperation>>map(microservice.getInterfaces(), _function));
    final Function<ReferredOperation, QualifiedName> _function_1 = (ReferredOperation it) -> {
      return QualifiedName.create(it.getInterface().getName(), it.getOperation().getName());
    };
    return Scopes.<ReferredOperation>scopeFor(operations, _function_1, 
      IScope.NULLSCOPE);
  }
  
  /**
   * Build scope for technology-specific protocols
   */
  private IScope getScopeForTechnologySpecificProtocols(final TechnologySpecificProtocol protocol) {
    Import _technology = protocol.getTechnology();
    boolean _tripleEquals = (_technology == null);
    if (_tripleEquals) {
      return IScope.NULLSCOPE;
    }
    final TechnologySpecificProtocolSpecification protocolSpecification = protocol.getProtocolSpecification();
    CommunicationType _xifexpression = null;
    if ((protocolSpecification != null)) {
      _xifexpression = protocolSpecification.getCommunicationType();
    }
    final CommunicationType forCommunicationType = _xifexpression;
    List<Predicate<Protocol>> _xifexpression_1 = null;
    if ((forCommunicationType != null)) {
      final Predicate<Protocol> _function = (Protocol it) -> {
        CommunicationType _communicationType = it.getCommunicationType();
        return Objects.equal(forCommunicationType, _communicationType);
      };
      _xifexpression_1 = Collections.<Predicate<Protocol>>unmodifiableList(CollectionLiterals.<Predicate<Protocol>>newArrayList(_function));
    }
    List<Predicate<Protocol>> communicationTypeFilter = _xifexpression_1;
    final Function<Technology, List<Protocol>> _function_1 = (Technology it) -> {
      return IterableExtensions.<Protocol>toList(it.getProtocols());
    };
    final Function<Protocol, List<String>> _function_2 = (Protocol it) -> {
      return it.getQualifiedNameParts();
    };
    final List<Predicate<Protocol>> _converted_communicationTypeFilter = (List<Predicate<Protocol>>)communicationTypeFilter;
    return DdmmUtils.<Import, Technology, Protocol>getScopeForPossiblyImportedConcept(
      protocol.getTechnology(), 
      null, 
      Technology.class, 
      protocol.getTechnology().getImportURI(), _function_1, _function_2, ((Predicate<Protocol>[])Conversions.unwrapArray(_converted_communicationTypeFilter, Predicate.class)));
  }
  
  /**
   * Build scope for protocol data formats
   */
  private IScope getScopeForDataFormats(final TechnologySpecificProtocol protocol) {
    Protocol _protocol = protocol.getProtocol();
    boolean _tripleEquals = (_protocol == null);
    if (_tripleEquals) {
      return IScope.NULLSCOPE;
    }
    final String protocolName = protocol.getProtocol().getName();
    if ((protocolName == null)) {
      return IScope.NULLSCOPE;
    }
    final Function1<Protocol, Boolean> _function = (Protocol it) -> {
      String _name = it.getName();
      return Boolean.valueOf(Objects.equal(_name, protocolName));
    };
    final EList<DataFormat> scopeElements = IterableExtensions.<Protocol>findFirst(protocol.getProtocol().getTechnology().getProtocols(), _function).getDataFormats();
    final Function<DataFormat, QualifiedName> _function_1 = (DataFormat it) -> {
      return QualifiedName.create(it.getFormatName());
    };
    return Scopes.<DataFormat>scopeFor(scopeElements, _function_1, 
      IScope.NULLSCOPE);
  }
  
  /**
   * Build scope for the actual microservices if the import was already specified
   */
  private IScope getScopeForImportedMicroservices(final Import import_) {
    if ((import_ == null)) {
      return IScope.NULLSCOPE;
    }
    final Function<ServiceModel, List<Microservice>> _function = (ServiceModel it) -> {
      return IterableExtensions.<Microservice>toList(it.getMicroservices());
    };
    final Function<Microservice, List<String>> _function_1 = (Microservice it) -> {
      return it.getQualifiedNameParts();
    };
    return DdmmUtils.<Import, ServiceModel, Microservice>getScopeForPossiblyImportedConcept(import_, 
      null, 
      ServiceModel.class, 
      import_.getImportURI(), _function, _function_1);
  }
  
  /**
   * Build scope for imported service aspects used to annotate microservices, interfaces,
   * operations, parameters, or data fields
   */
  private IScope getScope(final TechnologySpecificImportedServiceAspect importedAspect, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__TECHNOLOGY)) {
      _matched=true;
      return this.getScopeForTechnologies(importedAspect);
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__ASPECT)) {
        _matched=true;
        return this.getScopeForImportedAspect(importedAspect);
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, TechnologyPackage.Literals.TECHNOLOGY_SPECIFIC_PROPERTY_VALUE_ASSIGNMENT__PROPERTY)) {
        _matched=true;
        return this.getScopeForAspectProperty(importedAspect);
      }
    }
    return null;
  }
  
  /**
   * Build scope for technology-specific value assignment
   */
  private IScope getScope(final TechnologySpecificPropertyValueAssignment assignment, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, TechnologyPackage.Literals.TECHNOLOGY_SPECIFIC_PROPERTY_VALUE_ASSIGNMENT__PROPERTY)) {
      _matched=true;
      return this.getScopeForAspectProperty(EcoreUtil2.<TechnologySpecificImportedServiceAspect>getContainerOfType(assignment, 
        TechnologySpecificImportedServiceAspect.class));
    }
    return null;
  }
  
  /**
   * Build scope for aspect properties
   */
  private IScope getScopeForAspectProperty(final TechnologySpecificImportedServiceAspect importedAspect) {
    return Scopes.scopeFor(importedAspect.getAspect().getProperties());
  }
  
  /**
   * Build scope for technologies of imported service aspect
   */
  private IScope getScopeForTechnologies(final TechnologySpecificImportedServiceAspect aspect) {
    IScope _xifexpression = null;
    ComplexTypeMapping _typeMapping = aspect.getTypeMapping();
    boolean _tripleNotEquals = (_typeMapping != null);
    if (_tripleNotEquals) {
      _xifexpression = this.getScopeForAnnotatedTechnologies(aspect.getTypeMapping());
    } else {
      _xifexpression = this.getScopeForAnnotatedTechnologies(EcoreUtil2.<MicroserviceMapping>getContainerOfType(aspect, MicroserviceMapping.class));
    }
    return _xifexpression;
  }
  
  /**
   * Build scope for aspect of imported service aspect
   */
  private IScope getScopeForImportedAspect(final TechnologySpecificImportedServiceAspect aspect) {
    Import _technology = aspect.getTechnology();
    boolean _tripleEquals = (_technology == null);
    if (_tripleEquals) {
      return IScope.NULLSCOPE;
    }
    ExchangePattern forExchangePattern = null;
    CommunicationType forCommunicationType = null;
    List<Pair<Protocol, DataFormat>> forProtocolsAndDataFormats = null;
    final EObject mapping = aspect.eContainer();
    JoinPointType _switchResult = null;
    boolean _matched = false;
    if (mapping instanceof ComplexTypeMapping) {
      _matched=true;
      _switchResult = JoinPointType.COMPLEX_TYPES;
    }
    if (!_matched) {
      if (mapping instanceof MicroserviceMapping) {
        _matched=true;
        JoinPointType _xblockexpression = null;
        {
          forProtocolsAndDataFormats = IterableExtensions.<Pair<Protocol, DataFormat>>toList(this.getEffectiveProtocolsAndDataFormats(((MicroserviceMapping)mapping)).values());
          _xblockexpression = JoinPointType.MICROSERVICES;
        }
        _switchResult = _xblockexpression;
      }
    }
    if (!_matched) {
      if (mapping instanceof InterfaceMapping) {
        _matched=true;
        JoinPointType _xblockexpression = null;
        {
          forProtocolsAndDataFormats = IterableExtensions.<Pair<Protocol, DataFormat>>toList(this.getEffectiveProtocolsAndDataFormats(((InterfaceMapping)mapping)).values());
          _xblockexpression = JoinPointType.INTERFACES;
        }
        _switchResult = _xblockexpression;
      }
    }
    if (!_matched) {
      if (mapping instanceof OperationMapping) {
        _matched=true;
        JoinPointType _xblockexpression = null;
        {
          forProtocolsAndDataFormats = IterableExtensions.<Pair<Protocol, DataFormat>>toList(this.getEffectiveProtocolsAndDataFormats(((OperationMapping)mapping)).values());
          _xblockexpression = JoinPointType.OPERATIONS;
        }
        _switchResult = _xblockexpression;
      }
    }
    if (!_matched) {
      if (mapping instanceof ReferredOperationMapping) {
        _matched=true;
        JoinPointType _xblockexpression = null;
        {
          forProtocolsAndDataFormats = IterableExtensions.<Pair<Protocol, DataFormat>>toList(this.getEffectiveProtocolsAndDataFormats(((ReferredOperationMapping)mapping)).values());
          _xblockexpression = JoinPointType.OPERATIONS;
        }
        _switchResult = _xblockexpression;
      }
    }
    if (!_matched) {
      if (mapping instanceof ParameterMapping) {
        _matched=true;
        JoinPointType _xblockexpression = null;
        {
          final Parameter parameter = ((ParameterMapping)mapping).getParameter();
          forCommunicationType = parameter.getCommunicationType();
          forExchangePattern = parameter.getExchangePattern();
          final Pair<Protocol, DataFormat> effectiveProtocolAndDataFormat = this.getEffectiveProtocolAndDataFormat(((ParameterMapping)mapping));
          List<Pair<Protocol, DataFormat>> _xifexpression = null;
          if ((effectiveProtocolAndDataFormat != null)) {
            _xifexpression = Collections.<Pair<Protocol, DataFormat>>unmodifiableList(CollectionLiterals.<Pair<Protocol, DataFormat>>newArrayList(effectiveProtocolAndDataFormat));
          } else {
            _xifexpression = null;
          }
          forProtocolsAndDataFormats = _xifexpression;
          _xblockexpression = JoinPointType.PARAMETERS;
        }
        _switchResult = _xblockexpression;
      }
    }
    if (!_matched) {
      if (mapping instanceof TechnologySpecificFieldMapping) {
        _matched=true;
        JoinPointType _xblockexpression = null;
        {
          ComplexParameterMapping _parameterMapping = ((TechnologySpecificFieldMapping)mapping).getParameterMapping();
          boolean _tripleNotEquals = (_parameterMapping != null);
          if (_tripleNotEquals) {
            final ComplexParameterMapping parameterMapping = ((TechnologySpecificFieldMapping)mapping).getParameterMapping();
            final Pair<Protocol, DataFormat> effectiveProtocolAndDataFormat = this.getEffectiveProtocolAndDataFormat(parameterMapping);
            List<Pair<Protocol, DataFormat>> _xifexpression = null;
            if ((effectiveProtocolAndDataFormat != null)) {
              _xifexpression = Collections.<Pair<Protocol, DataFormat>>unmodifiableList(CollectionLiterals.<Pair<Protocol, DataFormat>>newArrayList(effectiveProtocolAndDataFormat));
            } else {
              _xifexpression = null;
            }
            forProtocolsAndDataFormats = _xifexpression;
            final Parameter parameter = parameterMapping.getParameter();
            forCommunicationType = parameter.getCommunicationType();
            forExchangePattern = parameter.getExchangePattern();
          }
          _xblockexpression = JoinPointType.DATA_FIELDS;
        }
        _switchResult = _xblockexpression;
      }
    }
    final JoinPointType joinPoint = _switchResult;
    final EList<EObject> resourceContents = DdmmUtils.getImportedModelContents(aspect.getTechnology().eResource(), 
      aspect.getTechnology().getImportURI());
    if (((resourceContents == null) || resourceContents.isEmpty())) {
      return IScope.NULLSCOPE;
    }
    EObject _get = resourceContents.get(0);
    final Function1<ServiceAspect, Boolean> _function = (ServiceAspect it) -> {
      return Boolean.valueOf(it.getJoinPoints().contains(joinPoint));
    };
    final List<ServiceAspect> declaredAspectsForJoinPoint = IterableExtensions.<ServiceAspect>toList(IterableExtensions.<ServiceAspect>filter(((Technology) _get).getServiceAspects(), _function));
    final ArrayList<ServiceAspect> scopeAspects = this.filterMatchingAspects(declaredAspectsForJoinPoint, forExchangePattern, forCommunicationType, forProtocolsAndDataFormats);
    final Function<ServiceAspect, QualifiedName> _function_1 = (ServiceAspect it) -> {
      return QualifiedName.create(it.getQualifiedNameParts());
    };
    return Scopes.<ServiceAspect>scopeFor(scopeAspects, _function_1, 
      IScope.NULLSCOPE);
  }
  
  /**
   * Convenience method to create a scope for imports of certain types
   */
  private IScope getScopeForImportsOfType(final EObject context, final Class<? extends EObject>... types) {
    final EList<Import> allImports = EcoreUtil2.<TechnologyMapping>getContainerOfType(context, TechnologyMapping.class).getImports();
    final Function<Import, String> _function = (Import it) -> {
      return it.getImportURI();
    };
    final Iterable<Import> validImports = DdmmUtils.<Import>getImportsOfModelTypes(allImports, _function, types);
    return Scopes.scopeFor(validImports);
  }
  
  /**
   * Helper method to determine effective protocols and data formats of a microservice mapping
   */
  private Map<CommunicationType, Pair<Protocol, DataFormat>> getEffectiveProtocolsAndDataFormats(final MicroserviceMapping mapping) {
    final Map<CommunicationType, Pair<Protocol, DataFormat>> results = this.<EObject>getEffectiveProtocolsAndDataFormats(mapping.getProtocols(), null, null);
    final ArrayList<CommunicationType> missingCommunicationTypes = CollectionLiterals.<CommunicationType>newArrayList();
    boolean _containsKey = results.containsKey(CommunicationType.ASYNCHRONOUS);
    boolean _not = (!_containsKey);
    if (_not) {
      missingCommunicationTypes.add(CommunicationType.ASYNCHRONOUS);
    }
    boolean _containsKey_1 = results.containsKey(CommunicationType.SYNCHRONOUS);
    boolean _not_1 = (!_containsKey_1);
    if (_not_1) {
      missingCommunicationTypes.add(CommunicationType.SYNCHRONOUS);
    }
    boolean _isEmpty = missingCommunicationTypes.isEmpty();
    if (_isEmpty) {
      return results;
    }
    final Consumer<Import> _function = (Import it) -> {
      final Technology technologyModel = DdmmUtils.<Technology>getImportedModelRoot(it.eResource(), it.getImportURI(), Technology.class);
      final Consumer<CommunicationType> _function_1 = (CommunicationType communicationType) -> {
        Protocol defaultProtocol = null;
        DataFormat defaultDataFormat = null;
        EList<Protocol> _protocols = null;
        if (technologyModel!=null) {
          _protocols=technologyModel.getProtocols();
        }
        Iterable<Protocol> _filter = null;
        if (_protocols!=null) {
          final Function1<Protocol, Boolean> _function_2 = (Protocol it_1) -> {
            CommunicationType _communicationType = it_1.getCommunicationType();
            return Boolean.valueOf(Objects.equal(_communicationType, communicationType));
          };
          _filter=IterableExtensions.<Protocol>filter(_protocols, _function_2);
        }
        Protocol _findFirst = null;
        if (_filter!=null) {
          final Function1<Protocol, Boolean> _function_3 = (Protocol it_1) -> {
            return Boolean.valueOf(it_1.isDefault());
          };
          _findFirst=IterableExtensions.<Protocol>findFirst(_filter, _function_3);
        }
        defaultProtocol = _findFirst;
        if ((defaultProtocol != null)) {
          defaultDataFormat = defaultProtocol.getDefaultFormat();
          results.put(communicationType, Pair.<Protocol, DataFormat>of(defaultProtocol, defaultDataFormat));
        }
      };
      missingCommunicationTypes.forEach(_function_1);
    };
    mapping.getTechnologies().forEach(_function);
    return results;
  }
  
  /**
   * Helper method to determine effective protocols and data formats of an interface mapping
   */
  private Map<CommunicationType, Pair<Protocol, DataFormat>> getEffectiveProtocolsAndDataFormats(final InterfaceMapping mapping) {
    final Function<MicroserviceMapping, Map<CommunicationType, Pair<Protocol, DataFormat>>> _function = (MicroserviceMapping it) -> {
      return this.getEffectiveProtocolsAndDataFormats(it);
    };
    return this.<MicroserviceMapping>getEffectiveProtocolsAndDataFormats(mapping.getProtocols(), mapping.getMicroserviceMapping(), _function);
  }
  
  /**
   * Helper method to determine effective protocols and data formats of an operation mapping
   */
  private Map<CommunicationType, Pair<Protocol, DataFormat>> getEffectiveProtocolsAndDataFormats(final OperationMapping mapping) {
    final Function<MicroserviceMapping, Map<CommunicationType, Pair<Protocol, DataFormat>>> _function = (MicroserviceMapping it) -> {
      return this.getEffectiveProtocolsAndDataFormats(it);
    };
    return this.<MicroserviceMapping>getEffectiveProtocolsAndDataFormats(mapping.getProtocols(), mapping.getMicroserviceMapping(), _function);
  }
  
  /**
   * Helper method to determine effective protocols and data formats of a referred operation
   * mapping
   */
  private Map<CommunicationType, Pair<Protocol, DataFormat>> getEffectiveProtocolsAndDataFormats(final ReferredOperationMapping mapping) {
    final Function<MicroserviceMapping, Map<CommunicationType, Pair<Protocol, DataFormat>>> _function = (MicroserviceMapping it) -> {
      return this.getEffectiveProtocolsAndDataFormats(it);
    };
    return this.<MicroserviceMapping>getEffectiveProtocolsAndDataFormats(mapping.getProtocols(), 
      mapping.getMicroserviceMapping(), _function);
  }
  
  /**
   * Helper method to determine effective protocol and data format for a parameter mapping with
   * consideration of its communication type
   */
  private Pair<Protocol, DataFormat> getEffectiveProtocolAndDataFormat(final ParameterMapping mapping) {
    final Map<CommunicationType, Pair<Protocol, DataFormat>> operationProtocolsAndDataFormats = this.getEffectiveProtocolsAndDataFormats(mapping.getOperationMapping());
    return operationProtocolsAndDataFormats.get(mapping.getParameter().getCommunicationType());
  }
  
  /**
   * Helper method to determine effective protocols and data formats from technology-specific
   * protocol specifications and possibly the containing concept, if protocol and data format
   * couldn't be determined for a communication type.
   * 
   * The method takes the following type arguments:
   *     - CONTAINER: The container of the technology-specific protocol specifications.
   * 
   * The function argument of the method returns for a given CONTAINER object the effective
   * protocols and data formats.
   */
  protected <CONTAINER extends EObject> Map<CommunicationType, Pair<Protocol, DataFormat>> getEffectiveProtocolsAndDataFormats(final List<TechnologySpecificProtocolSpecification> protocolSpecifications, final CONTAINER container, final Function<CONTAINER, Map<CommunicationType, Pair<Protocol, DataFormat>>> getFromContainer) {
    final Map<CommunicationType, Pair<Protocol, DataFormat>> results = CollectionLiterals.<CommunicationType, Pair<Protocol, DataFormat>>newHashMap();
    final ArrayList<CommunicationType> missingCommunicationTypes = CollectionLiterals.<CommunicationType>newArrayList();
    ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, 2, true);
    for (final Integer i : _doubleDotLessThan) {
      {
        CommunicationType _switchResult = null;
        if (i != null) {
          switch (i) {
            case 0:
              _switchResult = CommunicationType.ASYNCHRONOUS;
              break;
            case 1:
              _switchResult = CommunicationType.SYNCHRONOUS;
              break;
          }
        }
        final CommunicationType communicationType = _switchResult;
        Protocol protocol = null;
        DataFormat dataFormat = null;
        final Function1<TechnologySpecificProtocolSpecification, Boolean> _function = (TechnologySpecificProtocolSpecification it) -> {
          CommunicationType _communicationType = it.getCommunicationType();
          return Boolean.valueOf(Objects.equal(_communicationType, communicationType));
        };
        TechnologySpecificProtocolSpecification protocolSpecification = IterableExtensions.<TechnologySpecificProtocolSpecification>findFirst(protocolSpecifications, _function);
        if ((((protocolSpecification != null) && 
          (protocolSpecification.getTechnologySpecificProtocol() != null)) && 
          (protocolSpecification.getTechnologySpecificProtocol().getProtocol() != null))) {
          protocol = protocolSpecification.getTechnologySpecificProtocol().getProtocol();
          DataFormat _elvis = null;
          DataFormat _dataFormat = protocolSpecification.getTechnologySpecificProtocol().getDataFormat();
          if (_dataFormat != null) {
            _elvis = _dataFormat;
          } else {
            DataFormat _defaultFormat = protocol.getDefaultFormat();
            _elvis = _defaultFormat;
          }
          dataFormat = _elvis;
        }
        if ((protocol != null)) {
          results.put(communicationType, Pair.<Protocol, DataFormat>of(protocol, dataFormat));
        } else {
          missingCommunicationTypes.add(communicationType);
        }
      }
    }
    if ((((container != null) && (getFromContainer != null)) && (!missingCommunicationTypes.isEmpty()))) {
      final Map<CommunicationType, Pair<Protocol, DataFormat>> containerResults = getFromContainer.apply(container);
      final Function1<Map.Entry<CommunicationType, Pair<Protocol, DataFormat>>, Boolean> _function = (Map.Entry<CommunicationType, Pair<Protocol, DataFormat>> it) -> {
        return Boolean.valueOf(missingCommunicationTypes.contains(it.getKey()));
      };
      final Consumer<Map.Entry<CommunicationType, Pair<Protocol, DataFormat>>> _function_1 = (Map.Entry<CommunicationType, Pair<Protocol, DataFormat>> it) -> {
        results.put(it.getKey(), it.getValue());
      };
      IterableExtensions.<Map.Entry<CommunicationType, Pair<Protocol, DataFormat>>>filter(containerResults.entrySet(), _function).forEach(_function_1);
    }
    return results;
  }
}
