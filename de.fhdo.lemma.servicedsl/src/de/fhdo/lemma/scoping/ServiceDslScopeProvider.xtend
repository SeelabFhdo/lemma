/*
 * generated by Xtext 2.12.0
 */
package de.fhdo.lemma.scoping

import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import de.fhdo.lemma.service.ServicePackage
import org.eclipse.xtext.naming.QualifiedName
import org.eclipse.xtext.scoping.impl.MapBasedScope
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.EcoreUtil2
import de.fhdo.lemma.data.DataModel
import org.eclipse.xtext.resource.EObjectDescription
import de.fhdo.lemma.service.ImportedType
import de.fhdo.lemma.technology.Technology
import org.eclipse.xtext.scoping.Scopes
import de.fhdo.lemma.service.Microservice
import de.fhdo.lemma.service.ServiceModel
import de.fhdo.lemma.service.Parameter
import de.fhdo.lemma.service.Interface
import de.fhdo.lemma.service.ReferredOperation
import java.util.List
import de.fhdo.lemma.service.PossiblyImportedInterface
import de.fhdo.lemma.service.Import
import de.fhdo.lemma.service.PossiblyImportedOperation
import de.fhdo.lemma.service.PossiblyImportedMicroservice
import de.fhdo.lemma.service.Operation
import com.google.common.base.Predicate
import org.eclipse.xtext.resource.IEObjectDescription
import de.fhdo.lemma.service.ImportedProtocolAndDataFormat
import de.fhdo.lemma.service.ProtocolSpecification
import de.fhdo.lemma.technology.CommunicationType
import de.fhdo.lemma.service.ImportedServiceAspect
import de.fhdo.lemma.technology.ExchangePattern
import de.fhdo.lemma.technology.ServiceAspect
import de.fhdo.lemma.technology.TechnologyPackage
import de.fhdo.lemma.technology.TechnologySpecificPropertyValueAssignment
import de.fhdo.lemma.technology.JoinPointType
import de.fhdo.lemma.technology.Protocol
import de.fhdo.lemma.technology.DataFormat
import java.util.Map
import com.google.common.base.Function
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import java.util.regex.Pattern
import de.fhdo.lemma.service.TechnologyReference
import de.fhdo.lemma.utils.LemmaUtils

/**
 * This class implements a custom scope provider for the Service DSL.
 *
 * @author <a href="mailto:florian.rademacher@fh-dortmund.de">Florian Rademacher</a>
 */
class ServiceDslScopeProvider extends AbstractServiceDslScopeProvider {
    // TODO: Inheritance of microservices
    //@Inject
    //private ServiceDslQualifiedNameProvider nameProvider

    /**
     * Build scope for a given context and a given reference
     */
    override getScope(EObject context, EReference reference) {
        val scope = switch (context) {
            /* Microservices */
            Microservice: context.getScope(reference)

            /* Technology references */
            TechnologyReference: context.getScope(reference)

            /* Interfaces */
            Interface: context.getScope(reference)

            /* Operations */
            Operation: context.getScope(reference)

            /* Possibly imported microservices */
            PossiblyImportedMicroservice: context.getScope(reference)

            /* Possibly imported interfaces */
            PossiblyImportedInterface: context.getScope(reference)

            /* Possibly imported operations */
            PossiblyImportedOperation: context.getScope(reference)

            /* Parameters */
            Parameter: context.getScope(reference)

            /* Referred operations */
            ReferredOperation: context.getScope(reference)

            /* Imported type */
            ImportedType: context.getScope(reference)

            /* Protocol specification */
            ProtocolSpecification: context.getScope(reference)

            /* Imported protocol and data format */
            ImportedProtocolAndDataFormat: context.getScope(reference)

            /* Imported service aspects */
            ImportedServiceAspect: context.getScope(reference)

            /* Technology-specific property value assignments */
            TechnologySpecificPropertyValueAssignment: context.getScope(reference)
        }

        if (scope !== null)
            return scope
        // Try default scope resolution, if no scope could be determined
        else if (scope === null)
            return super.getScope(context, reference)
    }

    /**
     * Build scope for microservices and the given reference
     */
    private def getScope(Microservice microservice, EReference reference) {
        switch (reference) {
            /* Super microservices */
            // TODO: Inheritance of microservices
            //case ServicePackage::Literals.MICROSERVICE__SUPER:
            //    return microservice.getScopeForSuperMicroservice(reference)

            /*
             * Available imports and their aliases for possibly imported microservices, interfaces
             * and operations that could potentially be required by a microservice
             */
            case ServicePackage::Literals.POSSIBLY_IMPORTED_MICROSERVICE__IMPORT,
                case ServicePackage::Literals.POSSIBLY_IMPORTED_INTERFACE__IMPORT,
                case ServicePackage::Literals.POSSIBLY_IMPORTED_OPERATION__IMPORT:
                return microservice.getScopeForImportsOfType(ServiceModel)

            /*
             * Possibly imported, required microservices (will be passed by the scope provider in
             * the context of a Microservice, if no import is given. Otherwise this will happen with
             * an instance of the PossiblyImportedMicroservice concept as the context).
             */
            case ServicePackage::Literals.POSSIBLY_IMPORTED_MICROSERVICE__MICROSERVICE:
                return microservice.getScopeForPossiblyImportedMicroservice()

            /*
             * Possibly imported, required interfaces (will be passed by the scope provider in the
             * context of a Microservice, if no import is given. Otherwise this will happen with an
             * instance of the PossiblyImportedInterface concept as the context).
             */
            case ServicePackage::Literals.POSSIBLY_IMPORTED_INTERFACE__INTERFACE:
                return microservice.getScopeForPossiblyImportedInterface()

            /*
             * Possibly imported, required operations (will be passed by the scope provider in the
             * context of a Microservice, if no import is given. Otherwise this will happen with an
             * instance of the PossiblyImportedOperation concept as the context).
             */
            case ServicePackage::Literals.POSSIBLY_IMPORTED_OPERATION__OPERATION:
                return microservice.getScopeForPossiblyImportedOperation()

            /* Import aliases of annotated endpoints */
            case ServicePackage::Literals.IMPORTED_PROTOCOL_AND_DATA_FORMAT__IMPORT:
                return microservice.getServiceTechnologyImportAliasesAsScope()
        }

        return null
    }

    /**
     * Build scope for technology references and the given reference
     */
    private def getScope(TechnologyReference technologyReference, EReference reference) {
        switch (reference) {
            /* Technology */
            case ServicePackage::Literals.TECHNOLOGY_REFERENCE__TECHNOLOGY:
                return technologyReference.getScopeForImportsOfType(Technology)
        }

        return null
    }

    /**
     * Build scope for interfaces and the given reference
     */
    private def getScope(Interface ^interface, EReference reference) {
        switch (reference) {
            /* Import aliases of annotated endpoints */
            case ServicePackage::Literals.IMPORTED_PROTOCOL_AND_DATA_FORMAT__IMPORT:
                return interface.getServiceTechnologyImportAliasesAsScope()
        }

        return null
    }

    /**
     * Build scope for operations and the given reference
     */
    private def getScope(Operation operation, EReference reference) {
        switch (reference) {
            /* Import aliases of annotated endpoints */
            case ServicePackage::Literals.IMPORTED_PROTOCOL_AND_DATA_FORMAT__IMPORT:
                return operation.getServiceTechnologyImportAliasesAsScope()
        }

        return null
    }

    /**
     * Build scope for possibly imported microservices and the given reference
     */
    private def getScope(PossiblyImportedMicroservice importedMicroservice, EReference reference) {
        switch (reference) {
            /*
             * Available imports and their aliases for possibly imported microservices that could
             * potentially be required by a microservice
             */
            case ServicePackage::Literals.POSSIBLY_IMPORTED_MICROSERVICE__IMPORT:
                return importedMicroservice.getScopeForImportsOfType(ServiceModel)

            /*
             * Possibly imported, required microservices. The scope provider will delegate the scope
             * resolution with PossiblyImportedMicroservice as the context, if its import feature
             * was set. Otherwise, the context will be an instance of Microservice (see above).
             */
            case ServicePackage::Literals.POSSIBLY_IMPORTED_MICROSERVICE__MICROSERVICE:
                return importedMicroservice
                    .getScopeForPossiblyImportedMicroservice(importedMicroservice.import)
        }

        return null
    }

    /**
     * Build scope for possibly imported interface and the given reference
     */
    private def getScope(PossiblyImportedInterface importedInterface, EReference reference) {
        switch (reference) {
            /*
             * Available imports and their aliases for possibly imported interfaces that could
             * potentially be required by a microservice
             */
            case ServicePackage::Literals.POSSIBLY_IMPORTED_INTERFACE__IMPORT:
                return importedInterface.getScopeForImportsOfType(ServiceModel)

            /*
             * Possibly imported, required interfaces. The scope provider will delegate the scope
             * resolution with PossiblyImportedInterface as the context, if its import feature was
             * set. Otherwise, the context will be an instance of Microservice (see above).
             */
            case ServicePackage::Literals.POSSIBLY_IMPORTED_INTERFACE__INTERFACE:
                return importedInterface
                    .getScopeForPossiblyImportedInterface(importedInterface.import)
        }

        return null
    }

    /**
     * Build scope for possibly imported operation and the given reference
     */
    private def getScope(PossiblyImportedOperation importedOperation, EReference reference) {
        switch (reference) {
            /*
             * Available imports and their aliases for possibly imported operations that could
             * potentially be required by a microservice
             */
            case ServicePackage::Literals.POSSIBLY_IMPORTED_OPERATION__IMPORT:
                return importedOperation.getScopeForImportsOfType(ServiceModel)

            /*
             * Possibly imported, required operations. The scope provider will delegate the scope
             * resolution with PossiblyImportedOperation as the context, if its import feature was
             * set. Otherwise, the context will be an instance of Microservice (see above).
             */
            case ServicePackage::Literals.POSSIBLY_IMPORTED_OPERATION__OPERATION:
                return importedOperation
                    .getScopeForPossiblyImportedOperation(importedOperation.import)
        }

        return null
    }

    /**
     * Build scope for parameters of operations
     */
    private def getScope(Parameter parameter, EReference reference) {
        switch (reference) {
            /*
             * Available imports and their aliases for possibly imported operations that could
             * potentially initialize the parameter
             */
            case ServicePackage::Literals.POSSIBLY_IMPORTED_OPERATION__IMPORT:
                return parameter.getScopeForOperationImport()

            /*
             * Possibly imported operations that may initialize the parameter. The scope provider
             * will delegate the scope resolution with Parameter as the context, if its import
             * feature was set. Otherwise, the context will be an instance of Microservice (see
             * above).
             */
            case ServicePackage::Literals.POSSIBLY_IMPORTED_OPERATION__OPERATION:
                return parameter.getScopeForInitializingOperation()

            /*
             * Available imports and their aliases for imported types of operation parameters. The
             * scope provider will delegate the scope resolution with Parameter as the context, if
             * its import feature was not set. Otherwise, the context will be an instance of
             * ImportedType (see below).
             */
            case ServicePackage::Literals.IMPORTED_TYPE__IMPORT:
                return parameter.getScopeForImportedTypeImport()
        }

        return null
    }

    /**
     * Build scope for referred operations in interfaces
     */
    private def getScope(ReferredOperation operation, EReference reference) {
        switch (reference) {
            /* Operations to refer to */
            case ServicePackage::Literals.REFERRED_OPERATION__OPERATION:
                return operation.getScopeForReferableOperation()

            /* Import aliases of annotated endpoints */
            case ServicePackage::Literals.IMPORTED_PROTOCOL_AND_DATA_FORMAT__IMPORT:
                return operation.getServiceTechnologyImportAliasesAsScope()
        }

        return null
    }

    /**
     * Build scope for operation to refer to
     */
    def getScopeForReferableOperation(ReferredOperation operation) {
        // The interface may refer to all operations of its siblings, i.e., all interfaces of its
        // containing microservice
        val scopeElements = EcoreUtil2.getSiblingsOfType(operation.interface, Interface)
            .map[it.operations]
            .flatten
            // Prevent NullPointerException when DSL code contains syntax errors
            .filter[it.name !== null]
            .map[
                val operationName = if (it.interface.version !== null)
                        QualifiedName.create(it.interface.version, it.interface.name, it.name)
                    else
                        QualifiedName.create(it.interface.name, it.name)
                EObjectDescription.create(operationName, it)
            ]

        return MapBasedScope.createScope(IScope.NULLSCOPE, scopeElements)
    }

    /**
     * Build scope for imported types of operation parameters
     */
    private def getScope(ImportedType importedType, EReference reference) {
        switch (reference) {
            /*
             * Available imports and their aliases for imported types used to specify the parameter
             */
            case ServicePackage::Literals.IMPORTED_TYPE__IMPORT:
                return importedType.getScopeForImportedTypeImport()

            /* Type of an imported type */
            case ServicePackage::Literals.IMPORTED_TYPE__TYPE:
                return importedType.getScopeForImportedType()
        }

        return null
    }

    /**
     * Build scope for allowed imports of imported types of operation parameters
     */
    private def getScopeForImportedTypeImport(EObject context) {
        // For the specification of an operation parameter's type, imported types from data models
        // or technologies may be used
        val dataModelImports = context.getScopeForImportsOfType(DataModel)
        val technologyImportAliases = context.getServiceTechnologyImportAliasesAsScope()
        if (technologyImportAliases !== IScope.NULLSCOPE)
            return LemmaUtils.mergeScopes(dataModelImports, technologyImportAliases)
        else
            return dataModelImports
    }

    /**
     * Build scope for imported types of operation parameters
     */
    private def getScopeForImportedType(ImportedType importedType) {
        val resourceContents = LemmaUtils.getImportedModelContents(importedType.eResource,
            importedType.import.importURI)
        if (resourceContents === null || resourceContents.empty)
            return IScope.NULLSCOPE

        // Types may be imported from data models (complex types) or technology models (technology-
        // specific types)
        val resourceRoot = resourceContents.get(0)
        switch (resourceRoot) {
            DataModel: return resourceRoot.getScopeForImportedComplexTypes
            Technology: return resourceRoot.getScopeForImportedTypes
            default: return IScope.NULLSCOPE
        }
    }

    /**
     * Build scope for imported protocols used to annotate microservices, interfaces, or
     * operations
     */
    private def getScope(ImportedProtocolAndDataFormat importedProtocol, EReference reference) {
        switch (reference) {
            /*
             * Available imports and their aliases for protocols imported from technology models
             * for the annotated element
             */
            case ServicePackage.Literals.IMPORTED_PROTOCOL_AND_DATA_FORMAT__IMPORT:
                return importedProtocol.getServiceTechnologyImportAliasesAsScope()

            /* Protocols */
            case ServicePackage::Literals.IMPORTED_PROTOCOL_AND_DATA_FORMAT__IMPORTED_PROTOCOL:
                return importedProtocol.getScopeForImportedProtocol()

            /* Data formats corresponding to an imported protocol */
            case ServicePackage::Literals.IMPORTED_PROTOCOL_AND_DATA_FORMAT__DATA_FORMAT:
                return importedProtocol.getScopeForDataFormat()
        }

        return null
    }

    /**
     * Build scope for imported service aspects used to annotate microservices, interfaces,
     * operations, or parameters
     */
    private def getScope(ImportedServiceAspect importedAspect, EReference reference) {
        switch (reference) {
            /*
             * Available imports and their aliases for aspects imported from technology models
             * for the annotated element
             */
            case ServicePackage.Literals.IMPORTED_SERVICE_ASPECT__IMPORT:
                return importedAspect.getServiceTechnologyImportAliasesAsScope()

            /* Imported aspects */
            case ServicePackage.Literals.IMPORTED_SERVICE_ASPECT__IMPORTED_ASPECT:
                return importedAspect.getScopeForImportedAspect()

            /* Properties */
            case TechnologyPackage.Literals.TECHNOLOGY_SPECIFIC_PROPERTY_VALUE_ASSIGNMENT__PROPERTY:
                return importedAspect.getScopeForAspectProperty()
        }

        return null
    }

    /**
     * Build scope for technology-specific value assignment
     */
    private def getScope(TechnologySpecificPropertyValueAssignment assignment,
        EReference reference) {
        switch (reference) {
            /*
             * Properties. The scope provider will pass TechnologySpecificPropertyValueAssignment as
             * context of a value assignment to a service aspect property, if the property received
             * a value.
             */
            case TechnologyPackage.Literals.TECHNOLOGY_SPECIFIC_PROPERTY_VALUE_ASSIGNMENT__PROPERTY:
                return assignment.getScopeForAspectProperty()
        }

        return null
    }

    /**
     * Build scope for aspect properties
     */
    private def getScopeForAspectProperty(EObject container) {
        // If we're inside an assignment, we need to return all available properties. Otherwise a
        // cyclic link resolution exception will occur. However, this also gives rise to possible
        // duplicate specification of properties for several value assignments. These duplicates get
        // checked in addition by the validator.
        if (container instanceof TechnologySpecificPropertyValueAssignment) {
            val aspect = EcoreUtil2.getContainerOfType(container, ImportedServiceAspect)
            return Scopes::scopeFor(aspect.importedAspect.properties)

        // If we're inside the aspect itself, i.e., when the modeler _just_ begins to express a new
        // value assignment for a property, we only provide those properties that haven't received
        // values yet
        } else if (container instanceof ImportedServiceAspect) {
            val alreadyUsedProperties = <String> newHashSet
            container.values.forEach[
                if (value !== null)
                    alreadyUsedProperties.add(property.name)
            ]

            val availableProperties = container.importedAspect.properties
                .filter[!alreadyUsedProperties.contains(name)]
            return Scopes::scopeFor(availableProperties)
        }
        else
            return IScope.NULLSCOPE
    }

    /**
     * Build scope for aspect of imported service aspect
     */
    private def getScopeForImportedAspect(ImportedServiceAspect importedAspect) {
        var ExchangePattern forExchangePattern
        var CommunicationType forCommunicationType
        var List<Pair<Protocol, DataFormat>> forProtocolsAndDataFormats
        val aspectContainer = importedAspect.eContainer

        /*
         * Determine the join point and relevant pointcut values depending on the container in which
         * the aspect is used
         */
        var bypassFilter = false
        val joinPoint = switch (aspectContainer) {
            Microservice: {
                forProtocolsAndDataFormats = aspectContainer
                    .effectiveProtocolsAndDataFormats.values.toList

                JoinPointType.MICROSERVICES
            }
            Interface: {
                // Check if the aspect is to be really annotated on an interface or the first
                // operation _within_ an interface already. This hack is necessary, because due to
                // the design of the Service DSL grammar, Xtext cannot itself distinguish between
                // the beginning of an operation or an interface, right after the parser has entered
                // the interface rule. This resulted in the scope provider returning interface
                // instead of operation aspects for the first operation within an interface, when
                // the user requested code completion.
                if (!importedAspect.onFirstInterfaceOperation) {
                    forProtocolsAndDataFormats = aspectContainer
                        .effectiveProtocolsAndDataFormats.values.toList

                    JoinPointType.INTERFACES
                } else {
                    // One disadvantage of the "fix" to prevent wrong aspects when code completion
                    // on the first operation within an interface is requested is that we do not
                    // have access to the Operation EObject at this point in time. Hence, is is
                    // possible that the user won't see any aspects in the completion suggestions,
                    // when all aspects in the technology model exhibit selectors. Therefore, we
                    // bypass the filter for now and show the user all operation aspects of the
                    // technology model. If the user then selects a non-matching aspect, this will
                    // lead to a reference error. However, this error is better than to show
                    // no selection (and thus no possibly matching aspects) at all.
                    bypassFilter = true
                    JoinPointType.OPERATIONS
                }
            }
            Operation: {
                forProtocolsAndDataFormats = aspectContainer
                    .effectiveProtocolsAndDataFormats.values.toList

                JoinPointType.OPERATIONS
            }
            ReferredOperation: {
                forProtocolsAndDataFormats = aspectContainer
                    .effectiveProtocolsAndDataFormats.values.toList

                JoinPointType.OPERATIONS
            }
            Parameter: {
                forCommunicationType = aspectContainer.communicationType
                forExchangePattern = aspectContainer.exchangePattern
                val effectiveProtocolAndDataFormat = aspectContainer.effectiveProtocolAndDataFormat
                forProtocolsAndDataFormats = if (effectiveProtocolAndDataFormat !== null)
                        #[effectiveProtocolAndDataFormat]
                    else
                        null

                JoinPointType.PARAMETERS
            }
        }

        /*
         * Get the contents of the resource, i.e., the technology model, from which aspects may be
         * imported
         */
        val resourceContents = LemmaUtils.getImportedModelContents(importedAspect.eResource,
            importedAspect.import.importURI)
        if (resourceContents === null || resourceContents.empty)
            return IScope.NULLSCOPE

        /*
         * Get the relevant aspects for the determined join point and the respective pointcut values
         */
        val declaredAspectsForJoinPoint = (resourceContents.get(0) as Technology).serviceAspects
            .filter[joinPoints.contains(joinPoint)].toList
        val scopeAspects = if (!bypassFilter)
                filterAspectsForMatching(joinPoint, declaredAspectsForJoinPoint, forExchangePattern,
                    forCommunicationType, forProtocolsAndDataFormats)
            else
                declaredAspectsForJoinPoint
        val scopeElements = scopeAspects.map[
            val protocolName = QualifiedName.create(it.getQualifiedNameParts(false, true))
            EObjectDescription.create(protocolName, it)
        ]
        return MapBasedScope.createScope(IScope.NULLSCOPE, scopeElements)
    }

    /**
     * Helper to determine scope aspects from pointcut selector values
     */
    protected def filterAspectsForMatching(JoinPointType joinPoint, List<ServiceAspect> aspects,
        ExchangePattern exchangePattern, CommunicationType communicationType,
        List<Pair<Protocol, DataFormat>> protocolsAndFormats) {
        if (protocolsAndFormats === null || protocolsAndFormats.empty)
            return findMatchingAspects(joinPoint, aspects, exchangePattern, communicationType, null,
                null)

        val uniqueMatchingAspects = <ServiceAspect>newHashSet
        for (protocolAndFormat : protocolsAndFormats)
            uniqueMatchingAspects.addAll(findMatchingAspects(joinPoint, aspects, exchangePattern,
                communicationType, protocolAndFormat.key, protocolAndFormat.value))
        return uniqueMatchingAspects
    }

    /**
     * Filter a list of service aspects for those for which either the passed pointcut selector
     * values are not applicable or, in case they are applicable, for those that match the given
     * pointcut selector values
     */
    private def findMatchingAspects(JoinPointType joinPoint, List<ServiceAspect> aspects,
        ExchangePattern exchangePattern, CommunicationType communicationType, Protocol protocol,
        DataFormat dataFormat) {
        val matchingAspects = <ServiceAspect> newArrayList

        aspects.forEach[aspect |
            val validPointcutSelector = aspect.isValidSelectorForJoinPoint(joinPoint,
                exchangePattern, communicationType, protocol, dataFormat)

            val matchingAspect = if (validPointcutSelector)
                    aspect.hasMatchingSelector(exchangePattern, communicationType, protocol,
                        dataFormat)
                else
                    true

            if (matchingAspect)
                matchingAspects.add(aspect)
        ]

        return matchingAspects
    }

    /**
     * Helper to determine if an aspect is to be annotated on an interface or the first operation
     * _within_ an interface
     */
    private def onFirstInterfaceOperation(ImportedServiceAspect aspect) {
        val textBeforeAspect = NodeModelUtils.getNode(aspect)?.parent?.text
        if (textBeforeAspect === null)
            return false

        val interfaceKeywordInText = Pattern.compile("(.*\\s+interface\\s+.*)|(.*\\s+interface)")
        return !interfaceKeywordInText.matcher(textBeforeAspect).find
    }

    /**
     * Get the annotated technologies of a microservice, that is the container of the given context,
     * as scopes
     */
    private def getServiceTechnologyImportAliasesAsScope(EObject context) {
        val microservice = EcoreUtil2.getContainerOfType(context, Microservice)
        if (microservice === null || microservice.technologyReferences.empty)
            return IScope::NULLSCOPE

        return Scopes::scopeFor(microservice.technologyReferences.map[technology])
    }

    /**
     * Convenience method for building a scope for a possibly imported microservice without an
     * import specification
     */
    private def getScopeForPossiblyImportedMicroservice(EObject context) {
        return getScopeForPossiblyImportedMicroservice(context, null)
    }

    /**
     * Helper method to build a scope for possibly imported microservices, i.e., a microservice
     * with or without import specifications. Microservices required by another microservice may
     * possibly be imported.
     */
    private def getScopeForPossiblyImportedMicroservice(EObject context, Import ^import) {
        if (!(
            context instanceof Microservice ||
            context instanceof PossiblyImportedMicroservice
        ))
            return IScope.NULLSCOPE

        /* Determine relevant microservice */
        val microservice =
            switch (context) {
                Microservice: context as Microservice

                // Possibly imported microservice is required by microservice
                PossiblyImportedMicroservice: EcoreUtil2.getContainerOfType(context, Microservice)
            }

        /*
         * Build the scope considering possible import specification:
         *     - If no import specification is given, get all microservices that can be required by
         *       by the determined microservice from the current service model.
         *     - If an import specification is given, get all microservices that can be required by
         *       the determined microservice from the service model the import specification points
         *       to.
         */
        val importUri = if (import !== null) import.importURI else null
        return LemmaUtils.getScopeForPossiblyImportedConcept(
            microservice,
            microservice.qualifiedNameParts,
            ServiceModel,
            importUri,
            [microservices.toList],
            [qualifiedNameParts],
            [microservice.canRequire(it, importUri !== null)]
        )
    }

    /**
     * Convenience method to build a scope for a possibly imported interface without an import
     * specification
     */
    private def getScopeForPossiblyImportedInterface(EObject context) {
        return getScopeForPossiblyImportedInterface(context, null)
    }

    /**
     * Build scope for possibly imported interfaces, i.e., interfaces with or without import
     * specifications. Interfaces required by a microservice may possibly be imported.
     */
    private def getScopeForPossiblyImportedInterface(EObject context, Import ^import) {
        if (!(
            context instanceof Microservice ||
            context instanceof PossiblyImportedInterface
        ))
            return IScope.NULLSCOPE

        /* Determine relevant microservice */
        val microservice =
            switch (context) {
                Microservice: context as Microservice

                // Possibly imported interface is required by microservice
                PossiblyImportedInterface: EcoreUtil2.getContainerOfType(context, Microservice)
            }

        /*
         * Build the scope considering possible import specification:
         *     - If no import specification is given, get all interfaces that can be required by
         *       by the determined microservice from the current service model.
         *     - If an import specification is given, get all interfaces that can be required by
         *       the determined microservice from the service model the import specification points
         *       to.
         */
        val importUri = if (import !== null) import.importURI else null
        return LemmaUtils.getScopeForPossiblyImportedConcept(
            microservice,
            microservice.qualifiedNameParts,
            ServiceModel,
            importUri,
            [containedInterfaces.toList],
            [qualifiedNameParts],
            [microservice.canRequire(it, importUri !== null)]
        )
    }

    /**
     * Convenience method to build a scope for a possibly imported operation without an import
     * specification
     */
    private def getScopeForPossiblyImportedOperation(EObject context) {
        return getScopeForPossiblyImportedOperation(context, null)
    }

    /**
     * Build scope for possibly imported operations, i.e., operations with or without import
     * specifications. Operations required by a microservice or used to initialize parameters of
     * other operations may possibly be imported.
     */
    private def getScopeForPossiblyImportedOperation(EObject context, Import ^import) {
        if (!(
            context instanceof Microservice ||
            context instanceof PossiblyImportedOperation
        ))
            return IScope.NULLSCOPE

        /* Prepare scope resolution */
        var EObject scopeContainer = null
        var List<String> scopeContainerNameParts = null
        val predicates = <Predicate<Operation>> newArrayList
        val importUri = if (import !== null) import.importURI else null
        switch (context) {
            // Operations required by microservices (context is Microservice, if user has not
            // entered an operation or import alias)
            Microservice: {
                val microservice = context
                scopeContainer = microservice
                scopeContainerNameParts = microservice.qualifiedNameParts
                predicates.add([context.canRequire(it, importUri !== null)])
            }

            // Operations required by microservices (context is PossiblyImportedOperation, if user
            // has entered an operation or import alias)
            PossiblyImportedOperation case context.eContainer instanceof Microservice: {
                val microservice = context.eContainer as Microservice
                scopeContainer = microservice
                scopeContainerNameParts = microservice.qualifiedNameParts
                predicates.add([microservice.canRequire(it, importUri !== null)])
            }

            // Initializing operations of parameter
            PossiblyImportedOperation case context.eContainer instanceof Parameter: {
                val operation = EcoreUtil2.getContainerOfType(context, Operation)
                scopeContainer = operation
                scopeContainerNameParts = operation.qualifiedNameParts
                predicates.add([(context.eContainer as Parameter).basicallyInitializableBy(it)])
            }
        }

        return LemmaUtils.getScopeForPossiblyImportedConcept(
            scopeContainer,
            scopeContainerNameParts,
            ServiceModel,
            importUri,
            [containedOperations.toList],
            [qualifiedNameParts],
            predicates
        )
    }

    /**
     * Build scope for imports of possibly imported Operations
     */
    private def getScopeForOperationImport(Parameter parameter) {
        val containingMicroservice = EcoreUtil2.getContainerOfType(parameter, Microservice)
        return Scopes::scopeFor(containingMicroservice.requiredImports)
    }

    /**
     * Build scope for initializing operations
     */
    private def getScopeForInitializingOperation(Parameter parameter) {
        val microservice = EcoreUtil2.getContainerOfType(parameter, Microservice)
        val import = parameter.initializedByOperation.import

        // Candidates for initializing operations are all operations directly or indirectly required
        // by a microservice (possibly imported), and all operations of the service itself, in case
        // no import alias was specified
        val candidateOperations = <Operation> newHashSet(
            microservice.getAllRequiredOperations(import))
        if (import === null) {
            val localOperations = microservice.containedOperations
            candidateOperations.addAll(localOperations)
        }

        val operation = EcoreUtil2.getContainerOfType(parameter, Operation)
        return LemmaUtils.getScopeWithRelativeQualifiedNames(
            candidateOperations.toList,
            [qualifiedNameParts],
            operation,
            operation.qualifiedNameParts,
            ServiceModel,
            [parameter.basicallyInitializableBy(it)]
        )
    }

    // TODO: Inheritance of microservices
    /**
     * Build scope for super microservices considering custom, version-aware name provider
     */
    /*private def getScopeForSuperMicroservice(Microservice microservice, EReference reference) {
        val serviceModel = microservice.serviceModel
        if (serviceModel === null)
            return IScope.NULLSCOPE

        val scopeElements = serviceModel.microservices.filter[microservice.canExtend(it)]
        return Scopes::scopeFor(scopeElements, nameProvider, IScope.NULLSCOPE)
    }*/

    /**
     * Build scope for imported protocols
     */
    private def getScopeForImportedProtocol(ImportedProtocolAndDataFormat importedProtocol) {
        val resourceContents = LemmaUtils.getImportedModelContents(importedProtocol.eResource,
            importedProtocol.import.importURI)
        if (resourceContents === null || resourceContents.empty)
            return IScope.NULLSCOPE

        // Return scope elements, i.e., defined protocols, that match the ImportedProtocol's
        // communication type if the container is a protocol specification
        val isProtocolSpecification = importedProtocol.specification !== null
        val CommunicationType filterCommunicationType = if (isProtocolSpecification)
            importedProtocol.specification.communicationType

        val resourceRoot = resourceContents.get(0) as Technology
        val scopeElements = resourceRoot.protocols
            .filter[!isProtocolSpecification || filterCommunicationType == communicationType]
            .map[
                val protocolName = QualifiedName.create(it.qualifiedNameParts)
                EObjectDescription.create(protocolName, it)
            ]

        return MapBasedScope.createScope(IScope.NULLSCOPE, scopeElements)
    }

    /**
     * Build scope for data formats of imported protocols
     */
    private def getScopeForDataFormat(ImportedProtocolAndDataFormat importedProtocol) {
        val resourceContents = LemmaUtils.getImportedModelContents(importedProtocol.eResource,
            importedProtocol.import.importURI)
        if (resourceContents === null || resourceContents.empty)
            return IScope.NULLSCOPE

        // May happen if syntax errors in the technology model exist
        val protocolName = importedProtocol.importedProtocol.name
        if (protocolName === null)
            return IScope.NULLSCOPE

        // Return scope elements, i.e., defined data formats, that exist for the ImportedProtocol's
        // protocol
        val resourceRoot = resourceContents.get(0) as Technology
        val scopeElements = resourceRoot.protocols
            // We can use the first protocol we find, as protocol names are unique (ensured by
            // validator of Technology DSL) independent of communication type
            .findFirst[name == protocolName]
            .dataFormats

        return Scopes::scopeFor(scopeElements, [QualifiedName.create(it.formatName)],
            IScope.NULLSCOPE)
    }

    /**
     * Build scope for complex types imported from a data model
     */
    private def getScopeForImportedComplexTypes(DataModel dataModel) {
        val scopeElements = dataModel.containedComplexTypes.map[
            val typeName = QualifiedName.create(it.qualifiedNameParts)
            EObjectDescription.create(typeName, it)
        ]

        return MapBasedScope.createScope(IScope.NULLSCOPE, scopeElements)
    }

    /**
     * Build scope for primitive and complex types imported from technology
     */
    private def getScopeForImportedTypes(Technology technology) {
        val scopeElements = <IEObjectDescription> newArrayList

        // Technology-specific primitive types
        scopeElements.addAll(technology.primitiveTypes.map[
            val typeName = QualifiedName.create(it.qualifiedNameParts)
            EObjectDescription.create(typeName, it)
        ])

        // Technology-specific collection types
        scopeElements.addAll(technology.collectionTypes.map[
            val typeName = QualifiedName.create(it.qualifiedNameParts)
            EObjectDescription.create(typeName, it)
        ])

        // Technology-specific data structures
        scopeElements.addAll(technology.dataStructures.map[
            val typeName = QualifiedName.create(it.qualifiedNameParts)
            EObjectDescription.create(typeName, it)
        ])

        return MapBasedScope.createScope(IScope.NULLSCOPE, scopeElements)
    }

    /**
     * Convenience method to create a scope for imports of certain types
     */
    private def getScopeForImportsOfType(EObject context, Class<? extends EObject>... types) {
        val allImports = EcoreUtil2.getContainerOfType(context, ServiceModel).imports
        val validImports = LemmaUtils.getImportsOfModelTypes(allImports, [it.importURI], types)
        return Scopes::scopeFor(validImports)
    }

    /**
     * Build scope for protocol specifications on microservices, interfaces, and operations
     */
    private def getScope(ProtocolSpecification protocolSpecification, EReference reference) {
        if (reference !== ServicePackage::Literals.IMPORTED_PROTOCOL_AND_DATA_FORMAT__IMPORT)
            return IScope.NULLSCOPE

        return protocolSpecification.getServiceTechnologyImportAliasesAsScope()
    }

    /**
     * Helper method to determine effective protocols and data formats of a microservice
     */
    private def getEffectiveProtocolsAndDataFormats(Microservice microservice) {
        /*
         * Try to get effective protocols and data formats from the service's protocol
         * specifications
         */
        val results = getEffectiveProtocolsAndDataFormats(microservice.protocols, null, null)

        /* Identify missing communication types */
        val missingCommunicationTypes = <CommunicationType> newArrayList
        if (!results.containsKey(CommunicationType.ASYNCHRONOUS))
            missingCommunicationTypes.add(CommunicationType.ASYNCHRONOUS)
        if (!results.containsKey(CommunicationType.SYNCHRONOUS))
            missingCommunicationTypes.add(CommunicationType.SYNCHRONOUS)

        if (missingCommunicationTypes.empty ||  microservice.technologyReferences.empty)
            return results

        /*
         * Complement effective protocols and data formats with the default protocols and data
         * formats of the annotated technology (if any) for missing communication types
         */
        microservice.technologyReferences.map[technology].forEach[
            val resourceContents = LemmaUtils.getImportedModelContents(eResource, importURI)
            if (resourceContents !== null && !resourceContents.empty) {
                val technologyModel = resourceContents.get(0) as Technology
                missingCommunicationTypes.forEach[communicationType |
                    var Protocol defaultProtocol
                    var DataFormat defaultDataFormat

                    defaultProtocol = technologyModel.protocols
                        .filter[it.communicationType == communicationType]
                        .findFirst[^default]

                    if (defaultProtocol !== null)
                        defaultDataFormat = defaultProtocol.defaultFormat

                    if (defaultProtocol !== null)
                        results.put(communicationType, {defaultProtocol -> defaultDataFormat})
                ]
            }
        ]

        return results
    }

    /**
     * Helper method to determine effective protocols and data formats of an interface
     */
    private def getEffectiveProtocolsAndDataFormats(Interface ^interface) {
        // Try to get effective protocols and data formats from the protocol specifications of the
        // interface. If there aren't any, get effective protocols and data formats from the
        // interface's microservice.
        return getEffectiveProtocolsAndDataFormats(interface.protocols, interface.microservice,
            [getEffectiveProtocolsAndDataFormats])
    }

    /**
     * Helper method to determine effective protocols and data formats of an operation
     */
    private def getEffectiveProtocolsAndDataFormats(Operation operation) {
        // Try to get effective protocols and data formats from the protocol specifications of the
        // operation. If there aren't any, get effective protocols and data formats from the
        // operation's interface.
        return getEffectiveProtocolsAndDataFormats(operation.protocols, operation.interface,
            [getEffectiveProtocolsAndDataFormats])
    }

    /**
     * Helper method to determine effective protocols and data formats of a referred operation
     */
    private def getEffectiveProtocolsAndDataFormats(ReferredOperation referredOperation) {
        // Try to get effective protocols and data formats from the protocol specifications of the
        // referred operation. If there aren't any, get effective protocols and data formats from
        // the referred operation's interface.
        return getEffectiveProtocolsAndDataFormats(referredOperation.protocols,
            referredOperation.interface, [getEffectiveProtocolsAndDataFormats])
    }

    /**
     * Helper method to determine effective protocol and data format for a parameter with
     * consideration of its communication type
     */
    private def getEffectiveProtocolAndDataFormat(Parameter parameter) {
        // Try to get effective protocol and data formats from the protocol specifications of the
        // parameter's operation
        val operationProtocolsAndDataFormats = parameter.operation.effectiveProtocolsAndDataFormats
        return operationProtocolsAndDataFormats.get(parameter.communicationType)
    }

    /**
     * Helper method to determine effective protocols and data formats from protocol specifications
     * and possibly the containing concept, if protocol and data format couldn't be determined for a
     * communication type.
     *
     * The method takes the following type arguments:
     *     - CONTAINER: The container of the protocol specifications.
     *
     * The function argument of the method returns for a given CONTAINER object the effective
     * protocols and data formats.
     */
    private def <CONTAINER extends EObject> getEffectiveProtocolsAndDataFormats(
        List<ProtocolSpecification> protocolSpecifications,
        CONTAINER container,
        Function<CONTAINER, Map<CommunicationType, Pair<Protocol, DataFormat>>> getFromContainer) {
        val Map<CommunicationType, Pair<Protocol, DataFormat>> results = newHashMap
        val missingCommunicationTypes = <CommunicationType> newArrayList

        for (i : 0..<2) {
            val communicationType = switch (i) {
                case 0: CommunicationType.ASYNCHRONOUS
                case 1: CommunicationType.SYNCHRONOUS
            }

            // Determine protocol and data format for a given communication from the passed list of
            // protocol specifications
            var Protocol protocol
            var DataFormat dataFormat
            var protocolSpecification = protocolSpecifications
                .findFirst[it.communicationType == communicationType]

            if (protocolSpecification !== null &&
                protocolSpecification.protocol !== null &&
                protocolSpecification.protocol.importedProtocol !== null) {
                protocol = protocolSpecification.protocol.importedProtocol
                dataFormat = protocolSpecification.protocol.dataFormat ?: protocol.defaultFormat
            }

            if (protocol !== null)
                results.put(communicationType, {protocol -> dataFormat})
            else
                missingCommunicationTypes.add(communicationType)
        }

        // For those communication types for which no protocol and data format could be determined,
        // try to gather those from the container and add them to the list of results
        if (container !== null && getFromContainer !== null && !missingCommunicationTypes.empty) {
            val containerResults = getFromContainer.apply(container)
            containerResults.entrySet.filter[missingCommunicationTypes.contains(it.key)]
                .forEach[results.put(it.key, it.value)]
        }

        return results
    }
}
