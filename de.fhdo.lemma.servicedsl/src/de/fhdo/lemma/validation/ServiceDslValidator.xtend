/*
 * generated by Xtext 2.12.0
 */
package de.fhdo.lemma.validation

import org.eclipse.xtext.validation.Check
import de.fhdo.lemma.service.ServicePackage
import de.fhdo.lemma.service.Import
import de.fhdo.lemma.service.Microservice
import de.fhdo.lemma.service.Interface
import de.fhdo.lemma.service.Operation
import de.fhdo.lemma.technology.CommunicationType
import de.fhdo.lemma.service.ServiceModel
import de.fhdo.lemma.ServiceDslQualifiedNameProvider
import com.google.inject.Inject
import de.fhdo.lemma.service.PossiblyImportedOperation
import de.fhdo.lemma.service.PossiblyImportedInterface
import de.fhdo.lemma.technology.ExchangePattern
import de.fhdo.lemma.typechecking.TypeChecker
import de.fhdo.lemma.typechecking.TypesNotCompatibleException
import org.eclipse.xtext.naming.QualifiedName
import de.fhdo.lemma.technology.TechnologySpecificPrimitiveType
import de.fhdo.lemma.data.Type
import de.fhdo.lemma.service.Parameter
import de.fhdo.lemma.technology.Technology
import de.fhdo.lemma.service.ProtocolSpecification
import de.fhdo.lemma.service.ReferredOperation
import de.fhdo.lemma.service.Endpoint
import java.util.List
import org.eclipse.emf.ecore.EObject
import de.fhdo.lemma.data.DataModel
import de.fhdo.lemma.service.Visibility
import de.fhdo.lemma.service.PossiblyImportedMicroservice
import com.google.common.base.Function
import java.util.Map
import de.fhdo.lemma.service.ImportedServiceAspect
import de.fhdo.lemma.technology.TechnologySpecificPropertyValueAssignment
import de.fhdo.lemma.technology.TechnologyPackage
import org.eclipse.xtext.EcoreUtil2
import de.fhdo.lemma.service.TechnologyReference
import de.fhdo.lemma.utils.LemmaUtils
import de.fhdo.lemma.service.ApiOperationComment
import de.fhdo.lemma.service.ApiParameterComment
import de.fhdo.lemma.data.PrimitiveUnspecified

/**
 * This class contains custom validation rules for service models.
 *
 * @author <a href="mailto:florian.rademacher@fh-dortmund.de">Florian Rademacher</a>
 */
class ServiceDslValidator extends AbstractServiceDslValidator {
    @Inject
    ServiceDslQualifiedNameProvider nameProvider

    /**
     * Check if an imported file exists and if it is case sensitive
     */
    @Check
    def checkImportFileExistsAndIsCaseSensitive(Import ^import) {
        val importURI = ^import.importURI
        val eResource = ^import.eResource

        if (!LemmaUtils.importFileExists(eResource, importURI))
            error("File not found", ^import,
                ServicePackage::Literals.IMPORT__IMPORT_URI)
        else if (!LemmaUtils.importFileExistsCaseSensitive(eResource, importURI))
            error("Import paths are case sensitive, but the case sensitivity of this import path " +
                "does not match its appearance in the filesystem", ^import,
                ServicePackage::Literals.IMPORT__IMPORT_URI)
    }

    /**
     * Check import aliases for uniqueness
     */
    @Check
    def checkImportAlias(ServiceModel serviceModel) {
        val duplicateIndex = LemmaUtils.getDuplicateIndex(serviceModel.imports, [name])
        if (duplicateIndex === -1) {
            return
        }

        val duplicate = serviceModel.imports.get(duplicateIndex)
        error('''Duplicate import alias «duplicate.name»''', duplicate,
            ServicePackage::Literals.IMPORT__NAME)
    }

    /**
     * Check that imported file defines a model that fits the given import type
     */
    @Check
    def checkImportType(Import ^import) {
        var Class<? extends EObject> expectedModelType
        var String expectedModelTypeName
        switch (import.importType) {
            case DATATYPES: {
                expectedModelType = DataModel
                expectedModelTypeName = "data"
            }
            case MICROSERVICES: {
                expectedModelType = ServiceModel
                expectedModelTypeName = "service"
            }
            case TECHNOLOGY: {
                expectedModelType = Technology
                expectedModelTypeName = "technology"
            }
            default:
                return
        }

        if (!LemmaUtils.isImportOfType(import.eResource, import.importURI, expectedModelType))
            error('''File does not contain a «expectedModelTypeName» model definition''', import,
                ServicePackage::Literals.IMPORT__IMPORT_URI)
    }

    /**
     * Check that model does not import itself
     */
    @Check
    def checkForSelfImport(ServiceModel thisModel) {
        val importedServiceModels = LemmaUtils.getImportsOfModelTypes(thisModel.imports, [importURI],
            ServiceModel)

        importedServiceModels.forEach[
            val importedRoot = LemmaUtils.getImportedModelContents(eResource, importURI)
            if (!importedRoot.empty && importedRoot.get(0) == thisModel)
                error("Model may not import itself", it,
                    ServicePackage::Literals.IMPORT__IMPORT_URI)
        ]
    }

    /**
     * Check that imported file is imported exactly once
     */
    @Check
    def checkImportFileUniqueness(ServiceModel serviceModel) {
        val absolutePath = LemmaUtils.absolutePath(serviceModel.eResource)
        val absoluteImportPaths = serviceModel.imports.map[
            LemmaUtils.convertToAbsolutePath(importURI, absolutePath)
        ]
        val duplicateIndex = LemmaUtils.getDuplicateIndex(absoluteImportPaths, [it])
        if (duplicateIndex === -1) {
            return
        }

        val duplicate = serviceModel.imports.get(duplicateIndex)
        error("File is already being imported", duplicate,
            ServicePackage::Literals.IMPORT__IMPORT_URI)
    }

    /**
     * Warn about non-unique microservice endpoints' addresses per protocol/data format combination
     */
    @Check
    def warnUniqueEndpointAddresses(ServiceModel serviceModel) {
        val microserviceEndpoints = serviceModel.microservices.map[endpoints].flatten.toList
        warnUniqueEndpointAddresses(microserviceEndpoints, "microservice",
            [microservice.qualifiedNameParts])
    }

    /**
     * Warn about non-unique interface endpoints' addresses per protocol/data format combination
     */
    @Check
    def warnUniqueEndpointAddresses(Microservice microservice) {
        val interfaceEndpoints = microservice.interfaces.map[endpoints].flatten.toList
        warnUniqueEndpointAddresses(interfaceEndpoints, "interface",
            [interface.qualifiedNameParts])
    }

    /**
     * Warn about non-unique operation endpoints' addresses per protocol/data format combination
     */
    @Check
    def warnUniqueEndpointAddresses(Interface ^interface) {
        // Combined check for operations and referred operations
        val List<Endpoint> operationEndpoints = newArrayList
        operationEndpoints.addAll(interface.referredOperations.map[endpoints].flatten)
        operationEndpoints.addAll(interface.operations.map[endpoints].flatten)
        warnUniqueEndpointAddresses(operationEndpoints, "operation", [
            if (operation !== null)
                operation.qualifiedNameParts
            else if (referredOperation !== null)
                referredOperation.qualifiedNameParts
        ])
    }

    /**
     * Check that technology is assigned only once to a microservice
     */
    @Check
    def checkTechnologyUniqueness(Microservice microservice) {
        val duplicateIndex = LemmaUtils.getDuplicateIndex(
            microservice.technologyReferences.map[technology],
            [it]
        )

        if (duplicateIndex > -1)
            error("Duplicate technology assignment",
                ServicePackage::Literals.MICROSERVICE__TECHNOLOGY_REFERENCES, duplicateIndex)
    }

    /**
     * Check that only one annotated technology contains type definitions
     */
    @Check
    def checkUniqueTypeDefinitionTechnology(Microservice microservice) {
        /*
         * Check that only one technology is explicitly marked as containing default type
         * definitions
         */
        val duplicateIndex = LemmaUtils.getDuplicateIndex(
            microservice.technologyReferences.map[isTypeDefinitionTechnology],
            [it], [it === true]
        )
        if (duplicateIndex > -1) {
            error("Only one technology can be the default type definition technology",
                ServicePackage::Literals.MICROSERVICE__TECHNOLOGY_REFERENCES, duplicateIndex)
            return
        }

        /*
         * Check that one technology is explicitly marked as containing default definitions, if more
         * than one technology defines types
         */
        // If one technology has been chosen to provide default types, no ambiguity regarding
        // the default types exists
        if (microservice.technologyReferences.exists[isIsTypeDefinitionTechnology]) {
            return
        }

        val typeDefinitionTechnologyReference = microservice.allTypeDefinitionTechnologyReferences
        if (typeDefinitionTechnologyReference.empty || typeDefinitionTechnologyReference.size == 1) {
            return
        }
        typeDefinitionTechnologyReference.forEach[
            error("More than one type definition technology detected. You need to explicitly " +
                "select one as the default type definition technology.", it,
                ServicePackage::Literals.TECHNOLOGY_REFERENCE__TECHNOLOGY)
        ]
    }

    /**
     * Check that annotated technologies define not only deployment-related concepts
     */
    @Check
    def checkTechnologiesForServiceConcepts(Microservice microservice) {
        for (i : 0..<microservice.technologyReferences.size) {
            val technologyImport = microservice.technologyReferences.get(i).technology
            val technologyModel = LemmaUtils.getImportedModelRoot(technologyImport.eResource,
                technologyImport.importURI, Technology)
            if (technologyModel.primitiveTypes.empty &&
                technologyModel.protocols.empty &&
                technologyModel.serviceAspects.empty) {
                error("Technology does not specify service-related concepts",
                    ServicePackage::Literals.MICROSERVICE__TECHNOLOGY_REFERENCES, i)
            }
        }
    }

    /**
     * Check that a microservice specifies protocols that match its operation parameters'
     * communication types
     */
    @Check
    def checkEffectiveProtocols(Microservice microservice) {
        // We do the check only if the microservice specifies technologies. Otherwise, the
        // assignment of protocol technologies happens in a technology mapping model
        if (microservice.technologyReferences.empty) {
            return
        }

        microservice.checkEffectiveProtocolsForCommunicationType(CommunicationType.ASYNCHRONOUS)
        microservice.checkEffectiveProtocolsForCommunicationType(CommunicationType.SYNCHRONOUS)
    }

    /**
     * Helper to check if a microservice specifies protocols for its operation parameters'
     * communication types
     */
    private def checkEffectiveProtocolsForCommunicationType(Microservice microservice,
        CommunicationType communicationType) {
        /*
         * If the microservice specifies an explicit or implicit protocol, we do not need to
         * perform the check. Explicit protocols are specified with the built-in @async/@sync
         * annotations. Implicit protocols result from default protocols in assigned technology
         * models.
         */
        val explicitProtocol = microservice.protocols.findFirst[
            it.communicationType == communicationType
        ]
        if (explicitProtocol !== null) {
            return
        }

        val implicitProtocol = getEffectiveDefaultProtocol(microservice, communicationType)
        if (implicitProtocol !== null) {
            return
        }

        /*
         * Show error, if the microservice does not explicitly or implicitly specify a protocol for
         * its operation parameters' commmunication types
         */
        var parameterForMissingProtocolExists =
            microservice.containedOperations.exists[
                parameters.exists[it.communicationType == communicationType]
            ]
            ||
            microservice.containedReferredOperations.exists[
                operation.parameters.exists[it.communicationType == communicationType]
            ]

        if (parameterForMissingProtocolExists) {
            val communicationTypeOutputString = switch (communicationType) {
                case SYNCHRONOUS: "synchronous"
                case ASYNCHRONOUS: "asynchronous"
            }

            error('''Microservice does not specify «communicationTypeOutputString» protocol, ''' +
                '''but its operations define «communicationTypeOutputString» parameters''',
                microservice, ServicePackage::Literals.MICROSERVICE__NAME
            )
        }
    }

    /**
     * Helper to find the effective default protocol of a microservice
     */
    private def getEffectiveDefaultProtocol(Microservice microservice,
        CommunicationType communicationType) {
        for (technologyImport : microservice.technologyReferences.map[technology]) {
            val technologyModel = LemmaUtils.getImportedModelRoot(technologyImport.eResource,
                technologyImport.importURI, Technology)

            val defaultProtocolOfTechnology = technologyModel.protocols.findFirst[
                ^default && it.communicationType === communicationType
            ]

            if (defaultProtocolOfTechnology !== null)
                return defaultProtocolOfTechnology
        }

        return null
    }

    /**
     * Check technologies of a microservice per communication type for unambiguous default protocols
     */
    @Check
    def checkTechnologiesForUniqueDefaultProtocols(Microservice microservice) {
        if (microservice.technologyReferences.empty) {
            return
        }

        val nonUniqueCommunicationTypes = CommunicationType.values
            .filter[communicationType |
                !microservice.protocols.exists[communicationType === it.communicationType]
            ]
            .filter[!isDefaultProtocolUnique(microservice, it)]

        for (communicationType : nonUniqueCommunicationTypes) {
            val String typeString = switch (communicationType) {
                case CommunicationType.ASYNCHRONOUS: "asynchronous"
                case CommunicationType.SYNCHRONOUS: "synchronous"
            }
            error('''Ambiguous default protocol for «typeString» communication. The ''' +
                '''microservice needs to explicitly specify a protocol for «typeString» ''' +
                '''communication.''', microservice, ServicePackage::Literals.MICROSERVICE__NAME)
        }
    }

    /**
     * Helper to check if default protocol of a microservice is unique for a given communication
     * type
     */
    private def isDefaultProtocolUnique(Microservice microservice,
        CommunicationType communicationType) {
        var boolean alreadyFoundDefaultProtocolForCommunicationType
        for (technologyImport : microservice.technologyReferences.map[technology]) {
            val technologyModel = LemmaUtils.getImportedModelRoot(technologyImport.eResource,
                technologyImport.importURI, Technology)
            val hasDefaultProtocolForCommunicationType = technologyModel.protocols.exists[
                ^default && it.communicationType === communicationType
            ]
            if (hasDefaultProtocolForCommunicationType) {
                if (alreadyFoundDefaultProtocolForCommunicationType)
                    return false
                else
                    alreadyFoundDefaultProtocolForCommunicationType = true
            }
        }

        return true
    }

    /**
     * Check that default type definition technology can be marked as such
     */
    @Check
    def checkDefaultTypeDefinitionTechnology(TechnologyReference technologyReference) {
        if (!technologyReference.isTypeDefinitionTechnology) {
            return
        }

        val importImport = technologyReference.technology
        val technologyModel = LemmaUtils.getImportedModelRoot(importImport.eResource,
            importImport.importURI, Technology)
        val technologyDefinesTypes = !technologyModel.primitiveTypes.empty ||
            !technologyModel.collectionTypes.empty || !technologyModel.dataStructures.empty
        if (!technologyDefinesTypes)
            error("Technology does not specify types and cannot be marked as default type " +
                "definition technology",
                ServicePackage.Literals::TECHNOLOGY_REFERENCE__IS_TYPE_DEFINITION_TECHNOLOGY)
    }


    /**
     * Check that interfaces are not empty, i.e., that they define or refer to at least one
     * operation
     */
    @Check
    def checkInterfaceNotEmpty(Interface ^interface) {
        val definesOperations = interface.operations !== null && !interface.operations.empty
        val refersOperations = interface.referredOperations !== null &&
            !interface.referredOperations.empty

        if (!definesOperations && !refersOperations)
            error("Interface must define or refer to at least one operation", interface,
                ServicePackage::Literals.INTERFACE__NAME)
    }

    /**
     * Check interface visibility
     */
    @Check
    def checkVisibility(Interface ^interface) {
        if (interface?.microservice === null || interface.effectiveVisibility !== null)
            return

        val microserviceVisibility = interface.microservice.effectiveVisibility.name()?.toLowerCase
        if (microserviceVisibility === null)
            return

        val interfaceVisibility = interface.visibility.name()?.toLowerCase
        if (interfaceVisibility === null) {
            return
        }

        error('''Interface visibility («interfaceVisibility») must not exceed the visibility ''' +
            '''of its defining microservice («microserviceVisibility»)''', interface,
            ServicePackage::Literals.INTERFACE__VISIBILITY)
    }

    /**
     * Warn, if a required interface is already marked as being required by its containing
     * microservice
     */
    @Check
    def warnAlreadyRequired(PossiblyImportedInterface importedInterface) {
        if (importedInterface.required && importedInterface.requiredByContainer) {
            val containingMicroserviceName = nameProvider
                .qualifiedName(importedInterface.interface.microservice)

            warning('''Interface is already required, because its microservice ''' +
                '''«containingMicroserviceName»  is required''', importedInterface,
                ServicePackage::Literals.POSSIBLY_IMPORTED_INTERFACE__INTERFACE)
        }
    }

    /**
     * Warn, if a required interface does not define any implemented methods
     */
    @Check
    def warnNoImplementedOperations(PossiblyImportedInterface importedInterface) {
        if (importedInterface.required && !importedInterface.interface.effectivelyImplemented)
            warning("Interface does not define any implemented operation ", importedInterface,
                ServicePackage::Literals.POSSIBLY_IMPORTED_INTERFACE__INTERFACE)
    }

    /**
     * Warn, if a required microservice does not define any implemented methods
     */
    @Check
    def warnNoImplementedOperations(PossiblyImportedMicroservice importedMicroservice) {
        if (!importedMicroservice.microservice.effectivelyImplemented)
            warning("Microservice does not define any implemented operation ", importedMicroservice,
                ServicePackage::Literals.POSSIBLY_IMPORTED_MICROSERVICE__MICROSERVICE)
    }

    /**
     * Check operation visibility
     */
    @Check
    def checkVisibility(Operation operation) {
        if (operation?.interface === null || operation.effectiveVisibility !== null)
            return

        val interfaceVisibility = operation.interface.effectiveVisibility.name()?.toLowerCase
        if (interfaceVisibility === null)
            return

        val operationVisibility = operation.visibility.name()?.toLowerCase
        if (operationVisibility === null) {
            return
        }

        error('''Operation visibility («operationVisibility») must not exceed the visibility ''' +
            '''of its defining interface («interfaceVisibility»)''', operation,
            ServicePackage::Literals.OPERATION__VISIBILITY)
    }

    /**
     * Warn, if the interface of an operation, that is marked as being not implemented, is also
     * marked as being not implemented. That is, the operation is already implicitly marked as being
     * not implemented by its containing interface.
     */
    @Check
    def warnAlreadyNotImplemented(Operation operation) {
        if (operation.notImplemented && operation.notImplementedByContainer) {
            val containingInterfaceName = operation.interface.name
            warning('''Operation is already marked as being not implemented, because ''' +
                '''its interface «containingInterfaceName» is marked as being not implemented''',
                operation, ServicePackage::Literals.OPERATION__NOT_IMPLEMENTED)
        }
    }

    /**
     * Warn, if an internal operation is already implicitly internal because its containing
     * interface is internal
     */
    @Check
    def warnAlreadyInternal(Operation operation) {
        if (operation.visibility === Visibility.INTERNAL &&
            operation.interface.effectivelyInternal) {
            val interfaceName = operation.interface.name
            warning('''Operation is already implicitly internal, because its interface ''' +
                '''«interfaceName» is effectively internal''', operation,
                ServicePackage::Literals.OPERATION__VISIBILITY)
        }
    }

    /**
     * Warn, if a required operation is already required because its containing interface or
     * microservice are required
     */
    @Check
    def warnAlreadyRequired(PossiblyImportedOperation importedOperation) {
        if (!importedOperation.required || !importedOperation.requiredByContainer) {
            return
        }

        val isInterfaceRequired = importedOperation.requiredByInterface
        val isServiceRequired = importedOperation.requiredByMicroservice
        val operation = importedOperation.operation

        if (isInterfaceRequired && isServiceRequired) {
            val interfaceName = operation.interface.name
            val serviceName = operation.interface.microservice.name
            warning('''Operation is already implicitly required, because both its interface ''' +
                '''«interfaceName» and microservice «serviceName» are required''',
                importedOperation,
                ServicePackage::Literals.POSSIBLY_IMPORTED_OPERATION__REQUIRED_BY_CONTAINER)
        } else if (isInterfaceRequired) {
            val interfaceName = operation.interface.name
            warning('''Operation is already implicitly required, because its interface ''' +
                '''«interfaceName» is required''', importedOperation,
                ServicePackage::Literals.POSSIBLY_IMPORTED_OPERATION__REQUIRED_BY_INTERFACE)
        } else if (isServiceRequired) {
            val serviceName = operation.interface.microservice.name
            warning('''Operation is already implicitly required, because its microservice ''' +
                '''«serviceName» is required''', importedOperation,
                ServicePackage::Literals.POSSIBLY_IMPORTED_OPERATION__REQUIRED_BY_MICROSERVICE)
        }
    }

    // TODO: Inheritance of microservices
    /**
     * Check non-cyclic inheritance relationships between microservices
     */
    /*@Check
    def checkCyclicInheritance(Microservice microservice) {
        if (LemmaUtils.hasCyclicInheritance(microservice, [it.super]))
            error("Cyclic inheritance detected", microservice,
                ServicePackage::Literals.MICROSERVICE__NAME)
    }*/

    /**
     * Check that there is at most one protocol per communication type annotated on microservices,
     * interfaces, operations, or referred operations
     */
    @Check
    def checkProtocolCommunicationType(ProtocolSpecification protocolSpecification) {
        val protocols = switch(protocolSpecification.eContainer) {
            Microservice : (protocolSpecification.eContainer as Microservice).protocols
            Interface : (protocolSpecification.eContainer as Interface).protocols
            Operation : (protocolSpecification.eContainer as Operation).protocols
            ReferredOperation : (protocolSpecification.eContainer as ReferredOperation).protocols
            default : null
        }

        if (protocols === null || protocols.empty) {
            return
        }

        val containerName = switch(protocolSpecification.eContainer) {
            Microservice : "microservice"
            Interface : "interface"
            Operation, ReferredOperation : "operation"
        }

        for (int i : 0..<2) {
            val communicationType = switch (i) {
                case 0: CommunicationType.SYNCHRONOUS
                case 1: CommunicationType.ASYNCHRONOUS
            }

            val communicationTypeName = switch (communicationType) {
                case SYNCHRONOUS: "synchronous"
                case ASYNCHRONOUS: "asynchronous"
            }

            val protocolsOfType = protocols.filter[communicationType == it.communicationType]
            if (protocolsOfType.size > 1)
                error('''There must not be more than one «communicationTypeName» protocol for ''' +
                    '''the «containerName»''', protocolsOfType.get(1),
                ServicePackage::Literals.PROTOCOL_SPECIFICATION__COMMUNICATION_TYPE)
        }
    }

    /**
     * The unspecified primitive type is forbidden for parameters
     */
    @Check
    def checkParameterType(Parameter parameter) {
        val hasUnspecifiedType = parameter.effectiveType instanceof PrimitiveUnspecified
        val operationIsImplemented = !parameter.operation.effectivelyNotImplemented
        if (!hasUnspecifiedType || !operationIsImplemented) {
            return
        }

        error("Type unspecified is only allowed in combination with noimpl modifier", parameter,
            ServicePackage::Literals.PARAMETER__PRIMITIVE_TYPE)
    }

    /**
     * Warn if initializing operation's parameters' output communication types do not match
     * initialized parameter's communication type
     */
    @Check
    def warnCommunicationTypesNotMatching(Parameter parameter) {
        if (parameter.initializedByOperation === null) {
            return
        }

        val initializingOperation = parameter.initializedByOperation.operation
        val existsOutParameterOfSameCommunicationType = initializingOperation.parameters
            .filter[exchangePattern === ExchangePattern.OUT]
            .exists[communicationType === parameter.communicationType]
        if (!existsOutParameterOfSameCommunicationType) {
            val communicationTypeName = switch (parameter.communicationType) {
                case CommunicationType.ASYNCHRONOUS: "asynchronous"
                case CommunicationType.SYNCHRONOUS: "synchronous"
            }

            warning('''Operation does not have any outgoing parameters with communication type ''' +
                '''«communicationTypeName»''', parameter,
                ServicePackage::Literals.PARAMETER__INITIALIZED_BY_OPERATION)
        }
    }

    /**
     * Warn if an API parameter has already been commented
     */
    @Check
    def warnDuplicateParameterComments(ApiOperationComment operationComment) {
        val parameterComments = operationComment.parameterComments
        if (parameterComments === null || parameterComments.empty) {
            return
        }

        val duplicateIndex = LemmaUtils.getDuplicateIndex(parameterComments, [it.parameter])
        if (duplicateIndex > -1) {
            val duplicateComment = parameterComments.get(duplicateIndex)
            warning("Parameter has already been commented", duplicateComment,
                ServicePackage.Literals::API_PARAMETER_COMMENT__PARAMETER)
        }
    }

    /**
     * Warn if an incoming API parameter has not been commented yet
     */
    @Check
    def warnMissingParameterComments(ApiOperationComment operationComment) {
        val allIncomingParameters = operationComment.operation?.parameters?.filter[
            exchangePattern === ExchangePattern.IN ||
            exchangePattern === ExchangePattern.INOUT
        ]
        if (allIncomingParameters === null) {
            return
        }

        val missingParameter = allIncomingParameters.findFirst[incomingParameter |
            !operationComment.parameterComments.exists[parameter == incomingParameter]
        ]
        if (missingParameter !== null)
            warning('''Incoming parameter «missingParameter.name» has not been commented yet''',
                ServicePackage.Literals::API_OPERATION_COMMENT__COMMENT)
    }

    /**
     * Warn if an API parameter has been commented as being required/not required when it is modeled
     * as being optional/not optional
     */
    @Check
    def warnParameterCommentDiffersFromOptionalFlag(ApiParameterComment parameterComment) {
        if (parameterComment.parameter === null || parameterComment.returned) {
            return
        }

        if (parameterComment.required !== !parameterComment.parameter.optional) {
            val commentIsRequiredString = if (!parameterComment.required) " not " else " "
            val parameterIsRequiredString = if (!parameterComment.parameter.optional)
                    " "
                else
                    " not "
            warning('''Parameter has been documented as being«commentIsRequiredString»required,''' +
                ''' but is modeled as being«parameterIsRequiredString»required''',
                ServicePackage.Literals::API_PARAMETER_COMMENT__PARAMETER)
        }
    }

    /**
     * Check type compatibility of parameter and initializing operation, and warn if incompatible
     */
    @Check
    def warnParameterInitializingTypeCompatibility(PossiblyImportedOperation importedOperation) {
        // The operation may not have a container if the user didn't finish entering the
        // initializing operation's name and hence the DSL code is syntactically incorrect
        val operation = importedOperation.operation
        if (operation.eContainer === null) {
            return
        }

        val initializedParameter = importedOperation.initializedParameter
        if (initializedParameter === null) {
            return
        }

        if (initializedParameter.exchangePattern === ExchangePattern.OUT) {
            error("Outgoing parameters may not be initialized", initializedParameter,
                ServicePackage::Literals.PARAMETER__EXCHANGE_PATTERN)
            return
        }

        val parameterType = initializedParameter.effectiveType
        if (parameterType === null) {
            return
        }

        /*
         * If the operation has an output type that is the same as the initialized parameter's type
         * both types are equal and hence inherently compatible
         */
        val existsSameOutputType = operation.parameters.exists[
            (exchangePattern == ExchangePattern.OUT || exchangePattern == ExchangePattern.INOUT) &&
            effectiveType == parameterType
        ]

        if (existsSameOutputType) {
            return
        }

        /*
         * Check and warn if initialized parameter is of a technology-specific primitive type that
         * has no basic built-in primitive type
         */
        if (warnParameterLacksPrimitiveType(initializedParameter)) {
            return
        }

        /* Perform full type check leveraging the data DSL's type checker */
        val outputTypesOfParametersCommunicationType = operation.parameters.filter[
                // may happen if no type has been entered by the user, yet
                effectiveType !== null &&
                communicationType === initializedParameter.communicationType &&
                (
                    exchangePattern === ExchangePattern.OUT ||
                    exchangePattern === ExchangePattern.INOUT
                )
            ].map[effectiveType]

        if (outputTypesOfParametersCommunicationType.empty) {
            return
        }

        warnInitializingTypeCompatibility(importedOperation,
            outputTypesOfParametersCommunicationType, parameterType)
    }

    /**
     * Helper method to determine if a technology-specific primitive type lacks underlying
     * built-in primitive types
     */
    private def warnParameterLacksPrimitiveType(Parameter initializedParameter) {
        /*
         * Only accept _technology-specific_ primitive types that do not have basic built-in
         * primitive types
         */
        val parameterType = initializedParameter.effectiveType
        if (!(parameterType instanceof TechnologySpecificPrimitiveType))
            return false

        val technologySpecificType = parameterType as TechnologySpecificPrimitiveType
        if (!technologySpecificType.basicBuiltinPrimitiveTypes.empty)
            return false

        /* Create warning */
        val qualifiedTypeName = new StringBuilder
        qualifiedTypeName.append(technologySpecificType.technology.name)
        qualifiedTypeName.append("::")
        qualifiedTypeName.append(QualifiedName.create(technologySpecificType.qualifiedNameParts))

        warning('''Technology-specific primitive type «qualifiedTypeName» of parameter ''' +
            '''«initializedParameter.name» has no basic type. To initialize the parameter, an ''' +
            '''additional type conversion would need to be implemented.''', initializedParameter,
            ServicePackage::Literals.PARAMETER__INITIALIZED_BY_OPERATION)

        return true
    }

    /**
     * Helper method to perform full type checks of a parameter and its initializing operation
     */
    private def warnInitializingTypeCompatibility(PossiblyImportedOperation importedOperation,
        Iterable<Type> outputTypes, Type parameterType) {
        // Iterate over all output types and check their compatibility with the initialized
        // parameter's type until one compatible type was found
        val typeChecker = new TypeChecker()
        var compatibleOutTypeFound = false
        var i = 0

        while (i < outputTypes.size && !compatibleOutTypeFound) {
            val outputType = outputTypes.get(i)

            try {
                typeChecker.checkTypeCompatibility(parameterType, outputType)
                compatibleOutTypeFound = true
            } catch (TypesNotCompatibleException ex) {
                i++
            }
        }

        // Warn, if no compatible type could be found
        if (compatibleOutTypeFound) {
            return
        }

        val initializedParameter = importedOperation.initializedParameter
        var typeName = QualifiedName
            .create(initializedParameter.effectiveTypeQualifiedNameParts)
            .toString

        if (parameterType instanceof TechnologySpecificPrimitiveType)
            typeName = parameterType.technology.name + "::" + typeName

        val communicationTypeName = switch (initializedParameter.communicationType) {
            case CommunicationType.ASYNCHRONOUS: "asynchronous"
            case CommunicationType.SYNCHRONOUS: "synchronous"
        }

        warning('''Types of output parameters with communication type «communicationTypeName» ''' +
            '''are not directly compatible with type «typeName» of parameter ''' +
            '''«initializedParameter.name».''', importedOperation,
            ServicePackage::Literals.POSSIBLY_IMPORTED_OPERATION__OPERATION)
    }

    /**
     * Check unique endpoints on microservice
     */
    @Check
    def checkUniqueEndpoints(Microservice microservice) {
        checkUniqueEndpoints(microservice.endpoints)
    }

    /**
     * Check unique endpoints on interface
     */
    @Check
    def checkUniqueEndpoints(Interface ^interface) {
        checkUniqueEndpoints(interface.endpoints)
    }

    /**
     * Check unique endpoints on operation
     */
    @Check
    def checkUniqueEndpoints(Operation operation) {
        checkUniqueEndpoints(operation.endpoints)
    }

    /**
     * Check uniqueness of an endpoint's addresses
     */
    @Check
    def checkUniqueEndpointAddresses(Endpoint endpoint) {
        val duplicateIndex = LemmaUtils.getDuplicateIndex(endpoint.addresses, [it])
        if (duplicateIndex > -1) {
            val duplicate = endpoint.addresses.get(duplicateIndex)
            error('''Duplicate address «duplicate»''', endpoint,
                ServicePackage::Literals.ENDPOINT__ADDRESSES, duplicateIndex)
        }
    }

    /**
     * Check uniqueness of aspects
     */
    @Check
    def checkUniqueAspects(ImportedServiceAspect aspect) {
        if (!aspect.importedAspect.isSingleValued) {
            return
        }

        val eponymousAspectsOfContainer = EcoreUtil2.getSiblingsOfType(aspect,
            ImportedServiceAspect).filter[
                it != aspect &&
                it.importedAspect.name == aspect.importedAspect.name
            ]

        if (!eponymousAspectsOfContainer.empty) {
            val duplicateAspect = eponymousAspectsOfContainer.get(0)
            error("Aspect may be specified at most once", duplicateAspect,
                ServicePackage.Literals::IMPORTED_SERVICE_ASPECT__IMPORTED_ASPECT)
        }
    }

    /**
     * Check that aspect has only one property, if only a single value is specified, and that the
     * specified value matches the property's type
     */
    @Check
    def checkSingleAspectProperty(ImportedServiceAspect importedAspect) {
        val propertyValue = importedAspect.singlePropertyValue
        if (propertyValue === null) {
            return
        }

        val propertyCount = importedAspect.importedAspect.properties.size
        if (propertyCount === 0)
            error("Aspect does not define properties", importedAspect,
                ServicePackage.Literals::IMPORTED_SERVICE_ASPECT__SINGLE_PROPERTY_VALUE)
        else if (propertyCount > 1)
            error("Ambiguous value assignment", importedAspect,
                ServicePackage.Literals::IMPORTED_SERVICE_ASPECT__SINGLE_PROPERTY_VALUE)
        else if (propertyCount === 1) {
            val targetProperty = importedAspect.importedAspect.properties.get(0)
            val targetPropertyType = targetProperty.type
            if (!propertyValue.isOfType(targetPropertyType))
                error('''Value is not of type «targetPropertyType.typeName» as expected by ''' +
                '''property «targetProperty.name»''', importedAspect,
                ServicePackage.Literals::IMPORTED_SERVICE_ASPECT__SINGLE_PROPERTY_VALUE)
        }
    }

    /**
     * Check uniqueness of aspect properties in value assignments
     */
    @Check
    def checkUniqueValueAssignments(ImportedServiceAspect aspect) {
        if (aspect.values.empty || aspect.importedAspect.properties.size <= 1) {
            return
        }

        val duplicateIndex = LemmaUtils.getDuplicateIndex(aspect.values, [property.name])
        if (duplicateIndex > -1)
            error("Duplicate value assignment to property",
                ServicePackage.Literals::IMPORTED_SERVICE_ASPECT__VALUES, duplicateIndex)
    }

    /**
     * Check that mandatory properties of aspects have values
     */
    @Check
    def checkMandatoryAspectProperties(ImportedServiceAspect importedAspect) {
        val aspect = importedAspect.importedAspect
        val aspectProperties = aspect.properties
        val mandatoryProperties = aspectProperties.filter[isMandatory]
        val mandatoryPropertiesWithoutValues = mandatoryProperties.filter[
            !importedAspect.values.map[property].contains(it)
        ]
        val allMandatoryPropertiesHaveValues = mandatoryPropertiesWithoutValues.empty

        val aspectHasExactlyOneMandatoryProperty = aspectProperties.size === 1 &&
            !mandatoryProperties.empty
        if (aspectHasExactlyOneMandatoryProperty) {
            if (importedAspect.singlePropertyValue === null && !allMandatoryPropertiesHaveValues) {
                val mandatoryProperty = mandatoryProperties.get(0)
                error('''Mandatory property «mandatoryProperty.name» does not have value''',
                    importedAspect,
                    ServicePackage.Literals::IMPORTED_SERVICE_ASPECT__IMPORTED_ASPECT)
            }
        } else if (!allMandatoryPropertiesHaveValues) {
            mandatoryPropertiesWithoutValues.forEach[
               error('''Mandatory property «name» does not have value''', importedAspect,
                    ServicePackage.Literals::IMPORTED_SERVICE_ASPECT__IMPORTED_ASPECT)
            ]
        }
    }

    /**
     * Check that the assigned value of a service aspect property matches its type
     */
    @Check
    def checkPropertyValueType(TechnologySpecificPropertyValueAssignment propertyValue) {
        if (propertyValue.property === null || propertyValue.value === null) {
            return
        }

        val serviceProperty = propertyValue.property
        val servicePropertyType = serviceProperty.type
        if (!propertyValue.value.isOfType(servicePropertyType))
            error('''Value is not of type «servicePropertyType.typeName» ''', propertyValue,
                TechnologyPackage::Literals.TECHNOLOGY_SPECIFIC_PROPERTY_VALUE_ASSIGNMENT__VALUE)
    }

    /**
     * Convenience method to check endpoint uniqueness in a list of endpoints
     */
    private def checkUniqueEndpoints(List<Endpoint> endpoints) {
        val protocolSet = <String> newHashSet
        endpoints.forEach[endpoint |
            for (i : 0..<endpoint.protocols.size) {
                val protocol = endpoint.protocols.get(i)
                var protocolId = protocol.import.name + "::" + protocol.importedProtocol.name
                if (protocol.dataFormat !== null)
                    protocolId += '''(«protocol.dataFormat.formatName»)'''
                else
                    protocolId += '''(«protocol.importedProtocol.defaultFormat.formatName»)'''

                val isDuplicate = !protocolSet.add(protocolId)
                if (isDuplicate)
                    error('''Duplicate endpoint for protocol «protocolId»''', endpoint,
                        ServicePackage::Literals.ENDPOINT__PROTOCOLS, i)
            }
        ]
    }

    /**
     * Convenience method to warn about non-unique endpoint addresses within a list of endpoints
     */
    private def warnUniqueEndpointAddresses(List<Endpoint> endpoints, String containerTypeName,
        Function<Endpoint, List<String>> getEndpointContainerNameParts) {
        /*
         * This ensures the uniqueness check. Its key is an address prefixed by protocol and data
         * format if modeled. Assigned to each key is a multi-value (in the form of a map), which
         * stores the "pure" protocol/data format name and the Endpoint instance of the address.
         */
        val uniqueAddressMap = <String, Map<String, Object>> newHashMap

        /* Iterate over endpoints, build map and perform uniqueness checks */
        endpoints.forEach[endpoint |
            for (i : 0..<endpoint.addresses.size) {
                endpoint.protocols.forEach[protocol |
                    val address = endpoint.addresses.get(i)
                    var protocolName = protocol.import.name + "::" + protocol.importedProtocol.name
                    val dataFormat = protocol.dataFormat
                    if (dataFormat?.formatName !== null)
                        protocolName += '''(«dataFormat.formatName»)'''
                    else
                        protocolName += '''(«protocol.importedProtocol.defaultFormat.formatName»)'''
                    val addressPrefixedByProtocol = protocolName + address

                    val valueMap = <String, Object> newHashMap
                    valueMap.put("protocol", protocolName)
                    valueMap.put("endpoint", endpoint)
                    val duplicate = uniqueAddressMap.putIfAbsent(addressPrefixedByProtocol,
                        valueMap)
                    val duplicateEndpoint = if (duplicate !== null)
                        duplicate.get("endpoint") as Endpoint

                    // If a duplicate was found we first check that it's not the same endpoint as
                    // being currently iterated. That is, to prevent adding an additional error,
                    // when an endpoint has a duplicate address. This check is performed separately
                    // per endpoint.
                    if (duplicateEndpoint !== null && duplicateEndpoint !== endpoint) {
                        val duplicateProtocolName = duplicate.get("protocol") as String
                        val duplicateContainerNameParts = getEndpointContainerNameParts
                            .apply(duplicateEndpoint)
                        val currentEndpointContainerNameParts = getEndpointContainerNameParts
                            .apply(endpoint)
                        val relativeDuplicateName = QualifiedName.create(
                            LemmaUtils.calculateRelativeQualifiedNameParts(
                                duplicateEndpoint, duplicateContainerNameParts, ServiceModel,
                                endpoint, currentEndpointContainerNameParts, ServiceModel
                            )
                        ).toString

                        warning('''Address is already specified for protocol ''' +
                            '''«duplicateProtocolName» on «containerTypeName» ''' +
                            '''«relativeDuplicateName»''', endpoint,
                            ServicePackage::Literals.ENDPOINT__ADDRESSES, i)
                    }
                ]
            }
        ]
    }
}
