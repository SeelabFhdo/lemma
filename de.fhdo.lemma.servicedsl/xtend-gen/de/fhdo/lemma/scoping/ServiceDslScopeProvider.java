/**
 * generated by Xtext 2.12.0
 */
package de.fhdo.lemma.scoping;

import com.google.common.base.Function;
import com.google.common.base.Objects;
import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;
import de.fhdo.lemma.data.ComplexType;
import de.fhdo.lemma.data.DataModel;
import de.fhdo.lemma.data.PrimitiveValue;
import de.fhdo.lemma.service.Import;
import de.fhdo.lemma.service.ImportedProtocolAndDataFormat;
import de.fhdo.lemma.service.ImportedServiceAspect;
import de.fhdo.lemma.service.ImportedType;
import de.fhdo.lemma.service.Interface;
import de.fhdo.lemma.service.Microservice;
import de.fhdo.lemma.service.Operation;
import de.fhdo.lemma.service.Parameter;
import de.fhdo.lemma.service.PossiblyImportedInterface;
import de.fhdo.lemma.service.PossiblyImportedMicroservice;
import de.fhdo.lemma.service.PossiblyImportedOperation;
import de.fhdo.lemma.service.ProtocolSpecification;
import de.fhdo.lemma.service.ReferredOperation;
import de.fhdo.lemma.service.ServiceModel;
import de.fhdo.lemma.service.ServicePackage;
import de.fhdo.lemma.service.TechnologyReference;
import de.fhdo.lemma.technology.CommunicationType;
import de.fhdo.lemma.technology.DataFormat;
import de.fhdo.lemma.technology.ExchangePattern;
import de.fhdo.lemma.technology.JoinPointType;
import de.fhdo.lemma.technology.Protocol;
import de.fhdo.lemma.technology.ServiceAspect;
import de.fhdo.lemma.technology.Technology;
import de.fhdo.lemma.technology.TechnologyPackage;
import de.fhdo.lemma.technology.TechnologySpecificCollectionType;
import de.fhdo.lemma.technology.TechnologySpecificDataStructure;
import de.fhdo.lemma.technology.TechnologySpecificPrimitiveType;
import de.fhdo.lemma.technology.TechnologySpecificProperty;
import de.fhdo.lemma.technology.TechnologySpecificPropertyValueAssignment;
import de.fhdo.lemma.utils.LemmaUtils;
import java.util.AbstractCollection;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import java.util.regex.Pattern;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.nodemodel.ICompositeNode;
import org.eclipse.xtext.nodemodel.util.NodeModelUtils;
import org.eclipse.xtext.resource.EObjectDescription;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.MapBasedScope;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.ExclusiveRange;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.Pair;

/**
 * This class implements a custom scope provider for the Service DSL.
 * 
 * @author <a href="mailto:florian.rademacher@fh-dortmund.de">Florian Rademacher</a>
 */
@SuppressWarnings("all")
public class ServiceDslScopeProvider extends AbstractServiceDslScopeProvider {
  /**
   * Build scope for a given context and a given reference
   */
  @Override
  public IScope getScope(final EObject context, final EReference reference) {
    IScope _switchResult = null;
    boolean _matched = false;
    if (context instanceof Microservice) {
      _matched=true;
      _switchResult = this.getScope(((Microservice)context), reference);
    }
    if (!_matched) {
      if (context instanceof TechnologyReference) {
        _matched=true;
        _switchResult = this.getScope(((TechnologyReference)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof Interface) {
        _matched=true;
        _switchResult = this.getScope(((Interface)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof Operation) {
        _matched=true;
        _switchResult = this.getScope(((Operation)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof PossiblyImportedMicroservice) {
        _matched=true;
        _switchResult = this.getScope(((PossiblyImportedMicroservice)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof PossiblyImportedInterface) {
        _matched=true;
        _switchResult = this.getScope(((PossiblyImportedInterface)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof PossiblyImportedOperation) {
        _matched=true;
        _switchResult = this.getScope(((PossiblyImportedOperation)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof Parameter) {
        _matched=true;
        _switchResult = this.getScope(((Parameter)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof ReferredOperation) {
        _matched=true;
        _switchResult = this.getScope(((ReferredOperation)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof ImportedType) {
        _matched=true;
        _switchResult = this.getScope(((ImportedType)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof ProtocolSpecification) {
        _matched=true;
        _switchResult = this.getScope(((ProtocolSpecification)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof ImportedProtocolAndDataFormat) {
        _matched=true;
        _switchResult = this.getScope(((ImportedProtocolAndDataFormat)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof ImportedServiceAspect) {
        _matched=true;
        _switchResult = this.getScope(((ImportedServiceAspect)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof TechnologySpecificPropertyValueAssignment) {
        _matched=true;
        _switchResult = this.getScope(((TechnologySpecificPropertyValueAssignment)context), reference);
      }
    }
    final IScope scope = _switchResult;
    if ((scope != null)) {
      return scope;
    } else {
      if ((scope == null)) {
        return super.getScope(context, reference);
      }
    }
    return null;
  }
  
  /**
   * Build scope for microservices and the given reference
   */
  private IScope getScope(final Microservice microservice, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, ServicePackage.Literals.POSSIBLY_IMPORTED_MICROSERVICE__IMPORT)) {
      _matched=true;
    }
    if (!_matched) {
      if (Objects.equal(reference, ServicePackage.Literals.POSSIBLY_IMPORTED_INTERFACE__IMPORT)) {
        _matched=true;
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, ServicePackage.Literals.POSSIBLY_IMPORTED_OPERATION__IMPORT)) {
        _matched=true;
      }
    }
    if (_matched) {
      return this.getScopeForImportsOfType(microservice, ServiceModel.class);
    }
    if (!_matched) {
      if (Objects.equal(reference, ServicePackage.Literals.POSSIBLY_IMPORTED_MICROSERVICE__MICROSERVICE)) {
        _matched=true;
        return this.getScopeForPossiblyImportedMicroservice(microservice);
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, ServicePackage.Literals.POSSIBLY_IMPORTED_INTERFACE__INTERFACE)) {
        _matched=true;
        return this.getScopeForPossiblyImportedInterface(microservice);
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, ServicePackage.Literals.POSSIBLY_IMPORTED_OPERATION__OPERATION)) {
        _matched=true;
        return this.getScopeForPossiblyImportedOperation(microservice);
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, ServicePackage.Literals.IMPORTED_PROTOCOL_AND_DATA_FORMAT__IMPORT)) {
        _matched=true;
        return this.getServiceTechnologyImportAliasesAsScope(microservice);
      }
    }
    return null;
  }
  
  /**
   * Build scope for technology references and the given reference
   */
  private IScope getScope(final TechnologyReference technologyReference, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, ServicePackage.Literals.TECHNOLOGY_REFERENCE__TECHNOLOGY)) {
      _matched=true;
      return this.getScopeForImportsOfType(technologyReference, Technology.class);
    }
    return null;
  }
  
  /**
   * Build scope for interfaces and the given reference
   */
  private IScope getScope(final Interface interface_, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, ServicePackage.Literals.IMPORTED_PROTOCOL_AND_DATA_FORMAT__IMPORT)) {
      _matched=true;
      return this.getServiceTechnologyImportAliasesAsScope(interface_);
    }
    return null;
  }
  
  /**
   * Build scope for operations and the given reference
   */
  private IScope getScope(final Operation operation, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, ServicePackage.Literals.IMPORTED_PROTOCOL_AND_DATA_FORMAT__IMPORT)) {
      _matched=true;
      return this.getServiceTechnologyImportAliasesAsScope(operation);
    }
    return null;
  }
  
  /**
   * Build scope for possibly imported microservices and the given reference
   */
  private IScope getScope(final PossiblyImportedMicroservice importedMicroservice, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, ServicePackage.Literals.POSSIBLY_IMPORTED_MICROSERVICE__IMPORT)) {
      _matched=true;
      return this.getScopeForImportsOfType(importedMicroservice, ServiceModel.class);
    }
    if (!_matched) {
      if (Objects.equal(reference, ServicePackage.Literals.POSSIBLY_IMPORTED_MICROSERVICE__MICROSERVICE)) {
        _matched=true;
        return this.getScopeForPossiblyImportedMicroservice(importedMicroservice, importedMicroservice.getImport());
      }
    }
    return null;
  }
  
  /**
   * Build scope for possibly imported interface and the given reference
   */
  private IScope getScope(final PossiblyImportedInterface importedInterface, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, ServicePackage.Literals.POSSIBLY_IMPORTED_INTERFACE__IMPORT)) {
      _matched=true;
      return this.getScopeForImportsOfType(importedInterface, ServiceModel.class);
    }
    if (!_matched) {
      if (Objects.equal(reference, ServicePackage.Literals.POSSIBLY_IMPORTED_INTERFACE__INTERFACE)) {
        _matched=true;
        return this.getScopeForPossiblyImportedInterface(importedInterface, importedInterface.getImport());
      }
    }
    return null;
  }
  
  /**
   * Build scope for possibly imported operation and the given reference
   */
  private IScope getScope(final PossiblyImportedOperation importedOperation, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, ServicePackage.Literals.POSSIBLY_IMPORTED_OPERATION__IMPORT)) {
      _matched=true;
      return this.getScopeForImportsOfType(importedOperation, ServiceModel.class);
    }
    if (!_matched) {
      if (Objects.equal(reference, ServicePackage.Literals.POSSIBLY_IMPORTED_OPERATION__OPERATION)) {
        _matched=true;
        return this.getScopeForPossiblyImportedOperation(importedOperation, importedOperation.getImport());
      }
    }
    return null;
  }
  
  /**
   * Build scope for parameters of operations
   */
  private IScope getScope(final Parameter parameter, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, ServicePackage.Literals.POSSIBLY_IMPORTED_OPERATION__IMPORT)) {
      _matched=true;
      return this.getScopeForOperationImport(parameter);
    }
    if (!_matched) {
      if (Objects.equal(reference, ServicePackage.Literals.POSSIBLY_IMPORTED_OPERATION__OPERATION)) {
        _matched=true;
        return this.getScopeForInitializingOperation(parameter);
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, ServicePackage.Literals.IMPORTED_TYPE__IMPORT)) {
        _matched=true;
        return this.getScopeForImportedTypeImport(parameter);
      }
    }
    return null;
  }
  
  /**
   * Build scope for referred operations in interfaces
   */
  private IScope getScope(final ReferredOperation operation, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, ServicePackage.Literals.REFERRED_OPERATION__OPERATION)) {
      _matched=true;
      return this.getScopeForReferableOperation(operation);
    }
    if (!_matched) {
      if (Objects.equal(reference, ServicePackage.Literals.IMPORTED_PROTOCOL_AND_DATA_FORMAT__IMPORT)) {
        _matched=true;
        return this.getServiceTechnologyImportAliasesAsScope(operation);
      }
    }
    return null;
  }
  
  /**
   * Build scope for operation to refer to
   */
  public IScope getScopeForReferableOperation(final ReferredOperation operation) {
    final Function1<Interface, EList<Operation>> _function = (Interface it) -> {
      return it.getOperations();
    };
    final Function1<Operation, Boolean> _function_1 = (Operation it) -> {
      String _name = it.getName();
      return Boolean.valueOf((_name != null));
    };
    final Function1<Operation, IEObjectDescription> _function_2 = (Operation it) -> {
      IEObjectDescription _xblockexpression = null;
      {
        QualifiedName _xifexpression = null;
        String _version = it.getInterface().getVersion();
        boolean _tripleNotEquals = (_version != null);
        if (_tripleNotEquals) {
          _xifexpression = QualifiedName.create(it.getInterface().getVersion(), it.getInterface().getName(), it.getName());
        } else {
          _xifexpression = QualifiedName.create(it.getInterface().getName(), it.getName());
        }
        final QualifiedName operationName = _xifexpression;
        _xblockexpression = EObjectDescription.create(operationName, it);
      }
      return _xblockexpression;
    };
    final Iterable<IEObjectDescription> scopeElements = IterableExtensions.<Operation, IEObjectDescription>map(IterableExtensions.<Operation>filter(Iterables.<Operation>concat(ListExtensions.<Interface, EList<Operation>>map(EcoreUtil2.<Interface>getSiblingsOfType(operation.getInterface(), Interface.class), _function)), _function_1), _function_2);
    return MapBasedScope.createScope(IScope.NULLSCOPE, scopeElements);
  }
  
  /**
   * Build scope for imported types of operation parameters
   */
  private IScope getScope(final ImportedType importedType, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, ServicePackage.Literals.IMPORTED_TYPE__IMPORT)) {
      _matched=true;
      return this.getScopeForImportedTypeImport(importedType);
    }
    if (!_matched) {
      if (Objects.equal(reference, ServicePackage.Literals.IMPORTED_TYPE__TYPE)) {
        _matched=true;
        return this.getScopeForImportedType(importedType);
      }
    }
    return null;
  }
  
  /**
   * Build scope for allowed imports of imported types of operation parameters
   */
  private IScope getScopeForImportedTypeImport(final EObject context) {
    final IScope dataModelImports = this.getScopeForImportsOfType(context, DataModel.class);
    final IScope technologyImportAliases = this.getServiceTechnologyImportAliasesAsScope(context);
    if ((technologyImportAliases != IScope.NULLSCOPE)) {
      return LemmaUtils.mergeScopes(dataModelImports, technologyImportAliases);
    } else {
      return dataModelImports;
    }
  }
  
  /**
   * Build scope for imported types of operation parameters
   */
  private IScope getScopeForImportedType(final ImportedType importedType) {
    final List<EObject> resourceContents = LemmaUtils.getImportedModelContents(importedType.eResource(), 
      importedType.getImport().getImportURI());
    if (((resourceContents == null) || resourceContents.isEmpty())) {
      return IScope.NULLSCOPE;
    }
    final EObject resourceRoot = resourceContents.get(0);
    boolean _matched = false;
    if (resourceRoot instanceof DataModel) {
      _matched=true;
      return this.getScopeForImportedComplexTypes(((DataModel)resourceRoot));
    }
    if (!_matched) {
      if (resourceRoot instanceof Technology) {
        _matched=true;
        return this.getScopeForImportedTypes(((Technology)resourceRoot));
      }
    }
    return IScope.NULLSCOPE;
  }
  
  /**
   * Build scope for imported protocols used to annotate microservices, interfaces, or
   * operations
   */
  private IScope getScope(final ImportedProtocolAndDataFormat importedProtocol, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, ServicePackage.Literals.IMPORTED_PROTOCOL_AND_DATA_FORMAT__IMPORT)) {
      _matched=true;
      return this.getServiceTechnologyImportAliasesAsScope(importedProtocol);
    }
    if (!_matched) {
      if (Objects.equal(reference, ServicePackage.Literals.IMPORTED_PROTOCOL_AND_DATA_FORMAT__IMPORTED_PROTOCOL)) {
        _matched=true;
        return this.getScopeForImportedProtocol(importedProtocol);
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, ServicePackage.Literals.IMPORTED_PROTOCOL_AND_DATA_FORMAT__DATA_FORMAT)) {
        _matched=true;
        return this.getScopeForDataFormat(importedProtocol);
      }
    }
    return null;
  }
  
  /**
   * Build scope for imported service aspects used to annotate microservices, interfaces,
   * operations, or parameters
   */
  private IScope getScope(final ImportedServiceAspect importedAspect, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, ServicePackage.Literals.IMPORTED_SERVICE_ASPECT__IMPORT)) {
      _matched=true;
      return this.getServiceTechnologyImportAliasesAsScope(importedAspect);
    }
    if (!_matched) {
      if (Objects.equal(reference, ServicePackage.Literals.IMPORTED_SERVICE_ASPECT__IMPORTED_ASPECT)) {
        _matched=true;
        return this.getScopeForImportedAspect(importedAspect);
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, TechnologyPackage.Literals.TECHNOLOGY_SPECIFIC_PROPERTY_VALUE_ASSIGNMENT__PROPERTY)) {
        _matched=true;
        return this.getScopeForAspectProperty(importedAspect);
      }
    }
    return null;
  }
  
  /**
   * Build scope for technology-specific value assignment
   */
  private IScope getScope(final TechnologySpecificPropertyValueAssignment assignment, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, TechnologyPackage.Literals.TECHNOLOGY_SPECIFIC_PROPERTY_VALUE_ASSIGNMENT__PROPERTY)) {
      _matched=true;
      return this.getScopeForAspectProperty(assignment);
    }
    return null;
  }
  
  /**
   * Build scope for aspect properties
   */
  private IScope getScopeForAspectProperty(final EObject container) {
    if ((container instanceof TechnologySpecificPropertyValueAssignment)) {
      final ImportedServiceAspect aspect = EcoreUtil2.<ImportedServiceAspect>getContainerOfType(container, ImportedServiceAspect.class);
      return Scopes.scopeFor(aspect.getImportedAspect().getProperties());
    } else {
      if ((container instanceof ImportedServiceAspect)) {
        final HashSet<String> alreadyUsedProperties = CollectionLiterals.<String>newHashSet();
        final Consumer<TechnologySpecificPropertyValueAssignment> _function = (TechnologySpecificPropertyValueAssignment it) -> {
          PrimitiveValue _value = it.getValue();
          boolean _tripleNotEquals = (_value != null);
          if (_tripleNotEquals) {
            alreadyUsedProperties.add(it.getProperty().getName());
          }
        };
        ((ImportedServiceAspect)container).getValues().forEach(_function);
        final Function1<TechnologySpecificProperty, Boolean> _function_1 = (TechnologySpecificProperty it) -> {
          boolean _contains = alreadyUsedProperties.contains(it.getName());
          return Boolean.valueOf((!_contains));
        };
        final Iterable<TechnologySpecificProperty> availableProperties = IterableExtensions.<TechnologySpecificProperty>filter(((ImportedServiceAspect)container).getImportedAspect().getProperties(), _function_1);
        return Scopes.scopeFor(availableProperties);
      } else {
        return IScope.NULLSCOPE;
      }
    }
  }
  
  /**
   * Build scope for aspect of imported service aspect
   */
  private IScope getScopeForImportedAspect(final ImportedServiceAspect importedAspect) {
    ExchangePattern forExchangePattern = null;
    CommunicationType forCommunicationType = null;
    List<Pair<Protocol, DataFormat>> forProtocolsAndDataFormats = null;
    final EObject aspectContainer = importedAspect.eContainer();
    boolean bypassFilter = false;
    JoinPointType _switchResult = null;
    boolean _matched = false;
    if (aspectContainer instanceof Microservice) {
      _matched=true;
      JoinPointType _xblockexpression = null;
      {
        forProtocolsAndDataFormats = IterableExtensions.<Pair<Protocol, DataFormat>>toList(this.getEffectiveProtocolsAndDataFormats(((Microservice)aspectContainer)).values());
        _xblockexpression = JoinPointType.MICROSERVICES;
      }
      _switchResult = _xblockexpression;
    }
    if (!_matched) {
      if (aspectContainer instanceof Interface) {
        _matched=true;
        JoinPointType _xifexpression = null;
        boolean _onFirstInterfaceOperation = this.onFirstInterfaceOperation(importedAspect);
        boolean _not = (!_onFirstInterfaceOperation);
        if (_not) {
          JoinPointType _xblockexpression = null;
          {
            forProtocolsAndDataFormats = IterableExtensions.<Pair<Protocol, DataFormat>>toList(this.getEffectiveProtocolsAndDataFormats(((Interface)aspectContainer)).values());
            _xblockexpression = JoinPointType.INTERFACES;
          }
          _xifexpression = _xblockexpression;
        } else {
          JoinPointType _xblockexpression_1 = null;
          {
            bypassFilter = true;
            _xblockexpression_1 = JoinPointType.OPERATIONS;
          }
          _xifexpression = _xblockexpression_1;
        }
        _switchResult = _xifexpression;
      }
    }
    if (!_matched) {
      if (aspectContainer instanceof Operation) {
        _matched=true;
        JoinPointType _xblockexpression = null;
        {
          forProtocolsAndDataFormats = IterableExtensions.<Pair<Protocol, DataFormat>>toList(this.getEffectiveProtocolsAndDataFormats(((Operation)aspectContainer)).values());
          _xblockexpression = JoinPointType.OPERATIONS;
        }
        _switchResult = _xblockexpression;
      }
    }
    if (!_matched) {
      if (aspectContainer instanceof ReferredOperation) {
        _matched=true;
        JoinPointType _xblockexpression = null;
        {
          forProtocolsAndDataFormats = IterableExtensions.<Pair<Protocol, DataFormat>>toList(this.getEffectiveProtocolsAndDataFormats(((ReferredOperation)aspectContainer)).values());
          _xblockexpression = JoinPointType.OPERATIONS;
        }
        _switchResult = _xblockexpression;
      }
    }
    if (!_matched) {
      if (aspectContainer instanceof Parameter) {
        _matched=true;
        JoinPointType _xblockexpression = null;
        {
          forCommunicationType = ((Parameter)aspectContainer).getCommunicationType();
          forExchangePattern = ((Parameter)aspectContainer).getExchangePattern();
          final Pair<Protocol, DataFormat> effectiveProtocolAndDataFormat = this.getEffectiveProtocolAndDataFormat(((Parameter)aspectContainer));
          List<Pair<Protocol, DataFormat>> _xifexpression = null;
          if ((effectiveProtocolAndDataFormat != null)) {
            _xifexpression = Collections.<Pair<Protocol, DataFormat>>unmodifiableList(CollectionLiterals.<Pair<Protocol, DataFormat>>newArrayList(effectiveProtocolAndDataFormat));
          } else {
            _xifexpression = null;
          }
          forProtocolsAndDataFormats = _xifexpression;
          _xblockexpression = JoinPointType.PARAMETERS;
        }
        _switchResult = _xblockexpression;
      }
    }
    final JoinPointType joinPoint = _switchResult;
    final List<EObject> resourceContents = LemmaUtils.getImportedModelContents(importedAspect.eResource(), 
      importedAspect.getImport().getImportURI());
    if (((resourceContents == null) || resourceContents.isEmpty())) {
      return IScope.NULLSCOPE;
    }
    EObject _get = resourceContents.get(0);
    final Function1<ServiceAspect, Boolean> _function = (ServiceAspect it) -> {
      return Boolean.valueOf(it.getJoinPoints().contains(joinPoint));
    };
    final List<ServiceAspect> declaredAspectsForJoinPoint = IterableExtensions.<ServiceAspect>toList(IterableExtensions.<ServiceAspect>filter(((Technology) _get).getServiceAspects(), _function));
    Collection<ServiceAspect> _xifexpression = null;
    if ((!bypassFilter)) {
      _xifexpression = this.filterAspectsForMatching(joinPoint, declaredAspectsForJoinPoint, forExchangePattern, forCommunicationType, forProtocolsAndDataFormats);
    } else {
      _xifexpression = declaredAspectsForJoinPoint;
    }
    final Collection<ServiceAspect> scopeAspects = _xifexpression;
    final Function1<ServiceAspect, IEObjectDescription> _function_1 = (ServiceAspect it) -> {
      IEObjectDescription _xblockexpression = null;
      {
        final QualifiedName protocolName = QualifiedName.create(it.getQualifiedNameParts(false, true));
        _xblockexpression = EObjectDescription.create(protocolName, it);
      }
      return _xblockexpression;
    };
    final Iterable<IEObjectDescription> scopeElements = IterableExtensions.<ServiceAspect, IEObjectDescription>map(scopeAspects, _function_1);
    return MapBasedScope.createScope(IScope.NULLSCOPE, scopeElements);
  }
  
  /**
   * Helper to determine scope aspects from pointcut selector values
   */
  protected AbstractCollection<ServiceAspect> filterAspectsForMatching(final JoinPointType joinPoint, final List<ServiceAspect> aspects, final ExchangePattern exchangePattern, final CommunicationType communicationType, final List<Pair<Protocol, DataFormat>> protocolsAndFormats) {
    if (((protocolsAndFormats == null) || protocolsAndFormats.isEmpty())) {
      return this.findMatchingAspects(joinPoint, aspects, exchangePattern, communicationType, null, 
        null);
    }
    final HashSet<ServiceAspect> uniqueMatchingAspects = CollectionLiterals.<ServiceAspect>newHashSet();
    for (final Pair<Protocol, DataFormat> protocolAndFormat : protocolsAndFormats) {
      uniqueMatchingAspects.addAll(this.findMatchingAspects(joinPoint, aspects, exchangePattern, communicationType, protocolAndFormat.getKey(), protocolAndFormat.getValue()));
    }
    return uniqueMatchingAspects;
  }
  
  /**
   * Filter a list of service aspects for those for which either the passed pointcut selector
   * values are not applicable or, in case they are applicable, for those that match the given
   * pointcut selector values
   */
  private ArrayList<ServiceAspect> findMatchingAspects(final JoinPointType joinPoint, final List<ServiceAspect> aspects, final ExchangePattern exchangePattern, final CommunicationType communicationType, final Protocol protocol, final DataFormat dataFormat) {
    final ArrayList<ServiceAspect> matchingAspects = CollectionLiterals.<ServiceAspect>newArrayList();
    final Consumer<ServiceAspect> _function = (ServiceAspect aspect) -> {
      final boolean validPointcutSelector = aspect.isValidSelectorForJoinPoint(joinPoint, exchangePattern, communicationType, protocol, dataFormat);
      boolean _xifexpression = false;
      if (validPointcutSelector) {
        _xifexpression = aspect.hasMatchingSelector(exchangePattern, communicationType, protocol, dataFormat);
      } else {
        _xifexpression = true;
      }
      final boolean matchingAspect = _xifexpression;
      if (matchingAspect) {
        matchingAspects.add(aspect);
      }
    };
    aspects.forEach(_function);
    return matchingAspects;
  }
  
  /**
   * Helper to determine if an aspect is to be annotated on an interface or the first operation
   * _within_ an interface
   */
  private boolean onFirstInterfaceOperation(final ImportedServiceAspect aspect) {
    ICompositeNode _node = NodeModelUtils.getNode(aspect);
    ICompositeNode _parent = null;
    if (_node!=null) {
      _parent=_node.getParent();
    }
    String _text = null;
    if (_parent!=null) {
      _text=_parent.getText();
    }
    final String textBeforeAspect = _text;
    if ((textBeforeAspect == null)) {
      return false;
    }
    final Pattern interfaceKeywordInText = Pattern.compile("(.*\\s+interface\\s+.*)|(.*\\s+interface)");
    boolean _find = interfaceKeywordInText.matcher(textBeforeAspect).find();
    return (!_find);
  }
  
  /**
   * Get the annotated technologies of a microservice, that is the container of the given context,
   * as scopes
   */
  private IScope getServiceTechnologyImportAliasesAsScope(final EObject context) {
    final Microservice microservice = EcoreUtil2.<Microservice>getContainerOfType(context, Microservice.class);
    if (((microservice == null) || microservice.getTechnologyReferences().isEmpty())) {
      return IScope.NULLSCOPE;
    }
    final Function1<TechnologyReference, Import> _function = (TechnologyReference it) -> {
      return it.getTechnology();
    };
    return Scopes.scopeFor(ListExtensions.<TechnologyReference, Import>map(microservice.getTechnologyReferences(), _function));
  }
  
  /**
   * Convenience method for building a scope for a possibly imported microservice without an
   * import specification
   */
  private IScope getScopeForPossiblyImportedMicroservice(final EObject context) {
    return this.getScopeForPossiblyImportedMicroservice(context, null);
  }
  
  /**
   * Helper method to build a scope for possibly imported microservices, i.e., a microservice
   * with or without import specifications. Microservices required by another microservice may
   * possibly be imported.
   */
  private IScope getScopeForPossiblyImportedMicroservice(final EObject context, final Import import_) {
    if ((!((context instanceof Microservice) || 
      (context instanceof PossiblyImportedMicroservice)))) {
      return IScope.NULLSCOPE;
    }
    Microservice _switchResult = null;
    boolean _matched = false;
    if (context instanceof Microservice) {
      _matched=true;
      _switchResult = ((Microservice) context);
    }
    if (!_matched) {
      if (context instanceof PossiblyImportedMicroservice) {
        _matched=true;
        _switchResult = EcoreUtil2.<Microservice>getContainerOfType(context, Microservice.class);
      }
    }
    final Microservice microservice = _switchResult;
    String _xifexpression = null;
    if ((import_ != null)) {
      _xifexpression = import_.getImportURI();
    } else {
      _xifexpression = null;
    }
    final String importUri = _xifexpression;
    final Function<ServiceModel, List<Microservice>> _function = (ServiceModel it) -> {
      return IterableExtensions.<Microservice>toList(it.getMicroservices());
    };
    final Function<Microservice, List<String>> _function_1 = (Microservice it) -> {
      return it.getQualifiedNameParts();
    };
    final Predicate<Microservice> _function_2 = (Microservice it) -> {
      return microservice.canRequire(it, (importUri != null));
    };
    return LemmaUtils.<Microservice, ServiceModel, Microservice>getScopeForPossiblyImportedConcept(microservice, 
      microservice.getQualifiedNameParts(), 
      ServiceModel.class, importUri, _function, _function_1, _function_2);
  }
  
  /**
   * Convenience method to build a scope for a possibly imported interface without an import
   * specification
   */
  private IScope getScopeForPossiblyImportedInterface(final EObject context) {
    return this.getScopeForPossiblyImportedInterface(context, null);
  }
  
  /**
   * Build scope for possibly imported interfaces, i.e., interfaces with or without import
   * specifications. Interfaces required by a microservice may possibly be imported.
   */
  private IScope getScopeForPossiblyImportedInterface(final EObject context, final Import import_) {
    if ((!((context instanceof Microservice) || 
      (context instanceof PossiblyImportedInterface)))) {
      return IScope.NULLSCOPE;
    }
    Microservice _switchResult = null;
    boolean _matched = false;
    if (context instanceof Microservice) {
      _matched=true;
      _switchResult = ((Microservice) context);
    }
    if (!_matched) {
      if (context instanceof PossiblyImportedInterface) {
        _matched=true;
        _switchResult = EcoreUtil2.<Microservice>getContainerOfType(context, Microservice.class);
      }
    }
    final Microservice microservice = _switchResult;
    String _xifexpression = null;
    if ((import_ != null)) {
      _xifexpression = import_.getImportURI();
    } else {
      _xifexpression = null;
    }
    final String importUri = _xifexpression;
    final Function<ServiceModel, List<Interface>> _function = (ServiceModel it) -> {
      return IterableExtensions.<Interface>toList(it.getContainedInterfaces());
    };
    final Function<Interface, List<String>> _function_1 = (Interface it) -> {
      return it.getQualifiedNameParts();
    };
    final Predicate<Interface> _function_2 = (Interface it) -> {
      return microservice.canRequire(it, (importUri != null));
    };
    return LemmaUtils.<Microservice, ServiceModel, Interface>getScopeForPossiblyImportedConcept(microservice, 
      microservice.getQualifiedNameParts(), 
      ServiceModel.class, importUri, _function, _function_1, _function_2);
  }
  
  /**
   * Convenience method to build a scope for a possibly imported operation without an import
   * specification
   */
  private IScope getScopeForPossiblyImportedOperation(final EObject context) {
    return this.getScopeForPossiblyImportedOperation(context, null);
  }
  
  /**
   * Build scope for possibly imported operations, i.e., operations with or without import
   * specifications. Operations required by a microservice or used to initialize parameters of
   * other operations may possibly be imported.
   */
  private IScope getScopeForPossiblyImportedOperation(final EObject context, final Import import_) {
    if ((!((context instanceof Microservice) || 
      (context instanceof PossiblyImportedOperation)))) {
      return IScope.NULLSCOPE;
    }
    EObject scopeContainer = null;
    List<String> scopeContainerNameParts = null;
    final ArrayList<Predicate<Operation>> predicates = CollectionLiterals.<Predicate<Operation>>newArrayList();
    String _xifexpression = null;
    if ((import_ != null)) {
      _xifexpression = import_.getImportURI();
    } else {
      _xifexpression = null;
    }
    final String importUri = _xifexpression;
    boolean _matched = false;
    if (context instanceof Microservice) {
      _matched=true;
      final Microservice microservice = ((Microservice)context);
      scopeContainer = microservice;
      scopeContainerNameParts = microservice.getQualifiedNameParts();
      final Predicate<Operation> _function = (Operation it) -> {
        return ((Microservice)context).canRequire(it, (importUri != null));
      };
      predicates.add(_function);
    }
    if (!_matched) {
      if (context instanceof PossiblyImportedOperation) {
        EObject _eContainer = ((PossiblyImportedOperation)context).eContainer();
        if ((_eContainer instanceof Microservice)) {
          _matched=true;
          EObject _eContainer_1 = ((PossiblyImportedOperation)context).eContainer();
          final Microservice microservice = ((Microservice) _eContainer_1);
          scopeContainer = microservice;
          scopeContainerNameParts = microservice.getQualifiedNameParts();
          final Predicate<Operation> _function = (Operation it) -> {
            return microservice.canRequire(it, (importUri != null));
          };
          predicates.add(_function);
        }
      }
    }
    if (!_matched) {
      if (context instanceof PossiblyImportedOperation) {
        EObject _eContainer = ((PossiblyImportedOperation)context).eContainer();
        if ((_eContainer instanceof Parameter)) {
          _matched=true;
          final Operation operation = EcoreUtil2.<Operation>getContainerOfType(context, Operation.class);
          scopeContainer = operation;
          scopeContainerNameParts = operation.getQualifiedNameParts();
          final Predicate<Operation> _function = (Operation it) -> {
            EObject _eContainer_1 = ((PossiblyImportedOperation)context).eContainer();
            return ((Parameter) _eContainer_1).basicallyInitializableBy(it);
          };
          predicates.add(_function);
        }
      }
    }
    final Function<ServiceModel, List<Operation>> _function = (ServiceModel it) -> {
      return IterableExtensions.<Operation>toList(it.getContainedOperations());
    };
    final Function<Operation, List<String>> _function_1 = (Operation it) -> {
      return it.getQualifiedNameParts();
    };
    return LemmaUtils.<EObject, ServiceModel, Operation>getScopeForPossiblyImportedConcept(scopeContainer, scopeContainerNameParts, 
      ServiceModel.class, importUri, _function, _function_1, ((Predicate<Operation>[])Conversions.unwrapArray(predicates, Predicate.class)));
  }
  
  /**
   * Build scope for imports of possibly imported Operations
   */
  private IScope getScopeForOperationImport(final Parameter parameter) {
    final Microservice containingMicroservice = EcoreUtil2.<Microservice>getContainerOfType(parameter, Microservice.class);
    return Scopes.scopeFor(containingMicroservice.getRequiredImports());
  }
  
  /**
   * Build scope for initializing operations
   */
  private IScope getScopeForInitializingOperation(final Parameter parameter) {
    final Microservice microservice = EcoreUtil2.<Microservice>getContainerOfType(parameter, Microservice.class);
    final Import import_ = parameter.getInitializedByOperation().getImport();
    final HashSet<Operation> candidateOperations = CollectionLiterals.<Operation>newHashSet(
      ((Operation[])Conversions.unwrapArray(microservice.getAllRequiredOperations(import_), Operation.class)));
    if ((import_ == null)) {
      final EList<Operation> localOperations = microservice.getContainedOperations();
      candidateOperations.addAll(localOperations);
    }
    final Operation operation = EcoreUtil2.<Operation>getContainerOfType(parameter, Operation.class);
    final Function<Operation, List<String>> _function = (Operation it) -> {
      return it.getQualifiedNameParts();
    };
    final Predicate<Operation> _function_1 = (Operation it) -> {
      return parameter.basicallyInitializableBy(it);
    };
    return LemmaUtils.<Operation, Operation, ServiceModel>getScopeWithRelativeQualifiedNames(
      IterableExtensions.<Operation>toList(candidateOperations), _function, operation, 
      operation.getQualifiedNameParts(), 
      ServiceModel.class, _function_1);
  }
  
  /**
   * Build scope for imported protocols
   */
  private IScope getScopeForImportedProtocol(final ImportedProtocolAndDataFormat importedProtocol) {
    final List<EObject> resourceContents = LemmaUtils.getImportedModelContents(importedProtocol.eResource(), 
      importedProtocol.getImport().getImportURI());
    if (((resourceContents == null) || resourceContents.isEmpty())) {
      return IScope.NULLSCOPE;
    }
    ProtocolSpecification _specification = importedProtocol.getSpecification();
    final boolean isProtocolSpecification = (_specification != null);
    CommunicationType _xifexpression = null;
    if (isProtocolSpecification) {
      _xifexpression = importedProtocol.getSpecification().getCommunicationType();
    }
    final CommunicationType filterCommunicationType = _xifexpression;
    EObject _get = resourceContents.get(0);
    final Technology resourceRoot = ((Technology) _get);
    final Function1<Protocol, Boolean> _function = (Protocol it) -> {
      return Boolean.valueOf(((!isProtocolSpecification) || Objects.equal(filterCommunicationType, it.getCommunicationType())));
    };
    final Function1<Protocol, IEObjectDescription> _function_1 = (Protocol it) -> {
      IEObjectDescription _xblockexpression = null;
      {
        final QualifiedName protocolName = QualifiedName.create(it.getQualifiedNameParts());
        _xblockexpression = EObjectDescription.create(protocolName, it);
      }
      return _xblockexpression;
    };
    final Iterable<IEObjectDescription> scopeElements = IterableExtensions.<Protocol, IEObjectDescription>map(IterableExtensions.<Protocol>filter(resourceRoot.getProtocols(), _function), _function_1);
    return MapBasedScope.createScope(IScope.NULLSCOPE, scopeElements);
  }
  
  /**
   * Build scope for data formats of imported protocols
   */
  private IScope getScopeForDataFormat(final ImportedProtocolAndDataFormat importedProtocol) {
    final List<EObject> resourceContents = LemmaUtils.getImportedModelContents(importedProtocol.eResource(), 
      importedProtocol.getImport().getImportURI());
    if (((resourceContents == null) || resourceContents.isEmpty())) {
      return IScope.NULLSCOPE;
    }
    final String protocolName = importedProtocol.getImportedProtocol().getName();
    if ((protocolName == null)) {
      return IScope.NULLSCOPE;
    }
    EObject _get = resourceContents.get(0);
    final Technology resourceRoot = ((Technology) _get);
    final Function1<Protocol, Boolean> _function = (Protocol it) -> {
      String _name = it.getName();
      return Boolean.valueOf(Objects.equal(_name, protocolName));
    };
    final EList<DataFormat> scopeElements = IterableExtensions.<Protocol>findFirst(resourceRoot.getProtocols(), _function).getDataFormats();
    final Function<DataFormat, QualifiedName> _function_1 = (DataFormat it) -> {
      return QualifiedName.create(it.getFormatName());
    };
    return Scopes.<DataFormat>scopeFor(scopeElements, _function_1, 
      IScope.NULLSCOPE);
  }
  
  /**
   * Build scope for complex types imported from a data model
   */
  private IScope getScopeForImportedComplexTypes(final DataModel dataModel) {
    final Function1<ComplexType, IEObjectDescription> _function = (ComplexType it) -> {
      IEObjectDescription _xblockexpression = null;
      {
        final QualifiedName typeName = QualifiedName.create(it.getQualifiedNameParts());
        _xblockexpression = EObjectDescription.create(typeName, it);
      }
      return _xblockexpression;
    };
    final List<IEObjectDescription> scopeElements = ListExtensions.<ComplexType, IEObjectDescription>map(dataModel.getContainedComplexTypes(), _function);
    return MapBasedScope.createScope(IScope.NULLSCOPE, scopeElements);
  }
  
  /**
   * Build scope for primitive and complex types imported from technology
   */
  private IScope getScopeForImportedTypes(final Technology technology) {
    final ArrayList<IEObjectDescription> scopeElements = CollectionLiterals.<IEObjectDescription>newArrayList();
    final Function1<TechnologySpecificPrimitiveType, IEObjectDescription> _function = (TechnologySpecificPrimitiveType it) -> {
      IEObjectDescription _xblockexpression = null;
      {
        final QualifiedName typeName = QualifiedName.create(it.getQualifiedNameParts());
        _xblockexpression = EObjectDescription.create(typeName, it);
      }
      return _xblockexpression;
    };
    scopeElements.addAll(
      ListExtensions.<TechnologySpecificPrimitiveType, IEObjectDescription>map(technology.getPrimitiveTypes(), _function));
    final Function1<TechnologySpecificCollectionType, IEObjectDescription> _function_1 = (TechnologySpecificCollectionType it) -> {
      IEObjectDescription _xblockexpression = null;
      {
        final QualifiedName typeName = QualifiedName.create(it.getQualifiedNameParts());
        _xblockexpression = EObjectDescription.create(typeName, it);
      }
      return _xblockexpression;
    };
    scopeElements.addAll(
      ListExtensions.<TechnologySpecificCollectionType, IEObjectDescription>map(technology.getCollectionTypes(), _function_1));
    final Function1<TechnologySpecificDataStructure, IEObjectDescription> _function_2 = (TechnologySpecificDataStructure it) -> {
      IEObjectDescription _xblockexpression = null;
      {
        final QualifiedName typeName = QualifiedName.create(it.getQualifiedNameParts());
        _xblockexpression = EObjectDescription.create(typeName, it);
      }
      return _xblockexpression;
    };
    scopeElements.addAll(
      ListExtensions.<TechnologySpecificDataStructure, IEObjectDescription>map(technology.getDataStructures(), _function_2));
    return MapBasedScope.createScope(IScope.NULLSCOPE, scopeElements);
  }
  
  /**
   * Convenience method to create a scope for imports of certain types
   */
  private IScope getScopeForImportsOfType(final EObject context, final Class<? extends EObject>... types) {
    final EList<Import> allImports = EcoreUtil2.<ServiceModel>getContainerOfType(context, ServiceModel.class).getImports();
    final Function<Import, String> _function = (Import it) -> {
      return it.getImportURI();
    };
    final Iterable<Import> validImports = LemmaUtils.<Import>getImportsOfModelTypes(allImports, _function, types);
    return Scopes.scopeFor(validImports);
  }
  
  /**
   * Build scope for protocol specifications on microservices, interfaces, and operations
   */
  private IScope getScope(final ProtocolSpecification protocolSpecification, final EReference reference) {
    if ((reference != ServicePackage.Literals.IMPORTED_PROTOCOL_AND_DATA_FORMAT__IMPORT)) {
      return IScope.NULLSCOPE;
    }
    return this.getServiceTechnologyImportAliasesAsScope(protocolSpecification);
  }
  
  /**
   * Helper method to determine effective protocols and data formats of a microservice
   */
  private Map<CommunicationType, Pair<Protocol, DataFormat>> getEffectiveProtocolsAndDataFormats(final Microservice microservice) {
    final Map<CommunicationType, Pair<Protocol, DataFormat>> results = this.<EObject>getEffectiveProtocolsAndDataFormats(microservice.getProtocols(), null, null);
    final ArrayList<CommunicationType> missingCommunicationTypes = CollectionLiterals.<CommunicationType>newArrayList();
    boolean _containsKey = results.containsKey(CommunicationType.ASYNCHRONOUS);
    boolean _not = (!_containsKey);
    if (_not) {
      missingCommunicationTypes.add(CommunicationType.ASYNCHRONOUS);
    }
    boolean _containsKey_1 = results.containsKey(CommunicationType.SYNCHRONOUS);
    boolean _not_1 = (!_containsKey_1);
    if (_not_1) {
      missingCommunicationTypes.add(CommunicationType.SYNCHRONOUS);
    }
    if ((missingCommunicationTypes.isEmpty() || microservice.getTechnologyReferences().isEmpty())) {
      return results;
    }
    final Function1<TechnologyReference, Import> _function = (TechnologyReference it) -> {
      return it.getTechnology();
    };
    final Consumer<Import> _function_1 = (Import it) -> {
      final List<EObject> resourceContents = LemmaUtils.getImportedModelContents(it.eResource(), it.getImportURI());
      if (((resourceContents != null) && (!resourceContents.isEmpty()))) {
        EObject _get = resourceContents.get(0);
        final Technology technologyModel = ((Technology) _get);
        final Consumer<CommunicationType> _function_2 = (CommunicationType communicationType) -> {
          Protocol defaultProtocol = null;
          DataFormat defaultDataFormat = null;
          final Function1<Protocol, Boolean> _function_3 = (Protocol it_1) -> {
            CommunicationType _communicationType = it_1.getCommunicationType();
            return Boolean.valueOf(Objects.equal(_communicationType, communicationType));
          };
          final Function1<Protocol, Boolean> _function_4 = (Protocol it_1) -> {
            return Boolean.valueOf(it_1.isDefault());
          };
          defaultProtocol = IterableExtensions.<Protocol>findFirst(IterableExtensions.<Protocol>filter(technologyModel.getProtocols(), _function_3), _function_4);
          if ((defaultProtocol != null)) {
            defaultDataFormat = defaultProtocol.getDefaultFormat();
          }
          if ((defaultProtocol != null)) {
            results.put(communicationType, Pair.<Protocol, DataFormat>of(defaultProtocol, defaultDataFormat));
          }
        };
        missingCommunicationTypes.forEach(_function_2);
      }
    };
    ListExtensions.<TechnologyReference, Import>map(microservice.getTechnologyReferences(), _function).forEach(_function_1);
    return results;
  }
  
  /**
   * Helper method to determine effective protocols and data formats of an interface
   */
  private Map<CommunicationType, Pair<Protocol, DataFormat>> getEffectiveProtocolsAndDataFormats(final Interface interface_) {
    final Function<Microservice, Map<CommunicationType, Pair<Protocol, DataFormat>>> _function = (Microservice it) -> {
      return this.getEffectiveProtocolsAndDataFormats(it);
    };
    return this.<Microservice>getEffectiveProtocolsAndDataFormats(interface_.getProtocols(), interface_.getMicroservice(), _function);
  }
  
  /**
   * Helper method to determine effective protocols and data formats of an operation
   */
  private Map<CommunicationType, Pair<Protocol, DataFormat>> getEffectiveProtocolsAndDataFormats(final Operation operation) {
    final Function<Interface, Map<CommunicationType, Pair<Protocol, DataFormat>>> _function = (Interface it) -> {
      return this.getEffectiveProtocolsAndDataFormats(it);
    };
    return this.<Interface>getEffectiveProtocolsAndDataFormats(operation.getProtocols(), operation.getInterface(), _function);
  }
  
  /**
   * Helper method to determine effective protocols and data formats of a referred operation
   */
  private Map<CommunicationType, Pair<Protocol, DataFormat>> getEffectiveProtocolsAndDataFormats(final ReferredOperation referredOperation) {
    final Function<Interface, Map<CommunicationType, Pair<Protocol, DataFormat>>> _function = (Interface it) -> {
      return this.getEffectiveProtocolsAndDataFormats(it);
    };
    return this.<Interface>getEffectiveProtocolsAndDataFormats(referredOperation.getProtocols(), 
      referredOperation.getInterface(), _function);
  }
  
  /**
   * Helper method to determine effective protocol and data format for a parameter with
   * consideration of its communication type
   */
  private Pair<Protocol, DataFormat> getEffectiveProtocolAndDataFormat(final Parameter parameter) {
    final Map<CommunicationType, Pair<Protocol, DataFormat>> operationProtocolsAndDataFormats = this.getEffectiveProtocolsAndDataFormats(parameter.getOperation());
    return operationProtocolsAndDataFormats.get(parameter.getCommunicationType());
  }
  
  /**
   * Helper method to determine effective protocols and data formats from protocol specifications
   * and possibly the containing concept, if protocol and data format couldn't be determined for a
   * communication type.
   * 
   * The method takes the following type arguments:
   *     - CONTAINER: The container of the protocol specifications.
   * 
   * The function argument of the method returns for a given CONTAINER object the effective
   * protocols and data formats.
   */
  private <CONTAINER extends EObject> Map<CommunicationType, Pair<Protocol, DataFormat>> getEffectiveProtocolsAndDataFormats(final List<ProtocolSpecification> protocolSpecifications, final CONTAINER container, final Function<CONTAINER, Map<CommunicationType, Pair<Protocol, DataFormat>>> getFromContainer) {
    final Map<CommunicationType, Pair<Protocol, DataFormat>> results = CollectionLiterals.<CommunicationType, Pair<Protocol, DataFormat>>newHashMap();
    final ArrayList<CommunicationType> missingCommunicationTypes = CollectionLiterals.<CommunicationType>newArrayList();
    ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, 2, true);
    for (final Integer i : _doubleDotLessThan) {
      {
        CommunicationType _switchResult = null;
        if (i != null) {
          switch (i) {
            case 0:
              _switchResult = CommunicationType.ASYNCHRONOUS;
              break;
            case 1:
              _switchResult = CommunicationType.SYNCHRONOUS;
              break;
          }
        }
        final CommunicationType communicationType = _switchResult;
        Protocol protocol = null;
        DataFormat dataFormat = null;
        final Function1<ProtocolSpecification, Boolean> _function = (ProtocolSpecification it) -> {
          CommunicationType _communicationType = it.getCommunicationType();
          return Boolean.valueOf(Objects.equal(_communicationType, communicationType));
        };
        ProtocolSpecification protocolSpecification = IterableExtensions.<ProtocolSpecification>findFirst(protocolSpecifications, _function);
        if ((((protocolSpecification != null) && 
          (protocolSpecification.getProtocol() != null)) && 
          (protocolSpecification.getProtocol().getImportedProtocol() != null))) {
          protocol = protocolSpecification.getProtocol().getImportedProtocol();
          DataFormat _elvis = null;
          DataFormat _dataFormat = protocolSpecification.getProtocol().getDataFormat();
          if (_dataFormat != null) {
            _elvis = _dataFormat;
          } else {
            DataFormat _defaultFormat = protocol.getDefaultFormat();
            _elvis = _defaultFormat;
          }
          dataFormat = _elvis;
        }
        if ((protocol != null)) {
          results.put(communicationType, Pair.<Protocol, DataFormat>of(protocol, dataFormat));
        } else {
          missingCommunicationTypes.add(communicationType);
        }
      }
    }
    if ((((container != null) && (getFromContainer != null)) && (!missingCommunicationTypes.isEmpty()))) {
      final Map<CommunicationType, Pair<Protocol, DataFormat>> containerResults = getFromContainer.apply(container);
      final Function1<Map.Entry<CommunicationType, Pair<Protocol, DataFormat>>, Boolean> _function = (Map.Entry<CommunicationType, Pair<Protocol, DataFormat>> it) -> {
        return Boolean.valueOf(missingCommunicationTypes.contains(it.getKey()));
      };
      final Consumer<Map.Entry<CommunicationType, Pair<Protocol, DataFormat>>> _function_1 = (Map.Entry<CommunicationType, Pair<Protocol, DataFormat>> it) -> {
        results.put(it.getKey(), it.getValue());
      };
      IterableExtensions.<Map.Entry<CommunicationType, Pair<Protocol, DataFormat>>>filter(containerResults.entrySet(), _function).forEach(_function_1);
    }
    return results;
  }
}
