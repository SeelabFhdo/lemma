/**
 * generated by Xtext 2.12.0
 */
package de.fhdo.lemma.validation;

import com.google.common.base.Function;
import com.google.common.base.Objects;
import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;
import com.google.inject.Inject;
import de.fhdo.lemma.ServiceDslQualifiedNameProvider;
import de.fhdo.lemma.data.DataModel;
import de.fhdo.lemma.data.PrimitiveType;
import de.fhdo.lemma.data.PrimitiveUnspecified;
import de.fhdo.lemma.data.PrimitiveValue;
import de.fhdo.lemma.data.Type;
import de.fhdo.lemma.service.ApiOperationComment;
import de.fhdo.lemma.service.ApiParameterComment;
import de.fhdo.lemma.service.Endpoint;
import de.fhdo.lemma.service.Import;
import de.fhdo.lemma.service.ImportType;
import de.fhdo.lemma.service.ImportedProtocolAndDataFormat;
import de.fhdo.lemma.service.ImportedServiceAspect;
import de.fhdo.lemma.service.Interface;
import de.fhdo.lemma.service.Microservice;
import de.fhdo.lemma.service.Operation;
import de.fhdo.lemma.service.Parameter;
import de.fhdo.lemma.service.PossiblyImportedInterface;
import de.fhdo.lemma.service.PossiblyImportedMicroservice;
import de.fhdo.lemma.service.PossiblyImportedOperation;
import de.fhdo.lemma.service.ProtocolSpecification;
import de.fhdo.lemma.service.ReferredOperation;
import de.fhdo.lemma.service.ServiceModel;
import de.fhdo.lemma.service.ServicePackage;
import de.fhdo.lemma.service.TechnologyReference;
import de.fhdo.lemma.service.Visibility;
import de.fhdo.lemma.technology.CommunicationType;
import de.fhdo.lemma.technology.DataFormat;
import de.fhdo.lemma.technology.ExchangePattern;
import de.fhdo.lemma.technology.Protocol;
import de.fhdo.lemma.technology.ServiceAspect;
import de.fhdo.lemma.technology.Technology;
import de.fhdo.lemma.technology.TechnologyPackage;
import de.fhdo.lemma.technology.TechnologySpecificPrimitiveType;
import de.fhdo.lemma.technology.TechnologySpecificProperty;
import de.fhdo.lemma.technology.TechnologySpecificPropertyValueAssignment;
import de.fhdo.lemma.typechecking.TypeChecker;
import de.fhdo.lemma.typechecking.TypesNotCompatibleException;
import de.fhdo.lemma.utils.LemmaUtils;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.ExclusiveRange;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;

/**
 * This class contains custom validation rules for service models.
 * 
 * @author <a href="mailto:florian.rademacher@fh-dortmund.de">Florian Rademacher</a>
 */
@SuppressWarnings("all")
public class ServiceDslValidator extends AbstractServiceDslValidator {
  @Inject
  private ServiceDslQualifiedNameProvider nameProvider;
  
  /**
   * Check if an imported file exists and if it is case sensitive
   */
  @Check
  public void checkImportFileExistsAndIsCaseSensitive(final Import import_) {
    final String importURI = import_.getImportURI();
    final Resource eResource = import_.eResource();
    boolean _importFileExists = LemmaUtils.importFileExists(eResource, importURI);
    boolean _not = (!_importFileExists);
    if (_not) {
      this.error("File not found", import_, 
        ServicePackage.Literals.IMPORT__IMPORT_URI);
    } else {
      boolean _importFileExistsCaseSensitive = LemmaUtils.importFileExistsCaseSensitive(eResource, importURI);
      boolean _not_1 = (!_importFileExistsCaseSensitive);
      if (_not_1) {
        this.error(("Import paths are case sensitive, but the case sensitivity of this import path " + 
          "does not match its appearance in the filesystem"), import_, 
          ServicePackage.Literals.IMPORT__IMPORT_URI);
      }
    }
  }
  
  /**
   * Check import aliases for uniqueness
   */
  @Check
  public void checkImportAlias(final ServiceModel serviceModel) {
    final Function<Import, String> _function = (Import it) -> {
      return it.getName();
    };
    final Integer duplicateIndex = LemmaUtils.<Import, String>getDuplicateIndex(serviceModel.getImports(), _function);
    if (((duplicateIndex).intValue() == (-1))) {
      return;
    }
    final Import duplicate = serviceModel.getImports().get((duplicateIndex).intValue());
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("Duplicate import alias ");
    String _name = duplicate.getName();
    _builder.append(_name);
    this.error(_builder.toString(), duplicate, 
      ServicePackage.Literals.IMPORT__NAME);
  }
  
  /**
   * Check that imported file defines a model that fits the given import type
   */
  @Check
  public void checkImportType(final Import import_) {
    Class<? extends EObject> expectedModelType = null;
    String expectedModelTypeName = null;
    ImportType _importType = import_.getImportType();
    if (_importType != null) {
      switch (_importType) {
        case DATATYPES:
          expectedModelType = DataModel.class;
          expectedModelTypeName = "data";
          break;
        case MICROSERVICES:
          expectedModelType = ServiceModel.class;
          expectedModelTypeName = "service";
          break;
        case TECHNOLOGY:
          expectedModelType = Technology.class;
          expectedModelTypeName = "technology";
          break;
        default:
          return;
      }
    } else {
      return;
    }
    boolean _isImportOfType = LemmaUtils.isImportOfType(import_.eResource(), import_.getImportURI(), expectedModelType);
    boolean _not = (!_isImportOfType);
    if (_not) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("File does not contain a ");
      _builder.append(expectedModelTypeName);
      _builder.append(" model definition");
      this.error(_builder.toString(), import_, 
        ServicePackage.Literals.IMPORT__IMPORT_URI);
    }
  }
  
  /**
   * Check that model does not import itself
   */
  @Check
  public void checkForSelfImport(final ServiceModel thisModel) {
    final Function<Import, String> _function = (Import it) -> {
      return it.getImportURI();
    };
    final Iterable<Import> importedServiceModels = LemmaUtils.<Import>getImportsOfModelTypes(thisModel.getImports(), _function, 
      ServiceModel.class);
    final Consumer<Import> _function_1 = (Import it) -> {
      final List<EObject> importedRoot = LemmaUtils.getImportedModelContents(it.eResource(), it.getImportURI());
      if (((!importedRoot.isEmpty()) && Objects.equal(importedRoot.get(0), thisModel))) {
        this.error("Model may not import itself", it, 
          ServicePackage.Literals.IMPORT__IMPORT_URI);
      }
    };
    importedServiceModels.forEach(_function_1);
  }
  
  /**
   * Check that imported file is imported exactly once
   */
  @Check
  public void checkImportFileUniqueness(final ServiceModel serviceModel) {
    final String absolutePath = LemmaUtils.absolutePath(serviceModel.eResource());
    final Function1<Import, String> _function = (Import it) -> {
      return LemmaUtils.convertToAbsolutePath(it.getImportURI(), absolutePath);
    };
    final List<String> absoluteImportPaths = ListExtensions.<Import, String>map(serviceModel.getImports(), _function);
    final Function<String, String> _function_1 = (String it) -> {
      return it;
    };
    final Integer duplicateIndex = LemmaUtils.<String, String>getDuplicateIndex(absoluteImportPaths, _function_1);
    if (((duplicateIndex).intValue() == (-1))) {
      return;
    }
    final Import duplicate = serviceModel.getImports().get((duplicateIndex).intValue());
    this.error("File is already being imported", duplicate, 
      ServicePackage.Literals.IMPORT__IMPORT_URI);
  }
  
  /**
   * Warn about non-unique microservice endpoints' addresses per protocol/data format combination
   */
  @Check
  public void warnUniqueEndpointAddresses(final ServiceModel serviceModel) {
    final Function1<Microservice, EList<Endpoint>> _function = (Microservice it) -> {
      return it.getEndpoints();
    };
    final List<Endpoint> microserviceEndpoints = IterableExtensions.<Endpoint>toList(Iterables.<Endpoint>concat(ListExtensions.<Microservice, EList<Endpoint>>map(serviceModel.getMicroservices(), _function)));
    final Function<Endpoint, List<String>> _function_1 = (Endpoint it) -> {
      return it.getMicroservice().getQualifiedNameParts();
    };
    this.warnUniqueEndpointAddresses(microserviceEndpoints, "microservice", _function_1);
  }
  
  /**
   * Warn about non-unique interface endpoints' addresses per protocol/data format combination
   */
  @Check
  public void warnUniqueEndpointAddresses(final Microservice microservice) {
    final Function1<Interface, EList<Endpoint>> _function = (Interface it) -> {
      return it.getEndpoints();
    };
    final List<Endpoint> interfaceEndpoints = IterableExtensions.<Endpoint>toList(Iterables.<Endpoint>concat(ListExtensions.<Interface, EList<Endpoint>>map(microservice.getInterfaces(), _function)));
    final Function<Endpoint, List<String>> _function_1 = (Endpoint it) -> {
      return it.getInterface().getQualifiedNameParts();
    };
    this.warnUniqueEndpointAddresses(interfaceEndpoints, "interface", _function_1);
  }
  
  /**
   * Warn about non-unique operation endpoints' addresses per protocol/data format combination
   */
  @Check
  public void warnUniqueEndpointAddresses(final Interface interface_) {
    final List<Endpoint> operationEndpoints = CollectionLiterals.<Endpoint>newArrayList();
    final Function1<ReferredOperation, EList<Endpoint>> _function = (ReferredOperation it) -> {
      return it.getEndpoints();
    };
    Iterables.<Endpoint>addAll(operationEndpoints, Iterables.<Endpoint>concat(ListExtensions.<ReferredOperation, EList<Endpoint>>map(interface_.getReferredOperations(), _function)));
    final Function1<Operation, EList<Endpoint>> _function_1 = (Operation it) -> {
      return it.getEndpoints();
    };
    Iterables.<Endpoint>addAll(operationEndpoints, Iterables.<Endpoint>concat(ListExtensions.<Operation, EList<Endpoint>>map(interface_.getOperations(), _function_1)));
    final Function<Endpoint, List<String>> _function_2 = (Endpoint it) -> {
      EList<String> _xifexpression = null;
      Operation _operation = it.getOperation();
      boolean _tripleNotEquals = (_operation != null);
      if (_tripleNotEquals) {
        _xifexpression = it.getOperation().getQualifiedNameParts();
      } else {
        EList<String> _xifexpression_1 = null;
        ReferredOperation _referredOperation = it.getReferredOperation();
        boolean _tripleNotEquals_1 = (_referredOperation != null);
        if (_tripleNotEquals_1) {
          _xifexpression_1 = it.getReferredOperation().getQualifiedNameParts();
        }
        _xifexpression = _xifexpression_1;
      }
      return _xifexpression;
    };
    this.warnUniqueEndpointAddresses(operationEndpoints, "operation", _function_2);
  }
  
  /**
   * Check that technology is assigned only once to a microservice
   */
  @Check
  public void checkTechnologyUniqueness(final Microservice microservice) {
    final Function1<TechnologyReference, Import> _function = (TechnologyReference it) -> {
      return it.getTechnology();
    };
    final Function<Import, Import> _function_1 = (Import it) -> {
      return it;
    };
    final Integer duplicateIndex = LemmaUtils.<Import, Import>getDuplicateIndex(
      ListExtensions.<TechnologyReference, Import>map(microservice.getTechnologyReferences(), _function), _function_1);
    if (((duplicateIndex).intValue() > (-1))) {
      this.error("Duplicate technology assignment", 
        ServicePackage.Literals.MICROSERVICE__TECHNOLOGY_REFERENCES, (duplicateIndex).intValue());
    }
  }
  
  /**
   * Check that only one annotated technology contains type definitions
   */
  @Check
  public void checkUniqueTypeDefinitionTechnology(final Microservice microservice) {
    final Function1<TechnologyReference, Boolean> _function = (TechnologyReference it) -> {
      return Boolean.valueOf(it.isIsTypeDefinitionTechnology());
    };
    final Function<Boolean, Boolean> _function_1 = (Boolean it) -> {
      return it;
    };
    final Predicate<Boolean> _function_2 = (Boolean it) -> {
      return (it == Boolean.valueOf(true));
    };
    final Integer duplicateIndex = LemmaUtils.<Boolean, Boolean>getDuplicateIndex(
      ListExtensions.<TechnologyReference, Boolean>map(microservice.getTechnologyReferences(), _function), _function_1, _function_2);
    if (((duplicateIndex).intValue() > (-1))) {
      this.error("Only one technology can be the default type definition technology", 
        ServicePackage.Literals.MICROSERVICE__TECHNOLOGY_REFERENCES, (duplicateIndex).intValue());
      return;
    }
    final Function1<TechnologyReference, Boolean> _function_3 = (TechnologyReference it) -> {
      return Boolean.valueOf(it.isIsTypeDefinitionTechnology());
    };
    boolean _exists = IterableExtensions.<TechnologyReference>exists(microservice.getTechnologyReferences(), _function_3);
    if (_exists) {
      return;
    }
    final EList<TechnologyReference> typeDefinitionTechnologyReference = microservice.getAllTypeDefinitionTechnologyReferences();
    if ((typeDefinitionTechnologyReference.isEmpty() || (typeDefinitionTechnologyReference.size() == 1))) {
      return;
    }
    final Consumer<TechnologyReference> _function_4 = (TechnologyReference it) -> {
      this.error(("More than one type definition technology detected. You need to explicitly " + 
        "select one as the default type definition technology."), it, 
        ServicePackage.Literals.TECHNOLOGY_REFERENCE__TECHNOLOGY);
    };
    typeDefinitionTechnologyReference.forEach(_function_4);
  }
  
  /**
   * Check that annotated technologies define not only deployment-related concepts
   */
  @Check
  public void checkTechnologiesForServiceConcepts(final Microservice microservice) {
    int _size = microservice.getTechnologyReferences().size();
    ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, _size, true);
    for (final Integer i : _doubleDotLessThan) {
      {
        final Import technologyImport = microservice.getTechnologyReferences().get((i).intValue()).getTechnology();
        final Technology technologyModel = LemmaUtils.<Technology>getImportedModelRoot(technologyImport.eResource(), 
          technologyImport.getImportURI(), Technology.class);
        if (((technologyModel.getPrimitiveTypes().isEmpty() && 
          technologyModel.getProtocols().isEmpty()) && 
          technologyModel.getServiceAspects().isEmpty())) {
          this.error("Technology does not specify service-related concepts", 
            ServicePackage.Literals.MICROSERVICE__TECHNOLOGY_REFERENCES, (i).intValue());
        }
      }
    }
  }
  
  /**
   * Check that a microservice specifies protocols that match its operation parameters'
   * communication types
   */
  @Check
  public void checkEffectiveProtocols(final Microservice microservice) {
    boolean _isEmpty = microservice.getTechnologyReferences().isEmpty();
    if (_isEmpty) {
      return;
    }
    this.checkEffectiveProtocolsForCommunicationType(microservice, CommunicationType.ASYNCHRONOUS);
    this.checkEffectiveProtocolsForCommunicationType(microservice, CommunicationType.SYNCHRONOUS);
  }
  
  /**
   * Helper to check if a microservice specifies protocols for its operation parameters'
   * communication types
   */
  private void checkEffectiveProtocolsForCommunicationType(final Microservice microservice, final CommunicationType communicationType) {
    final Function1<ProtocolSpecification, Boolean> _function = (ProtocolSpecification it) -> {
      CommunicationType _communicationType = it.getCommunicationType();
      return Boolean.valueOf(Objects.equal(_communicationType, communicationType));
    };
    final ProtocolSpecification explicitProtocol = IterableExtensions.<ProtocolSpecification>findFirst(microservice.getProtocols(), _function);
    if ((explicitProtocol != null)) {
      return;
    }
    final Protocol implicitProtocol = this.getEffectiveDefaultProtocol(microservice, communicationType);
    if ((implicitProtocol != null)) {
      return;
    }
    boolean parameterForMissingProtocolExists = (IterableExtensions.<Operation>exists(microservice.getContainedOperations(), 
      ((Function1<Operation, Boolean>) (Operation it) -> {
        final Function1<Parameter, Boolean> _function_1 = (Parameter it_1) -> {
          CommunicationType _communicationType = it_1.getCommunicationType();
          return Boolean.valueOf(Objects.equal(_communicationType, communicationType));
        };
        return Boolean.valueOf(IterableExtensions.<Parameter>exists(it.getParameters(), _function_1));
      })) || 
      IterableExtensions.<ReferredOperation>exists(microservice.getContainedReferredOperations(), 
        ((Function1<ReferredOperation, Boolean>) (ReferredOperation it) -> {
          final Function1<Parameter, Boolean> _function_1 = (Parameter it_1) -> {
            CommunicationType _communicationType = it_1.getCommunicationType();
            return Boolean.valueOf(Objects.equal(_communicationType, communicationType));
          };
          return Boolean.valueOf(IterableExtensions.<Parameter>exists(it.getOperation().getParameters(), _function_1));
        })));
    if (parameterForMissingProtocolExists) {
      String _switchResult = null;
      if (communicationType != null) {
        switch (communicationType) {
          case SYNCHRONOUS:
            _switchResult = "synchronous";
            break;
          case ASYNCHRONOUS:
            _switchResult = "asynchronous";
            break;
          default:
            break;
        }
      }
      final String communicationTypeOutputString = _switchResult;
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Microservice does not specify ");
      _builder.append(communicationTypeOutputString);
      _builder.append(" protocol, ");
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("but its operations define ");
      _builder_1.append(communicationTypeOutputString);
      _builder_1.append(" parameters");
      String _plus = (_builder.toString() + _builder_1);
      this.error(_plus, microservice, ServicePackage.Literals.MICROSERVICE__NAME);
    }
  }
  
  /**
   * Helper to find the effective default protocol of a microservice
   */
  private Protocol getEffectiveDefaultProtocol(final Microservice microservice, final CommunicationType communicationType) {
    final Function1<TechnologyReference, Import> _function = (TechnologyReference it) -> {
      return it.getTechnology();
    };
    List<Import> _map = ListExtensions.<TechnologyReference, Import>map(microservice.getTechnologyReferences(), _function);
    for (final Import technologyImport : _map) {
      {
        final Technology technologyModel = LemmaUtils.<Technology>getImportedModelRoot(technologyImport.eResource(), 
          technologyImport.getImportURI(), Technology.class);
        final Function1<Protocol, Boolean> _function_1 = (Protocol it) -> {
          return Boolean.valueOf((it.isDefault() && (it.getCommunicationType() == communicationType)));
        };
        final Protocol defaultProtocolOfTechnology = IterableExtensions.<Protocol>findFirst(technologyModel.getProtocols(), _function_1);
        if ((defaultProtocolOfTechnology != null)) {
          return defaultProtocolOfTechnology;
        }
      }
    }
    return null;
  }
  
  /**
   * Check technologies of a microservice per communication type for unambiguous default protocols
   */
  @Check
  public void checkTechnologiesForUniqueDefaultProtocols(final Microservice microservice) {
    boolean _isEmpty = microservice.getTechnologyReferences().isEmpty();
    if (_isEmpty) {
      return;
    }
    final Function1<CommunicationType, Boolean> _function = (CommunicationType communicationType) -> {
      final Function1<ProtocolSpecification, Boolean> _function_1 = (ProtocolSpecification it) -> {
        CommunicationType _communicationType = it.getCommunicationType();
        return Boolean.valueOf((communicationType == _communicationType));
      };
      boolean _exists = IterableExtensions.<ProtocolSpecification>exists(microservice.getProtocols(), _function_1);
      return Boolean.valueOf((!_exists));
    };
    final Function1<CommunicationType, Boolean> _function_1 = (CommunicationType it) -> {
      boolean _isDefaultProtocolUnique = this.isDefaultProtocolUnique(microservice, it);
      return Boolean.valueOf((!_isDefaultProtocolUnique));
    };
    final Iterable<CommunicationType> nonUniqueCommunicationTypes = IterableExtensions.<CommunicationType>filter(IterableExtensions.<CommunicationType>filter(((Iterable<CommunicationType>)Conversions.doWrapArray(CommunicationType.values())), _function), _function_1);
    for (final CommunicationType communicationType : nonUniqueCommunicationTypes) {
      {
        String _switchResult = null;
        if (communicationType != null) {
          switch (communicationType) {
            case ASYNCHRONOUS:
              _switchResult = "asynchronous";
              break;
            case SYNCHRONOUS:
              _switchResult = "synchronous";
              break;
            default:
              break;
          }
        }
        final String typeString = _switchResult;
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Ambiguous default protocol for ");
        _builder.append(typeString);
        _builder.append(" communication. The ");
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("microservice needs to explicitly specify a protocol for ");
        _builder_1.append(typeString);
        _builder_1.append(" ");
        String _plus = (_builder.toString() + _builder_1);
        StringConcatenation _builder_2 = new StringConcatenation();
        _builder_2.append("communication.");
        String _plus_1 = (_plus + _builder_2);
        this.error(_plus_1, microservice, ServicePackage.Literals.MICROSERVICE__NAME);
      }
    }
  }
  
  /**
   * Helper to check if default protocol of a microservice is unique for a given communication
   * type
   */
  private boolean isDefaultProtocolUnique(final Microservice microservice, final CommunicationType communicationType) {
    boolean alreadyFoundDefaultProtocolForCommunicationType = false;
    final Function1<TechnologyReference, Import> _function = (TechnologyReference it) -> {
      return it.getTechnology();
    };
    List<Import> _map = ListExtensions.<TechnologyReference, Import>map(microservice.getTechnologyReferences(), _function);
    for (final Import technologyImport : _map) {
      {
        final Technology technologyModel = LemmaUtils.<Technology>getImportedModelRoot(technologyImport.eResource(), 
          technologyImport.getImportURI(), Technology.class);
        final Function1<Protocol, Boolean> _function_1 = (Protocol it) -> {
          return Boolean.valueOf((it.isDefault() && (it.getCommunicationType() == communicationType)));
        };
        final boolean hasDefaultProtocolForCommunicationType = IterableExtensions.<Protocol>exists(technologyModel.getProtocols(), _function_1);
        if (hasDefaultProtocolForCommunicationType) {
          if (alreadyFoundDefaultProtocolForCommunicationType) {
            return false;
          } else {
            alreadyFoundDefaultProtocolForCommunicationType = true;
          }
        }
      }
    }
    return true;
  }
  
  /**
   * Check that default type definition technology can be marked as such
   */
  @Check
  public void checkDefaultTypeDefinitionTechnology(final TechnologyReference technologyReference) {
    boolean _isIsTypeDefinitionTechnology = technologyReference.isIsTypeDefinitionTechnology();
    boolean _not = (!_isIsTypeDefinitionTechnology);
    if (_not) {
      return;
    }
    final Import importImport = technologyReference.getTechnology();
    final Technology technologyModel = LemmaUtils.<Technology>getImportedModelRoot(importImport.eResource(), 
      importImport.getImportURI(), Technology.class);
    final boolean technologyDefinesTypes = (((!technologyModel.getPrimitiveTypes().isEmpty()) || 
      (!technologyModel.getCollectionTypes().isEmpty())) || (!technologyModel.getDataStructures().isEmpty()));
    if ((!technologyDefinesTypes)) {
      this.error(("Technology does not specify types and cannot be marked as default type " + 
        "definition technology"), 
        ServicePackage.Literals.TECHNOLOGY_REFERENCE__IS_TYPE_DEFINITION_TECHNOLOGY);
    }
  }
  
  /**
   * Check that interfaces are not empty, i.e., that they define or refer to at least one
   * operation
   */
  @Check
  public void checkInterfaceNotEmpty(final Interface interface_) {
    final boolean definesOperations = ((interface_.getOperations() != null) && (!interface_.getOperations().isEmpty()));
    final boolean refersOperations = ((interface_.getReferredOperations() != null) && 
      (!interface_.getReferredOperations().isEmpty()));
    if (((!definesOperations) && (!refersOperations))) {
      this.error("Interface must define or refer to at least one operation", interface_, 
        ServicePackage.Literals.INTERFACE__NAME);
    }
  }
  
  /**
   * Check interface visibility
   */
  @Check
  public void checkVisibility(final Interface interface_) {
    boolean _or = false;
    Microservice _microservice = null;
    if (interface_!=null) {
      _microservice=interface_.getMicroservice();
    }
    boolean _tripleEquals = (_microservice == null);
    if (_tripleEquals) {
      _or = true;
    } else {
      Visibility _effectiveVisibility = interface_.getEffectiveVisibility();
      boolean _tripleNotEquals = (_effectiveVisibility != null);
      _or = _tripleNotEquals;
    }
    if (_or) {
      return;
    }
    String _name = interface_.getMicroservice().getEffectiveVisibility().name();
    String _lowerCase = null;
    if (_name!=null) {
      _lowerCase=_name.toLowerCase();
    }
    final String microserviceVisibility = _lowerCase;
    if ((microserviceVisibility == null)) {
      return;
    }
    String _name_1 = interface_.getVisibility().name();
    String _lowerCase_1 = null;
    if (_name_1!=null) {
      _lowerCase_1=_name_1.toLowerCase();
    }
    final String interfaceVisibility = _lowerCase_1;
    if ((interfaceVisibility == null)) {
      return;
    }
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("Interface visibility (");
    _builder.append(interfaceVisibility);
    _builder.append(") must not exceed the visibility ");
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("of its defining microservice (");
    _builder_1.append(microserviceVisibility);
    _builder_1.append(")");
    String _plus = (_builder.toString() + _builder_1);
    this.error(_plus, interface_, 
      ServicePackage.Literals.INTERFACE__VISIBILITY);
  }
  
  /**
   * Warn, if a required interface is already marked as being required by its containing
   * microservice
   */
  @Check
  public void warnAlreadyRequired(final PossiblyImportedInterface importedInterface) {
    if ((importedInterface.isRequired() && importedInterface.isRequiredByContainer())) {
      final QualifiedName containingMicroserviceName = this.nameProvider.qualifiedName(importedInterface.getInterface().getMicroservice());
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Interface is already required, because its microservice ");
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append(containingMicroserviceName);
      _builder_1.append("  is required");
      String _plus = (_builder.toString() + _builder_1);
      this.warning(_plus, importedInterface, 
        ServicePackage.Literals.POSSIBLY_IMPORTED_INTERFACE__INTERFACE);
    }
  }
  
  /**
   * Warn, if a required interface does not define any implemented methods
   */
  @Check
  public void warnNoImplementedOperations(final PossiblyImportedInterface importedInterface) {
    if ((importedInterface.isRequired() && (!importedInterface.getInterface().isEffectivelyImplemented()))) {
      this.warning("Interface does not define any implemented operation ", importedInterface, 
        ServicePackage.Literals.POSSIBLY_IMPORTED_INTERFACE__INTERFACE);
    }
  }
  
  /**
   * Warn, if a required microservice does not define any implemented methods
   */
  @Check
  public void warnNoImplementedOperations(final PossiblyImportedMicroservice importedMicroservice) {
    boolean _isEffectivelyImplemented = importedMicroservice.getMicroservice().isEffectivelyImplemented();
    boolean _not = (!_isEffectivelyImplemented);
    if (_not) {
      this.warning("Microservice does not define any implemented operation ", importedMicroservice, 
        ServicePackage.Literals.POSSIBLY_IMPORTED_MICROSERVICE__MICROSERVICE);
    }
  }
  
  /**
   * Check operation visibility
   */
  @Check
  public void checkVisibility(final Operation operation) {
    boolean _or = false;
    Interface _interface = null;
    if (operation!=null) {
      _interface=operation.getInterface();
    }
    boolean _tripleEquals = (_interface == null);
    if (_tripleEquals) {
      _or = true;
    } else {
      Visibility _effectiveVisibility = operation.getEffectiveVisibility();
      boolean _tripleNotEquals = (_effectiveVisibility != null);
      _or = _tripleNotEquals;
    }
    if (_or) {
      return;
    }
    String _name = operation.getInterface().getEffectiveVisibility().name();
    String _lowerCase = null;
    if (_name!=null) {
      _lowerCase=_name.toLowerCase();
    }
    final String interfaceVisibility = _lowerCase;
    if ((interfaceVisibility == null)) {
      return;
    }
    String _name_1 = operation.getVisibility().name();
    String _lowerCase_1 = null;
    if (_name_1!=null) {
      _lowerCase_1=_name_1.toLowerCase();
    }
    final String operationVisibility = _lowerCase_1;
    if ((operationVisibility == null)) {
      return;
    }
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("Operation visibility (");
    _builder.append(operationVisibility);
    _builder.append(") must not exceed the visibility ");
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("of its defining interface (");
    _builder_1.append(interfaceVisibility);
    _builder_1.append(")");
    String _plus = (_builder.toString() + _builder_1);
    this.error(_plus, operation, 
      ServicePackage.Literals.OPERATION__VISIBILITY);
  }
  
  /**
   * Warn, if the interface of an operation, that is marked as being not implemented, is also
   * marked as being not implemented. That is, the operation is already implicitly marked as being
   * not implemented by its containing interface.
   */
  @Check
  public void warnAlreadyNotImplemented(final Operation operation) {
    if ((operation.isNotImplemented() && operation.isNotImplementedByContainer())) {
      final String containingInterfaceName = operation.getInterface().getName();
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Operation is already marked as being not implemented, because ");
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("its interface ");
      _builder_1.append(containingInterfaceName);
      _builder_1.append(" is marked as being not implemented");
      String _plus = (_builder.toString() + _builder_1);
      this.warning(_plus, operation, ServicePackage.Literals.OPERATION__NOT_IMPLEMENTED);
    }
  }
  
  /**
   * Warn, if an internal operation is already implicitly internal because its containing
   * interface is internal
   */
  @Check
  public void warnAlreadyInternal(final Operation operation) {
    if (((operation.getVisibility() == Visibility.INTERNAL) && 
      operation.getInterface().isEffectivelyInternal())) {
      final String interfaceName = operation.getInterface().getName();
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Operation is already implicitly internal, because its interface ");
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append(interfaceName);
      _builder_1.append(" is effectively internal");
      String _plus = (_builder.toString() + _builder_1);
      this.warning(_plus, operation, 
        ServicePackage.Literals.OPERATION__VISIBILITY);
    }
  }
  
  /**
   * Warn, if a required operation is already required because its containing interface or
   * microservice are required
   */
  @Check
  public void warnAlreadyRequired(final PossiblyImportedOperation importedOperation) {
    if (((!importedOperation.isRequired()) || (!importedOperation.isRequiredByContainer()))) {
      return;
    }
    final boolean isInterfaceRequired = importedOperation.isRequiredByInterface();
    final boolean isServiceRequired = importedOperation.isRequiredByMicroservice();
    final Operation operation = importedOperation.getOperation();
    if ((isInterfaceRequired && isServiceRequired)) {
      final String interfaceName = operation.getInterface().getName();
      final String serviceName = operation.getInterface().getMicroservice().getName();
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Operation is already implicitly required, because both its interface ");
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append(interfaceName);
      _builder_1.append(" and microservice ");
      _builder_1.append(serviceName);
      _builder_1.append(" are required");
      String _plus = (_builder.toString() + _builder_1);
      this.warning(_plus, importedOperation, 
        ServicePackage.Literals.POSSIBLY_IMPORTED_OPERATION__REQUIRED_BY_CONTAINER);
    } else {
      if (isInterfaceRequired) {
        final String interfaceName_1 = operation.getInterface().getName();
        StringConcatenation _builder_2 = new StringConcatenation();
        _builder_2.append("Operation is already implicitly required, because its interface ");
        StringConcatenation _builder_3 = new StringConcatenation();
        _builder_3.append(interfaceName_1);
        _builder_3.append(" is required");
        String _plus_1 = (_builder_2.toString() + _builder_3);
        this.warning(_plus_1, importedOperation, 
          ServicePackage.Literals.POSSIBLY_IMPORTED_OPERATION__REQUIRED_BY_INTERFACE);
      } else {
        if (isServiceRequired) {
          final String serviceName_1 = operation.getInterface().getMicroservice().getName();
          StringConcatenation _builder_4 = new StringConcatenation();
          _builder_4.append("Operation is already implicitly required, because its microservice ");
          StringConcatenation _builder_5 = new StringConcatenation();
          _builder_5.append(serviceName_1);
          _builder_5.append(" is required");
          String _plus_2 = (_builder_4.toString() + _builder_5);
          this.warning(_plus_2, importedOperation, 
            ServicePackage.Literals.POSSIBLY_IMPORTED_OPERATION__REQUIRED_BY_MICROSERVICE);
        }
      }
    }
  }
  
  /**
   * Check that there is at most one protocol per communication type annotated on microservices,
   * interfaces, operations, or referred operations
   */
  @Check
  public void checkProtocolCommunicationType(final ProtocolSpecification protocolSpecification) {
    EList<ProtocolSpecification> _switchResult = null;
    EObject _eContainer = protocolSpecification.eContainer();
    boolean _matched = false;
    if (_eContainer instanceof Microservice) {
      _matched=true;
      EObject _eContainer_1 = protocolSpecification.eContainer();
      _switchResult = ((Microservice) _eContainer_1).getProtocols();
    }
    if (!_matched) {
      if (_eContainer instanceof Interface) {
        _matched=true;
        EObject _eContainer_1 = protocolSpecification.eContainer();
        _switchResult = ((Interface) _eContainer_1).getProtocols();
      }
    }
    if (!_matched) {
      if (_eContainer instanceof Operation) {
        _matched=true;
        EObject _eContainer_1 = protocolSpecification.eContainer();
        _switchResult = ((Operation) _eContainer_1).getProtocols();
      }
    }
    if (!_matched) {
      if (_eContainer instanceof ReferredOperation) {
        _matched=true;
        EObject _eContainer_1 = protocolSpecification.eContainer();
        _switchResult = ((ReferredOperation) _eContainer_1).getProtocols();
      }
    }
    if (!_matched) {
      _switchResult = null;
    }
    final EList<ProtocolSpecification> protocols = _switchResult;
    if (((protocols == null) || protocols.isEmpty())) {
      return;
    }
    String _switchResult_1 = null;
    EObject _eContainer_1 = protocolSpecification.eContainer();
    boolean _matched_1 = false;
    if (_eContainer_1 instanceof Microservice) {
      _matched_1=true;
      _switchResult_1 = "microservice";
    }
    if (!_matched_1) {
      if (_eContainer_1 instanceof Interface) {
        _matched_1=true;
        _switchResult_1 = "interface";
      }
    }
    if (!_matched_1) {
      if (_eContainer_1 instanceof Operation) {
        _matched_1=true;
      }
      if (!_matched_1) {
        if (_eContainer_1 instanceof ReferredOperation) {
          _matched_1=true;
        }
      }
      if (_matched_1) {
        _switchResult_1 = "operation";
      }
    }
    final String containerName = _switchResult_1;
    ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, 2, true);
    for (final int i : _doubleDotLessThan) {
      {
        CommunicationType _switchResult_2 = null;
        switch (i) {
          case 0:
            _switchResult_2 = CommunicationType.SYNCHRONOUS;
            break;
          case 1:
            _switchResult_2 = CommunicationType.ASYNCHRONOUS;
            break;
        }
        final CommunicationType communicationType = _switchResult_2;
        String _switchResult_3 = null;
        if (communicationType != null) {
          switch (communicationType) {
            case SYNCHRONOUS:
              _switchResult_3 = "synchronous";
              break;
            case ASYNCHRONOUS:
              _switchResult_3 = "asynchronous";
              break;
            default:
              break;
          }
        }
        final String communicationTypeName = _switchResult_3;
        final Function1<ProtocolSpecification, Boolean> _function = (ProtocolSpecification it) -> {
          CommunicationType _communicationType = it.getCommunicationType();
          return Boolean.valueOf(Objects.equal(communicationType, _communicationType));
        };
        final Iterable<ProtocolSpecification> protocolsOfType = IterableExtensions.<ProtocolSpecification>filter(protocols, _function);
        int _size = IterableExtensions.size(protocolsOfType);
        boolean _greaterThan = (_size > 1);
        if (_greaterThan) {
          StringConcatenation _builder = new StringConcatenation();
          _builder.append("There must not be more than one ");
          _builder.append(communicationTypeName);
          _builder.append(" protocol for ");
          StringConcatenation _builder_1 = new StringConcatenation();
          _builder_1.append("the ");
          _builder_1.append(containerName);
          String _plus = (_builder.toString() + _builder_1);
          this.error(_plus, ((EObject[])Conversions.unwrapArray(protocolsOfType, EObject.class))[1], 
            ServicePackage.Literals.PROTOCOL_SPECIFICATION__COMMUNICATION_TYPE);
        }
      }
    }
  }
  
  /**
   * The unspecified primitive type is forbidden for parameters
   */
  @Check
  public void checkParameterType(final Parameter parameter) {
    Type _effectiveType = parameter.getEffectiveType();
    final boolean hasUnspecifiedType = (_effectiveType instanceof PrimitiveUnspecified);
    boolean _isEffectivelyNotImplemented = parameter.getOperation().isEffectivelyNotImplemented();
    final boolean operationIsImplemented = (!_isEffectivelyNotImplemented);
    if (((!hasUnspecifiedType) || (!operationIsImplemented))) {
      return;
    }
    this.error("Type unspecified is only allowed in combination with noimpl modifier", parameter, 
      ServicePackage.Literals.PARAMETER__PRIMITIVE_TYPE);
  }
  
  /**
   * Warn if initializing operation's parameters' output communication types do not match
   * initialized parameter's communication type
   */
  @Check
  public void warnCommunicationTypesNotMatching(final Parameter parameter) {
    PossiblyImportedOperation _initializedByOperation = parameter.getInitializedByOperation();
    boolean _tripleEquals = (_initializedByOperation == null);
    if (_tripleEquals) {
      return;
    }
    final Operation initializingOperation = parameter.getInitializedByOperation().getOperation();
    final Function1<Parameter, Boolean> _function = (Parameter it) -> {
      ExchangePattern _exchangePattern = it.getExchangePattern();
      return Boolean.valueOf((_exchangePattern == ExchangePattern.OUT));
    };
    final Function1<Parameter, Boolean> _function_1 = (Parameter it) -> {
      CommunicationType _communicationType = it.getCommunicationType();
      CommunicationType _communicationType_1 = parameter.getCommunicationType();
      return Boolean.valueOf((_communicationType == _communicationType_1));
    };
    final boolean existsOutParameterOfSameCommunicationType = IterableExtensions.<Parameter>exists(IterableExtensions.<Parameter>filter(initializingOperation.getParameters(), _function), _function_1);
    if ((!existsOutParameterOfSameCommunicationType)) {
      String _switchResult = null;
      CommunicationType _communicationType = parameter.getCommunicationType();
      if (_communicationType != null) {
        switch (_communicationType) {
          case ASYNCHRONOUS:
            _switchResult = "asynchronous";
            break;
          case SYNCHRONOUS:
            _switchResult = "synchronous";
            break;
          default:
            break;
        }
      }
      final String communicationTypeName = _switchResult;
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Operation does not have any outgoing parameters with communication type ");
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append(communicationTypeName);
      String _plus = (_builder.toString() + _builder_1);
      this.warning(_plus, parameter, 
        ServicePackage.Literals.PARAMETER__INITIALIZED_BY_OPERATION);
    }
  }
  
  /**
   * Warn if an API parameter has already been commented
   */
  @Check
  public void warnDuplicateParameterComments(final ApiOperationComment operationComment) {
    final EList<ApiParameterComment> parameterComments = operationComment.getParameterComments();
    if (((parameterComments == null) || parameterComments.isEmpty())) {
      return;
    }
    final Function<ApiParameterComment, Parameter> _function = (ApiParameterComment it) -> {
      return it.getParameter();
    };
    final Integer duplicateIndex = LemmaUtils.<ApiParameterComment, Parameter>getDuplicateIndex(parameterComments, _function);
    if (((duplicateIndex).intValue() > (-1))) {
      final ApiParameterComment duplicateComment = parameterComments.get((duplicateIndex).intValue());
      this.warning("Parameter has already been commented", duplicateComment, 
        ServicePackage.Literals.API_PARAMETER_COMMENT__PARAMETER);
    }
  }
  
  /**
   * Warn if an incoming API parameter has not been commented yet
   */
  @Check
  public void warnMissingParameterComments(final ApiOperationComment operationComment) {
    Operation _operation = operationComment.getOperation();
    EList<Parameter> _parameters = null;
    if (_operation!=null) {
      _parameters=_operation.getParameters();
    }
    Iterable<Parameter> _filter = null;
    if (_parameters!=null) {
      final Function1<Parameter, Boolean> _function = (Parameter it) -> {
        return Boolean.valueOf(((it.getExchangePattern() == ExchangePattern.IN) || 
          (it.getExchangePattern() == ExchangePattern.INOUT)));
      };
      _filter=IterableExtensions.<Parameter>filter(_parameters, _function);
    }
    final Iterable<Parameter> allIncomingParameters = _filter;
    if ((allIncomingParameters == null)) {
      return;
    }
    final Function1<Parameter, Boolean> _function_1 = (Parameter incomingParameter) -> {
      final Function1<ApiParameterComment, Boolean> _function_2 = (ApiParameterComment it) -> {
        Parameter _parameter = it.getParameter();
        return Boolean.valueOf(Objects.equal(_parameter, incomingParameter));
      };
      boolean _exists = IterableExtensions.<ApiParameterComment>exists(operationComment.getParameterComments(), _function_2);
      return Boolean.valueOf((!_exists));
    };
    final Parameter missingParameter = IterableExtensions.<Parameter>findFirst(allIncomingParameters, _function_1);
    if ((missingParameter != null)) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Incoming parameter ");
      String _name = missingParameter.getName();
      _builder.append(_name);
      _builder.append(" has not been commented yet");
      this.warning(_builder.toString(), 
        ServicePackage.Literals.API_OPERATION_COMMENT__COMMENT);
    }
  }
  
  /**
   * Warn if an API parameter has been commented as being required/not required when it is modeled
   * as being optional/not optional
   */
  @Check
  public void warnParameterCommentDiffersFromOptionalFlag(final ApiParameterComment parameterComment) {
    Parameter _parameter = parameterComment.getParameter();
    boolean _tripleEquals = (_parameter == null);
    if (_tripleEquals) {
      return;
    }
    boolean _isRequired = parameterComment.isRequired();
    boolean _isOptional = parameterComment.getParameter().isOptional();
    boolean _not = (!_isOptional);
    boolean _tripleNotEquals = (Boolean.valueOf(_isRequired) != Boolean.valueOf(_not));
    if (_tripleNotEquals) {
      String _xifexpression = null;
      boolean _isRequired_1 = parameterComment.isRequired();
      boolean _not_1 = (!_isRequired_1);
      if (_not_1) {
        _xifexpression = " not ";
      } else {
        _xifexpression = " ";
      }
      final String commentIsRequiredString = _xifexpression;
      String _xifexpression_1 = null;
      boolean _isOptional_1 = parameterComment.getParameter().isOptional();
      boolean _not_2 = (!_isOptional_1);
      if (_not_2) {
        _xifexpression_1 = " ";
      } else {
        _xifexpression_1 = " not ";
      }
      final String parameterIsRequiredString = _xifexpression_1;
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Parameter has been documented as being");
      _builder.append(commentIsRequiredString);
      _builder.append("required,");
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append(" ");
      _builder_1.append("but is modeled as being");
      _builder_1.append(parameterIsRequiredString, " ");
      _builder_1.append("required");
      String _plus = (_builder.toString() + _builder_1);
      this.warning(_plus, 
        ServicePackage.Literals.API_PARAMETER_COMMENT__PARAMETER);
    }
  }
  
  /**
   * Check type compatibility of parameter and initializing operation, and warn if incompatible
   */
  @Check
  public void warnParameterInitializingTypeCompatibility(final PossiblyImportedOperation importedOperation) {
    final Operation operation = importedOperation.getOperation();
    EObject _eContainer = operation.eContainer();
    boolean _tripleEquals = (_eContainer == null);
    if (_tripleEquals) {
      return;
    }
    final Parameter initializedParameter = importedOperation.getInitializedParameter();
    if ((initializedParameter == null)) {
      return;
    }
    ExchangePattern _exchangePattern = initializedParameter.getExchangePattern();
    boolean _tripleEquals_1 = (_exchangePattern == ExchangePattern.OUT);
    if (_tripleEquals_1) {
      this.error("Outgoing parameters may not be initialized", initializedParameter, 
        ServicePackage.Literals.PARAMETER__EXCHANGE_PATTERN);
      return;
    }
    final Type parameterType = initializedParameter.getEffectiveType();
    if ((parameterType == null)) {
      return;
    }
    final Function1<Parameter, Boolean> _function = (Parameter it) -> {
      return Boolean.valueOf(((Objects.equal(it.getExchangePattern(), ExchangePattern.OUT) || Objects.equal(it.getExchangePattern(), ExchangePattern.INOUT)) && 
        Objects.equal(it.getEffectiveType(), parameterType)));
    };
    final boolean existsSameOutputType = IterableExtensions.<Parameter>exists(operation.getParameters(), _function);
    if (existsSameOutputType) {
      return;
    }
    boolean _warnParameterLacksPrimitiveType = this.warnParameterLacksPrimitiveType(initializedParameter);
    if (_warnParameterLacksPrimitiveType) {
      return;
    }
    final Function1<Parameter, Boolean> _function_1 = (Parameter it) -> {
      return Boolean.valueOf((((it.getEffectiveType() != null) && 
        (it.getCommunicationType() == initializedParameter.getCommunicationType())) && 
        ((it.getExchangePattern() == ExchangePattern.OUT) || 
          (it.getExchangePattern() == ExchangePattern.INOUT))));
    };
    final Function1<Parameter, Type> _function_2 = (Parameter it) -> {
      return it.getEffectiveType();
    };
    final Iterable<Type> outputTypesOfParametersCommunicationType = IterableExtensions.<Parameter, Type>map(IterableExtensions.<Parameter>filter(operation.getParameters(), _function_1), _function_2);
    boolean _isEmpty = IterableExtensions.isEmpty(outputTypesOfParametersCommunicationType);
    if (_isEmpty) {
      return;
    }
    this.warnInitializingTypeCompatibility(importedOperation, outputTypesOfParametersCommunicationType, parameterType);
  }
  
  /**
   * Helper method to determine if a technology-specific primitive type lacks underlying
   * built-in primitive types
   */
  private boolean warnParameterLacksPrimitiveType(final Parameter initializedParameter) {
    final Type parameterType = initializedParameter.getEffectiveType();
    if ((!(parameterType instanceof TechnologySpecificPrimitiveType))) {
      return false;
    }
    final TechnologySpecificPrimitiveType technologySpecificType = ((TechnologySpecificPrimitiveType) parameterType);
    boolean _isEmpty = technologySpecificType.getBasicBuiltinPrimitiveTypes().isEmpty();
    boolean _not = (!_isEmpty);
    if (_not) {
      return false;
    }
    final StringBuilder qualifiedTypeName = new StringBuilder();
    qualifiedTypeName.append(technologySpecificType.getTechnology().getName());
    qualifiedTypeName.append("::");
    qualifiedTypeName.append(QualifiedName.create(technologySpecificType.getQualifiedNameParts()));
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("Technology-specific primitive type ");
    _builder.append(qualifiedTypeName);
    _builder.append(" of parameter ");
    StringConcatenation _builder_1 = new StringConcatenation();
    String _name = initializedParameter.getName();
    _builder_1.append(_name);
    _builder_1.append(" has no basic type. To initialize the parameter, an ");
    String _plus = (_builder.toString() + _builder_1);
    StringConcatenation _builder_2 = new StringConcatenation();
    _builder_2.append("additional type conversion would need to be implemented.");
    String _plus_1 = (_plus + _builder_2);
    this.warning(_plus_1, initializedParameter, 
      ServicePackage.Literals.PARAMETER__INITIALIZED_BY_OPERATION);
    return true;
  }
  
  /**
   * Helper method to perform full type checks of a parameter and its initializing operation
   */
  private void warnInitializingTypeCompatibility(final PossiblyImportedOperation importedOperation, final Iterable<Type> outputTypes, final Type parameterType) {
    final TypeChecker typeChecker = new TypeChecker();
    boolean compatibleOutTypeFound = false;
    int i = 0;
    while (((i < IterableExtensions.size(outputTypes)) && (!compatibleOutTypeFound))) {
      {
        final Type outputType = ((Type[])Conversions.unwrapArray(outputTypes, Type.class))[i];
        try {
          typeChecker.checkTypeCompatibility(parameterType, outputType);
          compatibleOutTypeFound = true;
        } catch (final Throwable _t) {
          if (_t instanceof TypesNotCompatibleException) {
            i++;
          } else {
            throw Exceptions.sneakyThrow(_t);
          }
        }
      }
    }
    if (compatibleOutTypeFound) {
      return;
    }
    final Parameter initializedParameter = importedOperation.getInitializedParameter();
    String typeName = QualifiedName.create(initializedParameter.getEffectiveTypeQualifiedNameParts()).toString();
    if ((parameterType instanceof TechnologySpecificPrimitiveType)) {
      String _name = ((TechnologySpecificPrimitiveType)parameterType).getTechnology().getName();
      String _plus = (_name + "::");
      String _plus_1 = (_plus + typeName);
      typeName = _plus_1;
    }
    String _switchResult = null;
    CommunicationType _communicationType = initializedParameter.getCommunicationType();
    if (_communicationType != null) {
      switch (_communicationType) {
        case ASYNCHRONOUS:
          _switchResult = "asynchronous";
          break;
        case SYNCHRONOUS:
          _switchResult = "synchronous";
          break;
        default:
          break;
      }
    }
    final String communicationTypeName = _switchResult;
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("Types of output parameters with communication type ");
    _builder.append(communicationTypeName);
    _builder.append(" ");
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("are not directly compatible with type ");
    _builder_1.append(typeName);
    _builder_1.append(" of parameter ");
    String _plus_2 = (_builder.toString() + _builder_1);
    StringConcatenation _builder_2 = new StringConcatenation();
    String _name_1 = initializedParameter.getName();
    _builder_2.append(_name_1);
    _builder_2.append(".");
    String _plus_3 = (_plus_2 + _builder_2);
    this.warning(_plus_3, importedOperation, 
      ServicePackage.Literals.POSSIBLY_IMPORTED_OPERATION__OPERATION);
  }
  
  /**
   * Check unique endpoints on microservice
   */
  @Check
  public void checkUniqueEndpoints(final Microservice microservice) {
    this.checkUniqueEndpoints(microservice.getEndpoints());
  }
  
  /**
   * Check unique endpoints on interface
   */
  @Check
  public void checkUniqueEndpoints(final Interface interface_) {
    this.checkUniqueEndpoints(interface_.getEndpoints());
  }
  
  /**
   * Check unique endpoints on operation
   */
  @Check
  public void checkUniqueEndpoints(final Operation operation) {
    this.checkUniqueEndpoints(operation.getEndpoints());
  }
  
  /**
   * Check uniqueness of an endpoint's addresses
   */
  @Check
  public void checkUniqueEndpointAddresses(final Endpoint endpoint) {
    final Function<String, String> _function = (String it) -> {
      return it;
    };
    final Integer duplicateIndex = LemmaUtils.<String, String>getDuplicateIndex(endpoint.getAddresses(), _function);
    if (((duplicateIndex).intValue() > (-1))) {
      final String duplicate = endpoint.getAddresses().get((duplicateIndex).intValue());
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Duplicate address ");
      _builder.append(duplicate);
      this.error(_builder.toString(), endpoint, 
        ServicePackage.Literals.ENDPOINT__ADDRESSES, (duplicateIndex).intValue());
    }
  }
  
  /**
   * Check uniqueness of aspects
   */
  @Check
  public void checkUniqueAspects(final ImportedServiceAspect aspect) {
    boolean _isIsSingleValued = aspect.getImportedAspect().isIsSingleValued();
    boolean _not = (!_isIsSingleValued);
    if (_not) {
      return;
    }
    final Function1<ImportedServiceAspect, Boolean> _function = (ImportedServiceAspect it) -> {
      return Boolean.valueOf(((!Objects.equal(it, aspect)) && 
        Objects.equal(it.getImportedAspect().getName(), aspect.getImportedAspect().getName())));
    };
    final Iterable<ImportedServiceAspect> eponymousAspectsOfContainer = IterableExtensions.<ImportedServiceAspect>filter(EcoreUtil2.<ImportedServiceAspect>getSiblingsOfType(aspect, 
      ImportedServiceAspect.class), _function);
    boolean _isEmpty = IterableExtensions.isEmpty(eponymousAspectsOfContainer);
    boolean _not_1 = (!_isEmpty);
    if (_not_1) {
      final ImportedServiceAspect duplicateAspect = ((ImportedServiceAspect[])Conversions.unwrapArray(eponymousAspectsOfContainer, ImportedServiceAspect.class))[0];
      this.error("Aspect may be specified at most once", duplicateAspect, 
        ServicePackage.Literals.IMPORTED_SERVICE_ASPECT__IMPORTED_ASPECT);
    }
  }
  
  /**
   * Check that aspect has only one property, if only a single value is specified, and that the
   * specified value matches the property's type
   */
  @Check
  public void checkSingleAspectProperty(final ImportedServiceAspect importedAspect) {
    final PrimitiveValue propertyValue = importedAspect.getSinglePropertyValue();
    if ((propertyValue == null)) {
      return;
    }
    final int propertyCount = importedAspect.getImportedAspect().getProperties().size();
    if ((propertyCount == 0)) {
      this.error("Aspect does not define properties", importedAspect, 
        ServicePackage.Literals.IMPORTED_SERVICE_ASPECT__SINGLE_PROPERTY_VALUE);
    } else {
      if ((propertyCount > 1)) {
        this.error("Ambiguous value assignment", importedAspect, 
          ServicePackage.Literals.IMPORTED_SERVICE_ASPECT__SINGLE_PROPERTY_VALUE);
      } else {
        if ((propertyCount == 1)) {
          final TechnologySpecificProperty targetProperty = importedAspect.getImportedAspect().getProperties().get(0);
          final PrimitiveType targetPropertyType = targetProperty.getType();
          boolean _isOfType = propertyValue.isOfType(targetPropertyType);
          boolean _not = (!_isOfType);
          if (_not) {
            StringConcatenation _builder = new StringConcatenation();
            _builder.append("Value is not of type ");
            String _typeName = targetPropertyType.getTypeName();
            _builder.append(_typeName);
            _builder.append(" as expected by ");
            StringConcatenation _builder_1 = new StringConcatenation();
            _builder_1.append("property ");
            String _name = targetProperty.getName();
            _builder_1.append(_name);
            String _plus = (_builder.toString() + _builder_1);
            this.error(_plus, importedAspect, 
              ServicePackage.Literals.IMPORTED_SERVICE_ASPECT__SINGLE_PROPERTY_VALUE);
          }
        }
      }
    }
  }
  
  /**
   * Check uniqueness of aspect properties in value assignments
   */
  @Check
  public void checkUniqueValueAssignments(final ImportedServiceAspect aspect) {
    if ((aspect.getValues().isEmpty() || (aspect.getImportedAspect().getProperties().size() <= 1))) {
      return;
    }
    final Function<TechnologySpecificPropertyValueAssignment, String> _function = (TechnologySpecificPropertyValueAssignment it) -> {
      return it.getProperty().getName();
    };
    final Integer duplicateIndex = LemmaUtils.<TechnologySpecificPropertyValueAssignment, String>getDuplicateIndex(aspect.getValues(), _function);
    if (((duplicateIndex).intValue() > (-1))) {
      this.error("Duplicate value assignment to property", 
        ServicePackage.Literals.IMPORTED_SERVICE_ASPECT__VALUES, (duplicateIndex).intValue());
    }
  }
  
  /**
   * Check that mandatory properties of aspects have values
   */
  @Check
  public void checkMandatoryAspectProperties(final ImportedServiceAspect importedAspect) {
    final ServiceAspect aspect = importedAspect.getImportedAspect();
    final EList<TechnologySpecificProperty> aspectProperties = aspect.getProperties();
    final Function1<TechnologySpecificProperty, Boolean> _function = (TechnologySpecificProperty it) -> {
      return Boolean.valueOf(it.isIsMandatory());
    };
    final Iterable<TechnologySpecificProperty> mandatoryProperties = IterableExtensions.<TechnologySpecificProperty>filter(aspectProperties, _function);
    final Function1<TechnologySpecificProperty, Boolean> _function_1 = (TechnologySpecificProperty it) -> {
      final Function1<TechnologySpecificPropertyValueAssignment, TechnologySpecificProperty> _function_2 = (TechnologySpecificPropertyValueAssignment it_1) -> {
        return it_1.getProperty();
      };
      boolean _contains = ListExtensions.<TechnologySpecificPropertyValueAssignment, TechnologySpecificProperty>map(importedAspect.getValues(), _function_2).contains(it);
      return Boolean.valueOf((!_contains));
    };
    final Iterable<TechnologySpecificProperty> mandatoryPropertiesWithoutValues = IterableExtensions.<TechnologySpecificProperty>filter(mandatoryProperties, _function_1);
    final boolean allMandatoryPropertiesHaveValues = IterableExtensions.isEmpty(mandatoryPropertiesWithoutValues);
    final boolean aspectHasExactlyOneMandatoryProperty = ((aspectProperties.size() == 1) && 
      (!IterableExtensions.isEmpty(mandatoryProperties)));
    if (aspectHasExactlyOneMandatoryProperty) {
      if (((importedAspect.getSinglePropertyValue() == null) && (!allMandatoryPropertiesHaveValues))) {
        final TechnologySpecificProperty mandatoryProperty = ((TechnologySpecificProperty[])Conversions.unwrapArray(mandatoryProperties, TechnologySpecificProperty.class))[0];
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Mandatory property ");
        String _name = mandatoryProperty.getName();
        _builder.append(_name);
        _builder.append(" does not have value");
        this.error(_builder.toString(), importedAspect, 
          ServicePackage.Literals.IMPORTED_SERVICE_ASPECT__IMPORTED_ASPECT);
      }
    } else {
      if ((!allMandatoryPropertiesHaveValues)) {
        final Consumer<TechnologySpecificProperty> _function_2 = (TechnologySpecificProperty it) -> {
          StringConcatenation _builder_1 = new StringConcatenation();
          _builder_1.append("Mandatory property ");
          String _name_1 = it.getName();
          _builder_1.append(_name_1);
          _builder_1.append(" does not have value");
          this.error(_builder_1.toString(), importedAspect, 
            ServicePackage.Literals.IMPORTED_SERVICE_ASPECT__IMPORTED_ASPECT);
        };
        mandatoryPropertiesWithoutValues.forEach(_function_2);
      }
    }
  }
  
  /**
   * Check that the assigned value of a service aspect property matches its type
   */
  @Check
  public void checkPropertyValueType(final TechnologySpecificPropertyValueAssignment propertyValue) {
    if (((propertyValue.getProperty() == null) || (propertyValue.getValue() == null))) {
      return;
    }
    final TechnologySpecificProperty serviceProperty = propertyValue.getProperty();
    final PrimitiveType servicePropertyType = serviceProperty.getType();
    boolean _isOfType = propertyValue.getValue().isOfType(servicePropertyType);
    boolean _not = (!_isOfType);
    if (_not) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Value is not of type ");
      String _typeName = servicePropertyType.getTypeName();
      _builder.append(_typeName);
      _builder.append(" ");
      this.error(_builder.toString(), propertyValue, 
        TechnologyPackage.Literals.TECHNOLOGY_SPECIFIC_PROPERTY_VALUE_ASSIGNMENT__VALUE);
    }
  }
  
  /**
   * Convenience method to check endpoint uniqueness in a list of endpoints
   */
  private void checkUniqueEndpoints(final List<Endpoint> endpoints) {
    final HashSet<String> protocolSet = CollectionLiterals.<String>newHashSet();
    final Consumer<Endpoint> _function = (Endpoint endpoint) -> {
      int _size = endpoint.getProtocols().size();
      ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, _size, true);
      for (final Integer i : _doubleDotLessThan) {
        {
          final ImportedProtocolAndDataFormat protocol = endpoint.getProtocols().get((i).intValue());
          String _name = protocol.getImport().getName();
          String _plus = (_name + "::");
          String _name_1 = protocol.getImportedProtocol().getName();
          String protocolId = (_plus + _name_1);
          DataFormat _dataFormat = protocol.getDataFormat();
          boolean _tripleNotEquals = (_dataFormat != null);
          if (_tripleNotEquals) {
            String _protocolId = protocolId;
            StringConcatenation _builder = new StringConcatenation();
            _builder.append("(");
            String _formatName = protocol.getDataFormat().getFormatName();
            _builder.append(_formatName);
            _builder.append(")");
            protocolId = (_protocolId + _builder);
          } else {
            String _protocolId_1 = protocolId;
            StringConcatenation _builder_1 = new StringConcatenation();
            _builder_1.append("(");
            String _formatName_1 = protocol.getImportedProtocol().getDefaultFormat().getFormatName();
            _builder_1.append(_formatName_1);
            _builder_1.append(")");
            protocolId = (_protocolId_1 + _builder_1);
          }
          boolean _add = protocolSet.add(protocolId);
          final boolean isDuplicate = (!_add);
          if (isDuplicate) {
            StringConcatenation _builder_2 = new StringConcatenation();
            _builder_2.append("Duplicate endpoint for protocol ");
            _builder_2.append(protocolId);
            this.error(_builder_2.toString(), endpoint, 
              ServicePackage.Literals.ENDPOINT__PROTOCOLS, (i).intValue());
          }
        }
      }
    };
    endpoints.forEach(_function);
  }
  
  /**
   * Convenience method to warn about non-unique endpoint addresses within a list of endpoints
   */
  private void warnUniqueEndpointAddresses(final List<Endpoint> endpoints, final String containerTypeName, final Function<Endpoint, List<String>> getEndpointContainerNameParts) {
    final HashMap<String, Map<String, Object>> uniqueAddressMap = CollectionLiterals.<String, Map<String, Object>>newHashMap();
    final Consumer<Endpoint> _function = (Endpoint endpoint) -> {
      int _size = endpoint.getAddresses().size();
      ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, _size, true);
      for (final Integer i : _doubleDotLessThan) {
        final Consumer<ImportedProtocolAndDataFormat> _function_1 = (ImportedProtocolAndDataFormat protocol) -> {
          final String address = endpoint.getAddresses().get((i).intValue());
          String _name = protocol.getImport().getName();
          String _plus = (_name + "::");
          String _name_1 = protocol.getImportedProtocol().getName();
          String protocolName = (_plus + _name_1);
          final DataFormat dataFormat = protocol.getDataFormat();
          String _formatName = null;
          if (dataFormat!=null) {
            _formatName=dataFormat.getFormatName();
          }
          boolean _tripleNotEquals = (_formatName != null);
          if (_tripleNotEquals) {
            String _protocolName = protocolName;
            StringConcatenation _builder = new StringConcatenation();
            _builder.append("(");
            String _formatName_1 = dataFormat.getFormatName();
            _builder.append(_formatName_1);
            _builder.append(")");
            protocolName = (_protocolName + _builder);
          } else {
            String _protocolName_1 = protocolName;
            StringConcatenation _builder_1 = new StringConcatenation();
            _builder_1.append("(");
            String _formatName_2 = protocol.getImportedProtocol().getDefaultFormat().getFormatName();
            _builder_1.append(_formatName_2);
            _builder_1.append(")");
            protocolName = (_protocolName_1 + _builder_1);
          }
          final String addressPrefixedByProtocol = (protocolName + address);
          final HashMap<String, Object> valueMap = CollectionLiterals.<String, Object>newHashMap();
          valueMap.put("protocol", protocolName);
          valueMap.put("endpoint", endpoint);
          final Map<String, Object> duplicate = uniqueAddressMap.putIfAbsent(addressPrefixedByProtocol, valueMap);
          Endpoint _xifexpression = null;
          if ((duplicate != null)) {
            Object _get = duplicate.get("endpoint");
            _xifexpression = ((Endpoint) _get);
          }
          final Endpoint duplicateEndpoint = _xifexpression;
          if (((duplicateEndpoint != null) && (duplicateEndpoint != endpoint))) {
            Object _get_1 = duplicate.get("protocol");
            final String duplicateProtocolName = ((String) _get_1);
            final List<String> duplicateContainerNameParts = getEndpointContainerNameParts.apply(duplicateEndpoint);
            final List<String> currentEndpointContainerNameParts = getEndpointContainerNameParts.apply(endpoint);
            final String relativeDuplicateName = QualifiedName.create(
              LemmaUtils.<Endpoint, ServiceModel>calculateRelativeQualifiedNameParts(duplicateEndpoint, duplicateContainerNameParts, ServiceModel.class, endpoint, currentEndpointContainerNameParts, ServiceModel.class)).toString();
            StringConcatenation _builder_2 = new StringConcatenation();
            _builder_2.append("Address is already specified for protocol ");
            StringConcatenation _builder_3 = new StringConcatenation();
            _builder_3.append(duplicateProtocolName);
            _builder_3.append(" on ");
            _builder_3.append(containerTypeName);
            _builder_3.append(" ");
            String _plus_1 = (_builder_2.toString() + _builder_3);
            StringConcatenation _builder_4 = new StringConcatenation();
            _builder_4.append(relativeDuplicateName);
            String _plus_2 = (_plus_1 + _builder_4);
            this.warning(_plus_2, endpoint, 
              ServicePackage.Literals.ENDPOINT__ADDRESSES, (i).intValue());
          }
        };
        endpoint.getProtocols().forEach(_function_1);
      }
    };
    endpoints.forEach(_function);
  }
}
