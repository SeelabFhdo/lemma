package de.fhdo.lemma.data

import de.fhdo.lemma.data.DateUtils
import java.math.BigDecimal
import java.util.Map

/**
 * This metamodel represents the Data Modeling Viewpoint, which is mainly used for defining custom
 * structure, collection, and enumeration types.
 *
 * @author <a href="mailto:florian.rademacher@fh-dortmund.de">Florian Rademacher</a>
 */
class DataModel {
    /**
     * Implicit Constraints:
     *     (C1) Only one (or none) of the versions, contexts, or complexTypes may be filled with
     *          elements. That is, a DataModel may define custom types in versions (and contexts),
     *          contexts, or without versions and contexts.
     *          Ensured by: DSL grammar.
     */

    // TRANSFORMATION ONLY: The file path of the model in the form of a URI with a "file" scheme
    String t_modelUri

    contains ComplexTypeImport[] complexTypeImports opposite dataModel
    contains Version[] versions opposite dataModel
    contains Context[] contexts opposite dataModel
    contains ComplexType[] complexTypes opposite dataModel

    /* For debugging purposes to test the type checker. May be safely removed in the future. */
    //contains AssignTest[] assignTests

    /**
     * Get all ComplexTypes contained in a model instance
     */
    op ComplexType[] getContainedComplexTypes() {
        val containedComplexTypes = newArrayList

        // Get ComplexTypes encapsulated in versions
        if (versions !== null)
            versions.forEach[containedComplexTypes.addAll(it.containedComplexTypes)]

        // Get ComplexTypes encapsulated in contexts
        if (contexts !== null)
            contexts.forEach[containedComplexTypes.addAll(it.complexTypes)]

        containedComplexTypes.addAll(complexTypes)

        return containedComplexTypes.asEList
    }
}

/**
 * Represents the import of ComplexType from other DataModel instances
 */
class ComplexTypeImport {
    /**
     * Implicit Constraints:
     *     (C1) The import URI must point to a valid file.
     *          Ensured by: DSL validator.
     *     (C2) Imports must not be cyclic, i.e., the imported model must not directly or indirectly
     *          import this model.
     *          Ensured by: DSL validator.
     *     (C3) Name (= import alias) must be unique.
     *          Ensured by: DSL validator.
     *     (C4) Imported file must define a data model.
     *          Ensured by: DSL validator.
     */

    String name
    String importURI

    container DataModel dataModel opposite complexTypeImports
}

/**
 * A version may represent an additional naming scope for several complex types, either directly or
 * indirectly, when they are organized in contexts.
 */
class Version {
    /**
     * Implicit Constraints:
     *     (C1) Either one (or none) of the complexTypes or contexts may have elements.
     *          Ensured by: DSL grammar.
     *     (C2) Name must be unique.
     *          Ensured by: DSL validator.
     */

    String name

    contains ComplexType[] complexTypes opposite version
    contains Context[] contexts opposite version

    container DataModel dataModel opposite versions

    /**
     * Get all ComplexTypes contained by the Version
     */
    op ComplexType[] getContainedComplexTypes() {
        val containedComplexTypes = newArrayList

        if (contexts !== null)
            contexts.forEach[containedComplexTypes.addAll(it.complexTypes)]

        containedComplexTypes.addAll(complexTypes)

        return containedComplexTypes.asEList
    }

    /**
     * Get parts of the version for creating a qualified name
     */
    op String[] getQualifiedNameParts() {
        if (name === null || name.empty)
            return newArrayList.asEList

        val nameParts = newArrayList
        nameParts.add(name)
        nameParts.asEList
    }
}

/**
 * Next to a version, a context may act as an additional, possibly subordinate, naming scope to
 * organize complex types
 */
class Context {
    /**
     * Implicit Constraints:
     *     (C1) Name must be unique.
     *          Ensured by: DSL validator.
     */

    String name

    contains ComplexType[1..*] complexTypes opposite context

    container DataModel dataModel opposite contexts
    container Version version opposite contexts

    /**
     * Get parts of the context for creating a qualified name
     */
    op String[] getQualifiedNameParts() {
        if (name === null || name.empty)
            return newArrayList.asEList

        val nameParts = newArrayList

        if (version !== null)
            nameParts.addAll(version.qualifiedNameParts)

        nameParts.add(name)
        nameParts.asEList
    }

    /**
     * Build qualified name from qualified name parts
     */
    op String buildQualifiedName(String separator) {
        if (separator === null)
            return null

        var String qualifiedName = ""
        for (part : qualifiedNameParts)
            qualifiedName += separator + part
        // Remove leading separator
        if (!qualifiedName.empty)
            qualifiedName = qualifiedName.substring(separator.length)
        return qualifiedName
    }
}

/*
 * Abstract super class for all types
 */
abstract class Type {}

/*
 * Enumeration for primitive type constants (literal: type name, value: type size)
 */
enum PrimitiveTypeConstants {
    BOOLEAN as "boolean" = 1
    BYTE as "byte" = 8
    CHARACTER as "char" = 16
    DATE as "date" = -1
    DOUBLE as "double" = 64
    FLOAT as "float" = 32
    INTEGER as "int" = 32
    LONG as "long" = 64
    SHORT as "short" = 16
    STRING as "string" = -1
    UNSPECIFIED as "unspecified" = -1
}

/*
 * Represents built-in primitive types that correspond to Java's primitive types in syntax,
 * semantics, naming and size. Strings and dates, however, are also treated as primitive types.
 */
abstract class PrimitiveType extends Type {
    /**
     * Get printable name of PrimitiveType instance
     */
    derived String typeName get {
        return switch (this) {
            PrimitiveBoolean: PrimitiveTypeConstants.BOOLEAN.literal
            PrimitiveByte: PrimitiveTypeConstants.BYTE.literal
            PrimitiveCharacter: PrimitiveTypeConstants.CHARACTER.literal
            PrimitiveDate: PrimitiveTypeConstants.DATE.literal
            PrimitiveDouble: PrimitiveTypeConstants.DOUBLE.literal
            PrimitiveFloat: PrimitiveTypeConstants.FLOAT.literal
            PrimitiveInteger: PrimitiveTypeConstants.INTEGER.literal
            PrimitiveLong: PrimitiveTypeConstants.LONG.literal
            PrimitiveShort: PrimitiveTypeConstants.SHORT.literal
            PrimitiveString: PrimitiveTypeConstants.STRING.literal
            PrimitiveUnspecified: PrimitiveTypeConstants.UNSPECIFIED.literal
            default: null
        }
    }

    /**
     * Get size of built-in primitive type
     */
    derived Integer typeSize get {
        return switch (this) {
            PrimitiveBoolean: PrimitiveTypeConstants.BOOLEAN.value
            PrimitiveByte: PrimitiveTypeConstants.BYTE.value
            PrimitiveCharacter: PrimitiveTypeConstants.CHARACTER.value
            // Date is a built-in (but still "object-based") primitive type. Its size is therefore
            // not determinable and hence set to null. Null will be treated as representing an
            // "infinite" size, e.g., sizeCompare(PrimitiveDate) on a PrimitiveLong instance will
            // return -1 stating that a Long is smaller than a Date object, that probably consists
            // of a variety of primitively-typed data fields
            PrimitiveDate: null
            PrimitiveDouble: PrimitiveTypeConstants.DOUBLE.value
            PrimitiveFloat: PrimitiveTypeConstants.FLOAT.value
            PrimitiveInteger: PrimitiveTypeConstants.INTEGER.value
            PrimitiveLong: PrimitiveTypeConstants.LONG.value
            PrimitiveShort: PrimitiveTypeConstants.SHORT.value
            // Unspecified primitives do no have a size
            PrimitiveUnspecified: null
            // String is a built-in (but still "object-based") primitive type. See the description
            // of Date for details.
            PrimitiveString: null
            default: null
        }
    }

    /**
     * Compare the size of two built-in primitive types, following the semantics of Java's
     * Comparator.compare() method
     */
    op int sizeCompare(PrimitiveType typeToCompare) {
        // Type is bigger than "null type"
        if (typeToCompare === null)
            return 1

        // If two _built-in_ primitive types have the same, their sizes are equal (just like the
        // types themselves)
        if (typeName !== null && typeName == typeToCompare.typeName)
            return 0

        /* Perform size-based comparison */
        val typeToCompareSize = typeToCompare.typeSize
        if (typeSize === null)
            if (typeToCompareSize === null)
                return 0  // Both sizes are null and hence "infinite"
            else
                return 1  // This type's size is null, hence "infinite" and bigger
        else
            if (typeToCompareSize === null)
                return -1  // The compared type is null, hence "infinite" and bigger
            else if (typeSize > typeToCompareSize)
                return 1  // This type's size is bigger
            else if (typeSize < typeToCompareSize)
                return -1  // The compared type's size is bigger
            else
                return 0  // Both type sizes are equal
    }

    /**
     * Check if type is compatible with another built-in primitive type
     */
    op boolean isCompatibleWith(PrimitiveType typeToCheck) {
        // Unspecified types cannot be checked for type compatibility and are thus always
        // incompatible to any other type instances
        if (this instanceof PrimitiveUnspecified || typeToCheck instanceof PrimitiveUnspecified)
            return false

        // Same types are compatible
        if (typeToCheck !== null && typeToCheck.typeName == this.typeName)
            return true

        /**
         * Check compatibility of different types based on Java's rules for primitive type
         * compatibility
         */

        // Byte may be converted into short, integer, long, float, and double
        if (typeToCheck instanceof PrimitiveByte)
            switch (this) {
                PrimitiveShort,
                PrimitiveInteger,
                PrimitiveLong,
                PrimitiveFloat,
                PrimitiveDouble: return true
            }

        // Short may be converted into integer, long, float, and double
        else if (typeToCheck instanceof PrimitiveShort)
            switch (this) {
                PrimitiveInteger,
                PrimitiveLong,
                PrimitiveFloat,
                PrimitiveDouble: return true
            }

        // Character may be converted into integer, long, float, double, and string
        else if (typeToCheck instanceof PrimitiveCharacter)
            switch (this) {
                PrimitiveInteger,
                PrimitiveLong,
                PrimitiveFloat,
                PrimitiveDouble,
                PrimitiveString: return true
            }

        // Integer may be converted into long, float, and double
        else if (typeToCheck instanceof PrimitiveInteger)
            switch (this) {
                PrimitiveLong,
                PrimitiveFloat,
                PrimitiveDouble: return true
            }

        // Long may be converted into float and double
        else if (typeToCheck instanceof PrimitiveLong)
            switch (this) {
                PrimitiveFloat,
                PrimitiveDouble: return true
            }

         // Float may be converted into double
        else if (typeToCheck instanceof PrimitiveFloat)
            switch (this) {
                PrimitiveDouble: return true
            }

        return false
    }

    /**
     * Convenience operation for retrieving all concrete built-in primitive types' meta-classes
     */
    op Class<?>[] getBuiltinPrimitiveTypes() {
        val primitiveTypes = <Class<?>>newArrayList
        primitiveTypes.add(PrimitiveBoolean)
        primitiveTypes.add(PrimitiveByte)
        primitiveTypes.add(PrimitiveCharacter)
        primitiveTypes.add(PrimitiveDate)
        primitiveTypes.add(PrimitiveDouble)
        primitiveTypes.add(PrimitiveFloat)
        primitiveTypes.add(PrimitiveInteger)
        primitiveTypes.add(PrimitiveLong)
        primitiveTypes.add(PrimitiveShort)
        primitiveTypes.add(PrimitiveString)
        primitiveTypes.add(PrimitiveUnspecified)
        return primitiveTypes.asEList
    }
}

/**
 * Concepts for all concrete built-in primitive types
 */
class PrimitiveBoolean extends PrimitiveType {}
class PrimitiveByte extends PrimitiveType {}
class PrimitiveCharacter extends PrimitiveType {}
class PrimitiveDate extends PrimitiveType {}
class PrimitiveDouble extends PrimitiveType {}
class PrimitiveFloat extends PrimitiveType {}
class PrimitiveInteger extends PrimitiveType {}
class PrimitiveLong extends PrimitiveType {}
class PrimitiveShort extends PrimitiveType {}
class PrimitiveString extends PrimitiveType {}
class PrimitiveUnspecified extends PrimitiveType {}

/**
 * Super-concept of complex types
 */
abstract class ComplexType extends Type {
    /**
     * Implicit Constraints:
     *     (C1) Name must be unique.
     *          Ensured by: DSL validator.
     */

    String name
    ComplexTypeFeature[] features

    container DataModel dataModel opposite complexTypes
    container Version version opposite complexTypes
    container Context context opposite complexTypes

    /**
     * Flag indicating that the ComplexType instance is a DataStructure
     */
    derived boolean isStructure get {
        return this instanceof DataStructure
    }

    /**
     * Flag indicating that the ComplexType instance is a CollectionType that holds a PrimitiveType
     * and hence does not consist of several named and typed DataFields
     */
    derived boolean isPrimitiveCollection get {
        if (!(this instanceof CollectionType))
            return false

        return (this as CollectionType).primitiveType !== null
    }

    /**
     * Flag indicating that the ComplexType instance is a CollectionType that consists of several
     * named and typed DataFields instead of a single "anonymous" PrimitiveType field
     */
    derived boolean isStructuredCollection get {
        if (!(this instanceof CollectionType))
            return false

        return (this as CollectionType).dataFields !== null &&
            !(this as CollectionType).dataFields.empty
    }

    /**
     * Flag indicating that the ComplexType instance is an Enumeration
     */
    derived boolean isEnumeration get {
        return this instanceof Enumeration
    }

    /**
     * Get parts of the complex type for creating a qualified name
     */
    op String[] getQualifiedNameParts() {
        if (name === null || name.empty)
            return newArrayList.asEList

        val nameParts = newArrayList

        if (version !== null)
            nameParts.addAll(version.qualifiedNameParts)

        if (context !== null)
            nameParts.addAll(context.qualifiedNameParts)

        nameParts.add(name)
        nameParts.asEList
    }

    /**
     * Build qualified name from qualified name parts
     */
    op String buildQualifiedName(String separator) {
        if (separator === null)
            return null

        var String qualifiedName = ""
        for (part : qualifiedNameParts)
            qualifiedName += separator + part
        // Remove leading separator
        if (!qualifiedName.empty)
            qualifiedName = qualifiedName.substring(separator.length)
        return qualifiedName
    }

    /**
     * Get closest encompassing namespace
     */
    op Object getClosestNamespace() {
        return if (context !== null)
                context
            else if (version !== null)
                version
            else
                dataModel
    }

    /**
     * Helper operation for ComplexType-subclasses to compare the counts of two DataField lists. The
     * return value follows the semantics of Java's Comparator.compare() method. The comparison is
     * based on the numbers of concrete types of the DataFields, i.e., primitive types are compared
     * with primitive types, structures with structures, and collections with collections. The field
     * count of the first argument is greater, i.e., the operation returns 1, in case the
     * type-specific field counts are not equal and at least one type-specific field count is
     * greater than its counterpart in the second argument, e.g., there are more collection-typed
     * fields in the first than in the second argument.
     */
    op int compareFieldCounts(DataField[] fields, DataField[] fieldsToCompare) {
        // Both arguments' field counts are equal by convention, in case both arguments are null
        if (fields === null && fieldsToCompare === null)
            return 0
        // First argument is smaller by convention, when is null
        else if (fields === null)
            return -1
        // First argument is greater by convention, when second argument is null
        else if (fieldsToCompare === null)
            return 1

        /* Build type-specific lists of data fields for both arguments */
        val fieldsPrimitiveCounts = fields.filter[it.effectiveType instanceof PrimitiveType].length
        val fieldsStructureCounts = fields.filter[it.effectiveType instanceof DataStructure].length
        val fieldsCollectionCounts = fields.filter[it.effectiveType instanceof CollectionType]
            .length

        val primitiveCountsToCompare = fieldsToCompare.filter[
            it.effectiveType instanceof PrimitiveType
        ].length
        val structureCountsToCompare = fieldsToCompare.filter[
            it.effectiveType instanceof DataStructure
        ].length
        val collectionCountsToCompare = fieldsToCompare.filter[
            it.effectiveType instanceof CollectionType
        ].length

        /* Do the actual comparison */
        if (fieldsPrimitiveCounts === primitiveCountsToCompare &&
            fieldsStructureCounts === structureCountsToCompare &&
            fieldsCollectionCounts === collectionCountsToCompare)
            return 0
        else if (fieldsPrimitiveCounts >= primitiveCountsToCompare &&
            fieldsStructureCounts >= structureCountsToCompare &&
            fieldsCollectionCounts >= collectionCountsToCompare)
            return 1

        return -1
    }

    /**
     * Get list of domain-driven-design-related features
     */
    op ComplexTypeFeature[] getAllDomainFeatures() {
        return #[
            ComplexTypeFeature.AGGREGATE,
            ComplexTypeFeature.APPLICATION_SERVICE,
            ComplexTypeFeature.DOMAIN_EVENT,
            ComplexTypeFeature.DOMAIN_SERVICE,
            ComplexTypeFeature.ENTITY,
            ComplexTypeFeature.FACTORY,
            ComplexTypeFeature.INFRASTRUCTURE_SERVICE,
            ComplexTypeFeature.REPOSITORY,
            ComplexTypeFeature.SERVICE,
            ComplexTypeFeature.SPECIFICATION,
            ComplexTypeFeature.VALUE_OBJECT
        ].toEList
    }

    /**
     * Check if the type has a specific feature assigned
     */
    op boolean hasFeature(ComplexTypeFeature feature) {
        return features.contains(feature)
    }
}

/**
 * Possible features for a complex type. Remember to adapt ComplexType.getAllDomainFeatures() if a
 * new domain-driven-design-related feature is added.
 */
enum ComplexTypeFeature {
    AGGREGATE,
    APPLICATION_SERVICE,
    DOMAIN_EVENT,
    DOMAIN_SERVICE,
    ENTITY,
    FACTORY,
    INFRASTRUCTURE_SERVICE,
    REPOSITORY,
    SERVICE,
    SPECIFICATION,
    VALUE_OBJECT
}

/**
 * Represents a complex type that is imported from another data model
 */
class ImportedComplexType {
    refers ComplexTypeImport ^import
    refers Type importedType

    container DataField dataField opposite importedComplexType
    container DataOperation operation opposite importedComplexReturnType
    container DataOperationParameter parameter opposite importedComplexType
}

/*
 * Concept for data structures, i.e., complex types probably consisting of named and typed fields,
 * but that may also be empty though
 */
class DataStructure extends ComplexType {
    /**
     * Implicit Constraints:
     *     (C1) No cyclic inheritance, i.e., within an inheritance hierarchy, a data structure must
     *          not occur twice.
     *          Ensured by: DSL validator.
     */

    refers DataStructure ^super
    contains DataField[] dataFields opposite dataStructure
    contains DataOperation[] operations opposite dataStructure

    /**
     * Get the effective fields of the structure considering possible direct and indirect
     * inheritance relationships
     */
    op DataField[] getEffectiveFields() {
        val effectiveFields = <DataField> newArrayList
        val hiddenFields = <String> newHashSet
        var currentStructure = this
        do {
            // Collect named fields of currently iterated structure in the inheritance hierarchy. It
            // may happen that a field does not have a name, e.g., when the user does not finish its
            // declaration leveraging the DSL (which leads to syntax errors but does not prevent
            // model validation)
            val currentNamedFields = currentStructure.dataFields.filter[it.name !== null]

            for (field : currentNamedFields) {
                // Collect hidden fields on the way upwards the inheritance root
                if (field.hidden)
                    hiddenFields.add(field.name)

                // Got the field already collected on a lower inheritance level?
                val existingEffectiveField = effectiveFields.findFirst[field.name == it.name]
                val fieldAlreadyCollected = existingEffectiveField !== null

                // Is the field hidden, i.e., is the field itself hidden or was a field of the same
                // name hidden on a lower inheritance level?
                val hiddenField = field.hidden || hiddenFields.contains(field.name)

                // Was the field inherited from a super structure?
                val inheritedField = currentStructure !== this

                // Is this a visible, inherited field?
                val visibleInheritedField = !hiddenField && inheritedField

                // Add the field to the list of effective fields if one of the following applies:
                //    (1) The field was not collected before, and is either not inherited or if
                //        inherited it is visible.
                //    (2) In case the field got collected before and there exists a hidden version
                //        of it somewhere in the lower inheritance levels, we remove the existing
                //        version, which must've also been hidden (otherwise it could not be
                //        referenced on a lower inheritance level), and add the currently iterated
                //        field. This eventually results in the list of effective fields to contain
                //        only the visible versions of fields that get hidden somewhere on a lower
                //        inheritance hierarchy level.
                if (!fieldAlreadyCollected &&
                    (!inheritedField || visibleInheritedField))
                    effectiveFields.add(field)
                else if (fieldAlreadyCollected && hiddenField) {
                    effectiveFields.remove(existingEffectiveField)
                    effectiveFields.add(field)
                }
            }

            // Go to next, higher inheritance hierarchy level
            currentStructure = currentStructure.super
        } while (currentStructure !== null)

        return effectiveFields.asEList
    }

    /**
     * Get the effective operations of the structure considering possible direct and indirect
     * inheritance relationships
     */
    op DataOperation[] getEffectiveOperations() {
        val effectiveOperations = <DataOperation> newArrayList
        val hiddenOperations = <String> newHashSet
        var currentStructure = this
        do {
            val currentNamedOperations = currentStructure.operations.filter[it.name !== null]

            for (operation : currentNamedOperations) {
                if (operation.hidden)
                    hiddenOperations.add(operation.name)

                // Got the operation already collected on a lower inheritance level?
                val existingEffectiveOperation = effectiveOperations
                    .findFirst[operation.name == it.name]
                val operationAlreadyCollected = existingEffectiveOperation !== null

                // Is the operation hidden, i.e., is the operation itself hidden or was an operation
                // of the same name hidden on a lower inheritance level?
                val hiddenOperation = operation.hidden || hiddenOperations.contains(operation.name)

                // Was the operation inherited from a super structure?
                val inheritedOperation = currentStructure !== this

                // Is this a visible, inherited operation?
                val visibleInheritedOperation = !hiddenOperation && inheritedOperation

                // Add the operation to the list of effective operation if one of the following
                // applies:
                //    (1) The operation was not collected before, and is either not inherited or if
                //        inherited it is visible.
                //    (2) In case the operation got collected before and there exists a hidden
                //        version of it somewhere in the lower inheritance levels, we remove the
                //        existing version, which must've also been hidden (otherwise it could not
                //        be referenced on a lower inheritance level), and add the currently
                //        iterated operation. This eventually results in the list of effective
                //        operations to contain only the visible versions of operations that get
                //        hidden somewhere on a lower inheritance hierarchy level.
                if (!operationAlreadyCollected &&
                    (!inheritedOperation || visibleInheritedOperation))
                    effectiveOperations.add(operation)
                else if (operationAlreadyCollected && hiddenOperation) {
                    effectiveOperations.remove(existingEffectiveOperation)
                    effectiveOperations.add(operation)
                }
            }

            currentStructure = currentStructure.super
        } while (currentStructure !== null)

        return effectiveOperations.asEList
    }

    /**
     * Check if this data structure is a direct or indirect extension of, i.e., if it inherits from,
     * another data structure
     */
    op boolean isExtensionOf(DataStructure structure) {
        if (structure === null)
            return false

        var currentStructure = this
        while (currentStructure.super !== null) {
            if (currentStructure.super == structure)
                return true

            currentStructure = currentStructure.super
        }

        return false
    }

    /**
     * Convenience methods to compare two data structures by field counts
     */
    op int compareFieldCounts(DataStructure structureToCompare) {
        if (structureToCompare === null)
            return 1

        return super.compareFieldCounts(effectiveFields, structureToCompare.effectiveFields)
    }
}

/**
 * Possible features for a data operation
 */
enum DataOperationFeature {
    CLOSURE,
    IDENTIFIER,
    SIDE_EFFECT_FREE,
    VALIDATOR
}

/**
 * Represents an operation within a data structure
 */
class DataOperation {
    /**
     * Implicit Constraints:
     *     (C1) The operation must have a return type specification (which can be a complex return
     *          type, a primitive return type, or an _explicit_ specification that the operation has
     *          no return type) if either no operation with an equal name exists in a super data
     *          structure, or if an eponymous super operation exists that is hidden.
     *          Ensured by: DSL validator.
     *     (C2) If an eponymous super operation exists that is not hidden, than this operation must
     *          not have a return type specification, i.e., a visible super operation cannot be
     *          redefined in a sub-structure.
     *          Ensured by: DSL validator.
     *     (C3) Name must be unique within a data structure.
     *          Ensured by: DSL validator.
     */

    String name
    boolean hidden
    boolean hasNoReturnType
    DataOperationFeature[] features
    refers ComplexType[0..1] complexReturnType

    contains ImportedComplexType[0..1] importedComplexReturnType opposite operation
    contains PrimitiveType[0..1] primitiveReturnType
    contains DataOperationParameter[] parameters opposite operation

    container DataStructure dataStructure opposite operations

    /**
     * Flag to indicate that this operation lacks a return type specification, i.e., it was not
     * explicitly specified as having no return type and also does not return a primitive or complex
     * type
     */
    derived boolean lacksReturnTypeSpecification get {
        !hasNoReturnType && primitiveOrComplexReturnType === null
    }

    /**
     * Flag to indicate if this operation is inherited from a super structure
     */
    derived boolean inherited get {
        return findEponymousSuperOperation() !== null
    }

    /**
     * Get parts of the operation for creating a qualified name
     */
    op String[] getQualifiedNameParts() {
        if (name === null || name.empty)
            return newArrayList.asEList

        val nameParts = dataStructure.qualifiedNameParts
        nameParts.add(name)
        nameParts.asEList
    }

    /**
     * Build qualified name from qualified name parts
     */
    op String buildQualifiedName(String separator) {
        if (separator === null)
            return null

        var String qualifiedName = ""
        for (part : qualifiedNameParts)
            qualifiedName += separator + part
        // Remove leading separator
        if (!qualifiedName.empty)
            qualifiedName = qualifiedName.substring(separator.length)
        return qualifiedName
    }

    /**
     * Find an eponymous operation in the inheritance hierarchy of this operations's data structure.
     * Returns null, if this operation is not part of a data structure, as only data structures may
     * extend other data structures.
     */
    op DataOperation findEponymousSuperOperation() {
        if (dataStructure === null)
            return null

        if (name === null || name.empty)
            return null

        var superStructure = dataStructure.super
        while (superStructure !== null) {
            val overridenOperation = superStructure.operations.findFirst[
                this.name == it.name
            ]

            if (overridenOperation !== null)
                return overridenOperation
            else
                superStructure = superStructure.^super
        }

        return null
    }

    /**
     * Get the return type of the operation, if any. Will return null if the operation has no
     * primitive or complex type.
     */
    op Type getPrimitiveOrComplexReturnType() {
        return if (primitiveReturnType !== null)
            primitiveReturnType
        else if (complexReturnType !== null)
            complexReturnType
        else if (importedComplexReturnType !== null)
            importedComplexReturnType.importedType
        else
            null
    }

    /**
     * Check if the operation has a specific feature assigned
     */
    op boolean hasFeature(DataOperationFeature feature) {
        return features.contains(feature)
    }
}

class DataOperationParameter {
    /**
     * Implicit Constraints:
     *     (C1) Must have exactly one type, either imported or primitive.
     *          Ensured by: DSL grammar.
     *     (C2) Imported types may only come from a data model.
     *          Ensured by: DSL scope provider.
     *     (C3) Name must be unique.
     *          Ensured by: DSL validator.
     */

    String name
    refers ComplexType[0..1] complexType

    contains ImportedComplexType[0..1] importedComplexType opposite parameter
    contains PrimitiveType[0..1] primitiveType

    container DataOperation operation opposite parameters

    /**
     * Get parts of the parameter for creating a qualified name
     */
    op String[] getQualifiedNameParts() {
        if (name === null || name.empty)
            return newArrayList.asEList

        val nameParts = operation.qualifiedNameParts
        nameParts.addAll(name)
        nameParts.asEList
    }

    /**
     * Build qualified name from qualified name parts
     */
    op String buildQualifiedName(String separator) {
        if (separator === null)
            return null

        var String qualifiedName = ""
        for (part : qualifiedNameParts)
            qualifiedName += separator + part
        // Remove leading separator
        if (!qualifiedName.empty)
            qualifiedName = qualifiedName.substring(separator.length)
        return qualifiedName
    }

    /**
     * Get effective type of parameter, i.e., the primitive or imported type (null otherwise)
     */
    op Type getEffectiveType() {
        return if (primitiveType !== null)
            primitiveType
        else if (complexType !== null)
            complexType
        else if (importedComplexType !== null)
            importedComplexType.importedType
        else
            null
    }
}

/**
 * Representation of a collection with either a primitive type or several data fields
 */
class CollectionType extends ComplexType {
    /**
     * Implicit Constraints:
     *     (C1) Collection has either primitive type assigned or data fields.
     *          Ensured by: DSL grammar.
     */

    contains PrimitiveType[0..1] primitiveType
    contains DataField[] dataFields opposite collectionType

    /**
     * Convenience method to compare field counts of two collections
     */
    op int compareFieldCounts(CollectionType otherCollection) {
        if (otherCollection === null)
            return 1

        /**
         * If the collection to compare is a primitive collection and this is either a primitive
         * collection or has only one data field, then the field counts equal to one field.
         * Otherwise (collection with data fields that has more than one field) this collection's
         * field count is greater.
         */
        if (otherCollection.isPrimitiveCollection)
            if (isPrimitiveCollection || dataFields.size == 1)
                return 0
            else
                return 1

        /**
         * If this collection is a primitive collection and the one to compare is either a primitive
         * collection or has only one data field, then the field counts equal to one field. Otherwise
         * (this is a collection with data fields that has more than one field) this collection's
         * field count is smaller.
         */
        if (isPrimitiveCollection)
            if (otherCollection.isPrimitiveCollection || otherCollection.dataFields.size == 1)
                return 0
            else
                return -1

        /**
         * If this and the collection to compare are both collections with data fields, use the
         * inherited method of ComplexType to perform the actual comparison based on DataField lists
         */
        return super.compareFieldCounts(dataFields, otherCollection.dataFields)
    }
}

/**
 * Possible features for a data field
 */
enum DataFieldFeature {
    IDENTIFIER,
    NEVER_EMPTY,
    PART
}

/**
 * Represents a typed and named field
 */
class DataField {
    /**
     * Implicit Constraints:
     *     (C1) May either have a complex or primitive type, not both.
     *          Ensured by: DSL grammar.
     *     (C2) Must have a type or be hidden.
     *          Ensured by: DSL validator.
     *     (C3) The field must have a type if either no field with an equal name exists in a super
     *          data structure, or if an eponymous super field exists that is hidden.
     *          Ensured by: DSL validator.
     *     (C3) If an eponymous super field exists that is not hidden, than this field must not have
     *          a type, i.e., a visible super field cannot be redefined in a sub-structure.
     *          Ensured by: DSL validator.
     *     (C4) Name must be unique within a data structure.
     *          Ensured by: DSL validator.
     *     (C5) A feature may only be assigned once.
     *          Ensured by: DSL validator.
     *     (C6) Inherited fields cannot be immutable.
     *          Ensured by: DSL validator.     *
     *     (C7) Only data fields within structures are initializable.
     *          Ensured by: DSL validator.
     *     (C8) Only primitive data fields are initializable. Together with C3 this automatically
     *          ensures that inherited fields cannot be initialized (which is desired behavior).
     *          Ensured by: DSL validator.
     *     (C9) Initialization value must be compatible to primitive type.
     *          Ensured by: DSL validator.
     */

    String name
    boolean hidden
    boolean immutable
    refers ComplexType[0..1] complexType

    contains ImportedComplexType[0..1] importedComplexType opposite dataField
    contains PrimitiveType[0..1] primitiveType
    contains PrimitiveValue[0..1] initializationValue
    DataFieldFeature[] features

    container DataStructure dataStructure opposite dataFields
    container CollectionType collectionType opposite dataFields

    /**
     * Get the effective type (complex type, possibly imported, or primitive type) of the field
     */
    op Type getEffectiveType() {
        return if (primitiveType !== null)
            primitiveType
        else if (complexType !== null)
            complexType
        else if (importedComplexType !== null)
            importedComplexType.importedType
        else
            null
    }

    /**
     * Get parts of the data field for creating a qualified name
     */
    op String[] getQualifiedNameParts() {
        if (name === null || name.empty)
            return newArrayList.asEList

        val nameParts = newArrayList

        if (dataStructure !== null)
            nameParts.addAll(dataStructure.qualifiedNameParts)
        else if (collectionType !== null)
            nameParts.addAll(collectionType.qualifiedNameParts)

        nameParts.add(name)
        nameParts.asEList
    }

    /**
     * Build qualified name from qualified name parts
     */
    op String buildQualifiedName(String separator) {
        if (separator === null)
            return null

        var String qualifiedName = ""
        for (part : qualifiedNameParts)
            qualifiedName += separator + part
        // Remove leading separator
        if (!qualifiedName.empty)
            qualifiedName = qualifiedName.substring(separator.length)
        return qualifiedName
    }

    /**
     * Find an eponymous field in the inheritance hierarchy of this field's data structure. Returns
     * null, if this field is not part of a data structure, as only data structures may extend other
     * data structures.
     */
    op DataField findEponymousSuperField() {
        if (dataStructure === null)
            return null

        if (name === null || name.empty)
            return null

        var superStructure = dataStructure.super
        while (superStructure !== null) {
            // Fields in super structures with the same name as this field are considered
            // "overridden"
            val overridenField = superStructure.dataFields.findFirst[
                this.name == it.name
            ]

            if (overridenField !== null)
                return overridenField
            else
                // Climb up the inheritance hierarchy
                superStructure = superStructure.^super
        }

        return null
    }

    /**
     * Check if the field has a specific feature assigned
     */
    op boolean hasFeature(DataFieldFeature feature) {
        return features.contains(feature)
    }
}

/**
 * Represents an enumeration that can have a variety of fields with arbitrary initializing values
 */
class Enumeration extends ComplexType {
    /**
     * Implicit Constraints:
     *     (C1) Field names must be unique.
     *          Ensured by: DSL validator.
     */
    contains EnumerationField[1..*] fields opposite enumeration
}

/**
 * Represents a field in an enumeration
 */
class EnumerationField {
    String name

    contains PrimitiveValue[0..1] initializationValue
    container Enumeration enumeration opposite fields

    /**
     * Get parts of the enumeration field for creating a qualified name
     */
    op String[] getQualifiedNameParts() {
        if (name === null || name.empty)
            return newArrayList.asEList

        val nameParts = enumeration.qualifiedNameParts
        nameParts.add(name)
        nameParts.asEList
    }

    /**
     * Build qualified name from qualified name parts
     */
    op String buildQualifiedName(String separator) {
        if (separator === null)
            return null

        var String qualifiedName = ""
        for (part : qualifiedNameParts)
            qualifiedName += separator + part
        // Remove leading separator
        if (!qualifiedName.empty)
            qualifiedName = qualifiedName.substring(separator.length)
        return qualifiedName
    }
}

/**
 * Primitive type value. In general, there are three "kinds" of values supported by the metamodel:
 *      (i) Numbers: Comprises values of primitive types byte, short, integer, long, float, and
 *                   double.
 *      (ii) Strings: Comprises values of primitive types character, string, and date.
 *      (iii) Boolean: True and false values.
 */
class PrimitiveValue {
    String stringValue
    Boolean booleanValue
    BigDecimal numericValue

    /**
     * Check if numeric primitive value is in closed set [lowerBound, upperBound]. Returns false if
     * value is not numeric.
     */
    op boolean isInClosedSet(BigDecimal lowerBound, BigDecimal upperBound) {
        if (numericValue === null)
            return false

        val outOfBoundLower = numericValue.compareTo(lowerBound) < 0;
        val outOfBoundUpper = numericValue.compareTo(upperBound) > 0;
        return !outOfBoundLower && !outOfBoundUpper
    }

    /**
     * Check if numeric value has decimals. Returns false if value is not numeric.
     */
    op boolean hasDecimals() {
        if (numericValue === null)
            return false

        val moduloOne = numericValue.remainder(new BigDecimal("1"));
        return moduloOne.compareTo(BigDecimal.ZERO) != 0
    }

    /**
     * Check if value is _exactly_ of the given primitive type
     */
    op boolean isOfType(PrimitiveType primitiveType) {
        return asValueOfType(primitiveType) !== null
    }

    /**
     * Check if value does not contain a value of a primitive type
     */
    op boolean hasNoValue() {
        return stringValue === null && numericValue === null && booleanValue === null
    }

    /**
     * Cast encapsulated value to _exactly_ the given primitive type. If no _exact_ casting is
     * possible or the no primitive value is contained, return null.
     */
    op Object asValueOfType(PrimitiveType primitiveType) {
        if (primitiveType === null || hasNoValue)
            return null

        return switch (primitiveType) {
            PrimitiveBoolean: asBoolean
            PrimitiveByte: asByte
            PrimitiveCharacter: asCharacter
            PrimitiveDate: asDate
            PrimitiveDouble: asDouble
            PrimitiveFloat: asFloat
            PrimitiveInteger: asInteger
            PrimitiveLong: asLong
            PrimitiveShort: asShort
            PrimitiveString: asString
            PrimitiveUnspecified: null
        }
    }

    /**
     * Get value as string. Returns an empty string if the instance hasNoValue(), i.e., when its
     * effectively null.
     */
    op String valueAsString() {
        if (hasNoValue())
            return ""

        if (stringValue !== null)
            return stringValue
        else if (numericValue !== null)
            return numericValue.toString
        else if (booleanValue !== null)
            return booleanValue.toString
    }


    /**
     * Return value as boolean or null, if value is no boolean
     */
    op Boolean asBoolean() {
        return booleanValue
    }

    /**
     * Return value as byte or null, if value is no byte
     */
    op Byte asByte() {
        if (numericValue === null)
            return null

        if (hasDecimals)
            return null

        if (!isInClosedSet(new BigDecimal(Byte.MIN_VALUE), new BigDecimal(Byte.MAX_VALUE)))
            return null

        return numericValue.byteValue
    }

    /**
     * Return value as character or null, if value is no character
     */
    op Character asCharacter() {
        if (stringValue === null)
            return null

        if (stringValue.empty)
            return Character.MIN_VALUE
        else if (stringValue.length === 1)
            return stringValue.charAt(0)

        return null
    }

    /**
     * Return value as date or null, if value is no date in Java's DateFormat.SHORT format
     */
    op Date asDate() {
        if (stringValue === null)
            return null

        DateUtils.parseDate(stringValue)
    }

    /**
     * Return value as double or null, if value is no double
     */
    op Double asDouble() {
        if (numericValue === null)
            return null

        // -Double.MAX_VALUE is the smallest possible number a Double can hold based on IEEE 754
        if (!isInClosedSet(new BigDecimal(-Double.MAX_VALUE), new BigDecimal(Double.MAX_VALUE)))
            return null

        val doubleValue = numericValue.doubleValue
        if (!Double.isNaN(doubleValue) && !Double.isInfinite(doubleValue))
            return doubleValue

        return null
    }

    /**
     * Return value as float or null, if value is no float
     */
    op Float asFloat() {
        if (numericValue === null)
            return null

        // -Float.MAX_VALUE is the smallest possible number a Float can hold based on IEEE 754
        if (!isInClosedSet(new BigDecimal(-Float.MAX_VALUE), new BigDecimal(Float.MAX_VALUE)))
            return null

        val floatValue = numericValue.floatValue
        if (!Float.isNaN(floatValue) && !Float.isInfinite(floatValue))
            return floatValue

        return null
    }

    /**
     * Return value as integer or null, if value is no integer
     */
    op Integer asInteger() {
        if (numericValue === null)
            return null

        if (hasDecimals)
            return null

        if (!isInClosedSet(new BigDecimal(Integer.MIN_VALUE), new BigDecimal(Integer.MAX_VALUE)))
            return null

        try {
            return numericValue.intValueExact
        } catch (ArithmeticException ex) {
            return null
        }
    }

    /**
     * Return value as long or null, if value is no long
     */
    op Long asLong() {
        if (numericValue === null)
            return null

        if (hasDecimals)
            return null

        if (!isInClosedSet(new BigDecimal(Long.MIN_VALUE), new BigDecimal(Long.MAX_VALUE)))
            return null

        try {
            return numericValue.longValueExact
        } catch (ArithmeticException ex) {
            return null
        }
    }

    /**
     * Return value as short or null, if value is no short
     */
    op Short asShort() {
        if (numericValue === null)
            return null

        if (hasDecimals)
            return null

        if (!isInClosedSet(new BigDecimal(Short.MIN_VALUE), new BigDecimal(Short.MAX_VALUE)))
            return null

        try {
            return numericValue.shortValueExact
        } catch (ArithmeticException ex) {
            return null
        }
    }

    /**
     * Return value as string or null, if value is no string
     */
    op String asString() {
        return stringValue
    }

    /**
     * Infer names and sizes of all compatible types into which this value can be converted
     */
    op TypeNameSizeMap inferCompatibleTypes() {
        val compatibleTypes = <String, Integer>newHashMap

        if (asBoolean !== null)
            compatibleTypes.put(
                PrimitiveTypeConstants.BOOLEAN.literal,
                PrimitiveTypeConstants.BOOLEAN.value
            )

        if (asByte !== null)
            compatibleTypes.put(
                PrimitiveTypeConstants.BYTE.literal,
                PrimitiveTypeConstants.BYTE.value
            )

        if (asCharacter !== null)
            compatibleTypes.put(
                PrimitiveTypeConstants.CHARACTER.literal,
                PrimitiveTypeConstants.CHARACTER.value
            )

        if (asShort !== null)
            compatibleTypes.put(
                PrimitiveTypeConstants.SHORT.literal,
                PrimitiveTypeConstants.SHORT.value
            )

        if (asInteger !== null)
            compatibleTypes.put(
                PrimitiveTypeConstants.INTEGER.literal,
                PrimitiveTypeConstants.INTEGER.value
            )

        if (asLong !== null)
            compatibleTypes.put(
                PrimitiveTypeConstants.LONG.literal,
                PrimitiveTypeConstants.LONG.value
            )

        if (asFloat !== null)
            compatibleTypes.put(
                PrimitiveTypeConstants.FLOAT.literal,
                PrimitiveTypeConstants.FLOAT.value
            )

        if (asDouble !== null)
            compatibleTypes.put(
                PrimitiveTypeConstants.DOUBLE.literal,
                PrimitiveTypeConstants.DOUBLE.value
            )

        if (asDate !== null)
            compatibleTypes.put(
                PrimitiveTypeConstants.DATE.literal,
                PrimitiveTypeConstants.DATE.value
            )

        if (asString !== null)
            compatibleTypes.put(
                PrimitiveTypeConstants.STRING.literal,
                PrimitiveTypeConstants.STRING.value
            )

        return compatibleTypes

    }
}

type TypeNameSizeMap wraps Map<String, Integer>
