/**
 * generated by Xtext 2.12.0
 */
package de.fhdo.ddmm.technology.validation;

import com.google.common.base.Function;
import com.google.common.base.Objects;
import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;
import de.fhdo.ddmm.data.PrimitiveType;
import de.fhdo.ddmm.data.PrimitiveValue;
import de.fhdo.ddmm.technology.CommunicationType;
import de.fhdo.ddmm.technology.CompatibilityDirection;
import de.fhdo.ddmm.technology.CompatibilityMatrixEntry;
import de.fhdo.ddmm.technology.DataFormat;
import de.fhdo.ddmm.technology.JoinPointType;
import de.fhdo.ddmm.technology.OperationEnvironment;
import de.fhdo.ddmm.technology.OperationTechnology;
import de.fhdo.ddmm.technology.PointcutType;
import de.fhdo.ddmm.technology.PossiblyImportedTechnologySpecificType;
import de.fhdo.ddmm.technology.Protocol;
import de.fhdo.ddmm.technology.ServiceAspect;
import de.fhdo.ddmm.technology.ServiceAspectPointcut;
import de.fhdo.ddmm.technology.ServiceAspectPointcutSelector;
import de.fhdo.ddmm.technology.Technology;
import de.fhdo.ddmm.technology.TechnologyAspect;
import de.fhdo.ddmm.technology.TechnologyImport;
import de.fhdo.ddmm.technology.TechnologyPackage;
import de.fhdo.ddmm.technology.TechnologySpecificPrimitiveType;
import de.fhdo.ddmm.technology.TechnologySpecificProperty;
import de.fhdo.ddmm.technology.validation.AbstractTechnologyDslValidator;
import de.fhdo.ddmm.typechecking.TypecheckingUtils;
import de.fhdo.ddmm.utils.DdmmUtils;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.ExclusiveRange;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;

/**
 * This class contains custom validation rules.
 * 
 * @author <a href="mailto:florian.rademacher@fh-dortmund.de">Florian Rademacher</a>
 */
@SuppressWarnings("all")
public class TechnologyDslValidator extends AbstractTechnologyDslValidator {
  /**
   * Check if technology model contains at least one section
   */
  @Check
  public void checkModelNotEmpty(final Technology technology) {
    final boolean modelEmpty = (((((((technology.getPrimitiveTypes().isEmpty() && 
      technology.getListTypes().isEmpty()) && 
      technology.getDataStructures().isEmpty()) && 
      technology.getProtocols().isEmpty()) && 
      technology.getServiceAspects().isEmpty()) && 
      technology.getDeploymentTechnologies().isEmpty()) && 
      technology.getInfrastructureTechnologies().isEmpty()) && 
      technology.getOperationAspects().isEmpty());
    if (modelEmpty) {
      this.error("Model must not be empty", technology, 
        TechnologyPackage.Literals.TECHNOLOGY__NAME);
    }
  }
  
  /**
   * Check that imported file is imported exactly once
   */
  @Check
  public void checkImportFileUniqueness(final Technology model) {
    final Function<TechnologyImport, String> _function = (TechnologyImport it) -> {
      return it.getImportURI();
    };
    final Integer duplicateIndex = DdmmUtils.<TechnologyImport, String>getDuplicateIndex(model.getImports(), _function);
    if (((duplicateIndex).intValue() == (-1))) {
      return;
    }
    final TechnologyImport duplicate = model.getImports().get((duplicateIndex).intValue());
    this.error("File is already being imported", duplicate, 
      TechnologyPackage.Literals.TECHNOLOGY_IMPORT__IMPORT_URI);
  }
  
  /**
   * Check if an imported file exists
   */
  @Check
  public void checkImportFileExists(final TechnologyImport import_) {
    boolean _importFileExists = DdmmUtils.importFileExists(import_.eResource(), import_.getImportURI());
    boolean _not = (!_importFileExists);
    if (_not) {
      this.error("File not found", TechnologyPackage.Literals.TECHNOLOGY_IMPORT__IMPORT_URI);
    }
  }
  
  /**
   * Check that imported file defines a technology model
   */
  @Check
  public void checkImportType(final TechnologyImport technologyImport) {
    boolean _isImportOfType = DdmmUtils.<Technology>isImportOfType(technologyImport.eResource(), technologyImport.getImportURI(), 
      Technology.class);
    boolean _not = (!_isImportOfType);
    if (_not) {
      this.error("File does not contain a technology model definition", technologyImport, 
        TechnologyPackage.Literals.TECHNOLOGY_IMPORT__IMPORT_URI);
    }
  }
  
  /**
   * Check that technology does not import itself
   */
  @Check
  public void checkSelfImport(final TechnologyImport import_) {
    final Technology thisModelRoot = EcoreUtil2.<Technology>getContainerOfType(import_, Technology.class);
    final EList<EObject> importedModelRoots = DdmmUtils.getImportedModelContents(import_.eResource(), 
      import_.getImportURI());
    boolean _contains = importedModelRoots.contains(thisModelRoot);
    if (_contains) {
      this.error("Model must not import itself", import_, 
        TechnologyPackage.Literals.TECHNOLOGY_IMPORT__IMPORT_URI);
    }
  }
  
  /**
   * Check that there are not duplicates in the basic built-ins of a technology-specific primitive
   * type
   */
  @Check
  public void checkBascBuiltinsUnique(final TechnologySpecificPrimitiveType primitiveType) {
    final Function1<PrimitiveType, Class<?>> _function = (PrimitiveType it) -> {
      return it.getClass().getInterfaces()[0];
    };
    final List<Class<?>> basicBuiltins = ListExtensions.<PrimitiveType, Class<?>>map(primitiveType.getBasicBuiltinPrimitiveTypes(), _function);
    PrimitiveType duplicate = null;
    Integer duplicateIndex = null;
    int i = 0;
    while (((i < (basicBuiltins.size() - 1)) && (duplicate == null))) {
      {
        final Class<?> builtin = basicBuiltins.get(i);
        int n = (i + 1);
        while (((n < basicBuiltins.size()) && (duplicate == null))) {
          {
            final Class<?> builtinDuplicateToCheck = basicBuiltins.get(n);
            boolean _equals = Objects.equal(builtinDuplicateToCheck, builtin);
            if (_equals) {
              duplicate = primitiveType.getBasicBuiltinPrimitiveTypes().get(n);
              duplicateIndex = Integer.valueOf(n);
            }
            n++;
          }
        }
        i++;
      }
    }
    if ((duplicate != null)) {
      StringConcatenation _builder = new StringConcatenation();
      String _typeName = duplicate.getTypeName();
      _builder.append(_typeName);
      _builder.append(" is already a basic type for ");
      String _name = primitiveType.getName();
      _builder.append(_name);
      this.error(_builder.toString(), primitiveType, TechnologyPackage.Literals.TECHNOLOGY_SPECIFIC_PRIMITIVE_TYPE__BASIC_BUILTIN_PRIMITIVE_TYPES, (duplicateIndex).intValue());
    }
  }
  
  /**
   * Check that there is only one technology-specific primitive type that is marked as the default
   * for a built-in primitive type. Otherwise, the code generator could not unambiguously decide
   * which technology-specific primitive type to use, when no explicit mapping of a built-in
   * primitive types was specified.
   */
  @Check
  public void checkPrimitiveDefaultsUnique(final TechnologySpecificPrimitiveType primitiveType) {
    boolean _isDefault = primitiveType.isDefault();
    boolean _not = (!_isDefault);
    if (_not) {
      return;
    }
    final Function1<TechnologySpecificPrimitiveType, Boolean> _function = (TechnologySpecificPrimitiveType it) -> {
      return Boolean.valueOf((it.isDefault() && (it != primitiveType)));
    };
    final Iterable<TechnologySpecificPrimitiveType> otherDefaultPrimitiveTypes = IterableExtensions.<TechnologySpecificPrimitiveType>filter(primitiveType.getTechnology().getPrimitiveTypes(), _function);
    final Function1<PrimitiveType, Class<?>> _function_1 = (PrimitiveType it) -> {
      return it.getClass().getInterfaces()[0];
    };
    final List<Class<?>> primitiveTypeBuiltins = ListExtensions.<PrimitiveType, Class<?>>map(primitiveType.getBasicBuiltinPrimitiveTypes(), _function_1);
    TechnologySpecificPrimitiveType duplicateContainer = null;
    String duplicateName = null;
    Integer duplicateIndex = null;
    int i = 0;
    while (((i < IterableExtensions.size(otherDefaultPrimitiveTypes)) && (duplicateContainer == null))) {
      {
        final TechnologySpecificPrimitiveType otherDefaultPrimitiveType = ((TechnologySpecificPrimitiveType[])Conversions.unwrapArray(otherDefaultPrimitiveTypes, TechnologySpecificPrimitiveType.class))[i];
        final EList<PrimitiveType> otherBuiltins = otherDefaultPrimitiveType.getBasicBuiltinPrimitiveTypes();
        int n = 0;
        while (((n < otherBuiltins.size()) && (duplicateContainer == null))) {
          {
            final Class<?> otherBuiltin = otherBuiltins.get(n).getClass().getInterfaces()[0];
            boolean _contains = primitiveTypeBuiltins.contains(otherBuiltin);
            if (_contains) {
              duplicateContainer = otherDefaultPrimitiveType;
              duplicateName = otherBuiltins.get(n).getTypeName();
              duplicateIndex = Integer.valueOf(n);
            }
            n++;
          }
        }
        i++;
      }
    }
    if ((duplicateContainer != null)) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Duplicate default type: ");
      String _name = primitiveType.getName();
      _builder.append(_name);
      _builder.append(" is also specified as default ");
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("type for built-in primitive ");
      _builder_1.append(duplicateName);
      String _plus = (_builder.toString() + _builder_1);
      this.error(_plus, duplicateContainer, TechnologyPackage.Literals.TECHNOLOGY_SPECIFIC_PRIMITIVE_TYPE__BASIC_BUILTIN_PRIMITIVE_TYPES, (duplicateIndex).intValue());
    }
  }
  
  /**
   * Check that technology defines at least one default technology-specific primitive type for
   * each built-in primitive type. This ensures, that even if there is no mapping of a built-in
   * primitive type to a technology-specific one, we can deduce a technology-specific type for it
   * when code gets generated.
   */
  @Check
  public void checkPrimitiveDefaults(final Technology technology) {
    final boolean technologySpecifiesOtherTypes = (((!technology.getListTypes().isEmpty()) || 
      (!technology.getDataStructures().isEmpty())) || 
      (!(technology.getPrimitiveTypes().isEmpty() || IterableExtensions.<TechnologySpecificPrimitiveType>exists(technology.getPrimitiveTypes(), ((Function1<TechnologySpecificPrimitiveType, Boolean>) (TechnologySpecificPrimitiveType it) -> {
        return Boolean.valueOf(it.isDefault());
      })))));
    if ((!technologySpecifiesOtherTypes)) {
      return;
    }
    final Function1<TechnologySpecificPrimitiveType, Boolean> _function = (TechnologySpecificPrimitiveType it) -> {
      return Boolean.valueOf(it.isDefault());
    };
    final Function1<TechnologySpecificPrimitiveType, EList<PrimitiveType>> _function_1 = (TechnologySpecificPrimitiveType it) -> {
      return it.getBasicBuiltinPrimitiveTypes();
    };
    final Function1<PrimitiveType, Class<?>> _function_2 = (PrimitiveType it) -> {
      return it.getClass().getInterfaces()[0];
    };
    final List<Class<?>> specificDefaultPrimitivesBasics = IterableExtensions.<Class<?>>toList(IterableExtensions.<PrimitiveType, Class<?>>map(Iterables.<PrimitiveType>concat(IterableExtensions.<TechnologySpecificPrimitiveType, EList<PrimitiveType>>map(IterableExtensions.<TechnologySpecificPrimitiveType>filter(technology.getPrimitiveTypes(), _function), _function_1)), _function_2));
    boolean _isEmpty = specificDefaultPrimitivesBasics.isEmpty();
    if (_isEmpty) {
      this.error(("Technology must define at least one default primitive type for each built-in " + 
        "primitive type"), technology, TechnologyPackage.Literals.TECHNOLOGY__NAME);
      return;
    }
    final PrimitiveType primitiveTypeInstance = technology.getPrimitiveTypes().get(0).getBasicBuiltinPrimitiveTypes().get(0);
    final EList<Class<?>> builtinPrimitives = primitiveTypeInstance.getBuiltinPrimitiveTypes();
    boolean _containsAll = specificDefaultPrimitivesBasics.containsAll(builtinPrimitives);
    boolean _not = (!_containsAll);
    if (_not) {
      this.error(("Technology must define at least one default primitive type for each built-in " + 
        "primitive type"), technology, TechnologyPackage.Literals.TECHNOLOGY__NAME);
    }
  }
  
  /**
   * Check that there is exactly one default protocol for each communication type
   */
  @Check
  public void checkProtocolDefaults(final Technology technology) {
    this.checkProtocolsDefaults(technology, CommunicationType.SYNCHRONOUS);
    this.checkProtocolsDefaults(technology, CommunicationType.ASYNCHRONOUS);
  }
  
  /**
   * Convenience method to check protocol defaults
   */
  public void checkProtocolsDefaults(final Technology technology, final CommunicationType forCommunicationType) {
    boolean _isEmpty = technology.getProtocols().isEmpty();
    if (_isEmpty) {
      return;
    }
    String _switchResult = null;
    if (forCommunicationType != null) {
      switch (forCommunicationType) {
        case SYNCHRONOUS:
          _switchResult = "synchronous";
          break;
        case ASYNCHRONOUS:
          _switchResult = "asynchronous";
          break;
        default:
          _switchResult = "";
          break;
      }
    } else {
      _switchResult = "";
    }
    final String communicationTypeString = _switchResult;
    final Function1<Protocol, Boolean> _function = (Protocol it) -> {
      return Boolean.valueOf((it.isDefault() && Objects.equal(forCommunicationType, it.getCommunicationType())));
    };
    final Iterable<Protocol> definedDefaultProtocols = IterableExtensions.<Protocol>filter(technology.getProtocols(), _function);
    boolean _isEmpty_1 = IterableExtensions.isEmpty(definedDefaultProtocols);
    if (_isEmpty_1) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Technology must define at least one default ");
      _builder.append(communicationTypeString);
      _builder.append(" ");
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("protocol");
      String _plus = (_builder.toString() + _builder_1);
      this.error(_plus, technology, TechnologyPackage.Literals.TECHNOLOGY__NAME);
    } else {
      int _size = IterableExtensions.size(definedDefaultProtocols);
      boolean _greaterEqualsThan = (_size >= 2);
      if (_greaterEqualsThan) {
        StringConcatenation _builder_2 = new StringConcatenation();
        _builder_2.append("Technology may not define more than one default ");
        _builder_2.append(communicationTypeString);
        _builder_2.append(" ");
        StringConcatenation _builder_3 = new StringConcatenation();
        _builder_3.append("protocol");
        String _plus_1 = (_builder_2.toString() + _builder_3);
        this.error(_plus_1, ((EObject[])Conversions.unwrapArray(definedDefaultProtocols, EObject.class))[1], 
          TechnologyPackage.Literals.PROTOCOL__NAME);
      }
    }
  }
  
  /**
   * Check that data formats are unique _within_ a protocol (which is the reason why we do not
   * consider data formats in the unique names validator, because we do not want them to be
   * globally unique within the whole technology model)
   */
  @Check
  public void checkUniqueDataFormats(final DataFormat dataFormat) {
    final EList<DataFormat> allDataFormats = dataFormat.getProtocol().getDataFormats();
    int i = 0;
    boolean duplicateFound = false;
    DataFormat currentFormat = null;
    do {
      {
        currentFormat = allDataFormats.get(i);
        duplicateFound = ((!Objects.equal(currentFormat, dataFormat)) && 
          Objects.equal(currentFormat.getFormatName(), dataFormat.getFormatName()));
        i++;
      }
    } while(((!Objects.equal(currentFormat, dataFormat)) && (!duplicateFound)));
    if (duplicateFound) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Duplicate data format ");
      String _formatName = dataFormat.getFormatName();
      _builder.append(_formatName);
      this.error(_builder.toString(), dataFormat, 
        TechnologyPackage.Literals.DATA_FORMAT__FORMAT_NAME);
    }
  }
  
  /**
   * Check if compatibility entries exhibit ambiguous entries or duplicates
   */
  @Check
  public void checkCompatibilityMatrix(final Technology technology) {
    boolean _isEmpty = technology.getCompatibilityEntries().isEmpty();
    if (_isEmpty) {
      return;
    }
    final HashSet<String> entrySet = CollectionLiterals.<String>newHashSet();
    final Consumer<CompatibilityMatrixEntry> _function = (CompatibilityMatrixEntry entry) -> {
      final Consumer<PossiblyImportedTechnologySpecificType> _function_1 = (PossiblyImportedTechnologySpecificType compatibleType) -> {
        final String mappingTypeName = TypecheckingUtils.getTypeName(entry.getMappingType().getType());
        final String compatibleTypeName = TypecheckingUtils.getTypeName(compatibleType.getType());
        boolean ambiguousEntry = false;
        boolean duplicateEntry = false;
        CompatibilityDirection _direction = entry.getDirection();
        if (_direction != null) {
          switch (_direction) {
            case BIDIRECTIONAL:
              ambiguousEntry = ((!entrySet.add((mappingTypeName + compatibleTypeName))) || 
                (!entrySet.add((compatibleTypeName + mappingTypeName))));
              break;
            case COMPATIBLE_TYPES_TO_MAPPING:
              boolean _add = entrySet.add((compatibleTypeName + mappingTypeName));
              boolean _not = (!_add);
              duplicateEntry = _not;
              break;
            default:
              boolean _add_1 = entrySet.add((mappingTypeName + compatibleTypeName));
              boolean _not_1 = (!_add_1);
              duplicateEntry = _not_1;
              break;
          }
        } else {
          boolean _add_1 = entrySet.add((mappingTypeName + compatibleTypeName));
          boolean _not_1 = (!_add_1);
          duplicateEntry = _not_1;
        }
        String _xifexpression = null;
        if (ambiguousEntry) {
          _xifexpression = "Ambiguous entry";
        } else {
          String _xifexpression_1 = null;
          if (duplicateEntry) {
            _xifexpression_1 = "Duplicate entry";
          } else {
            _xifexpression_1 = null;
          }
          _xifexpression = _xifexpression_1;
        }
        final String errorMessage = _xifexpression;
        if ((errorMessage != null)) {
          this.error(errorMessage, entry, 
            TechnologyPackage.Literals.COMPATIBILITY_MATRIX_ENTRY__TECHNOLOGY);
        }
      };
      entry.getCompatibleTypes().forEach(_function_1);
    };
    technology.getCompatibilityEntries().forEach(_function);
  }
  
  /**
   * Check that self-compatibility of types is not explicitly described
   */
  @Check
  public void checkTypeSelfCompatibility(final CompatibilityMatrixEntry entry) {
    if (((entry.getMappingType() == null) || (entry.getCompatibleTypes() == null))) {
      return;
    }
    final String mappingTypeName = TypecheckingUtils.getTypeName(entry.getMappingType().getType());
    final Function1<PossiblyImportedTechnologySpecificType, String> _function = (PossiblyImportedTechnologySpecificType it) -> {
      return TypecheckingUtils.getTypeName(it.getType());
    };
    final List<String> compatibleTypeNames = ListExtensions.<PossiblyImportedTechnologySpecificType, String>map(entry.getCompatibleTypes(), _function);
    boolean _contains = compatibleTypeNames.contains(mappingTypeName);
    if (_contains) {
      this.error("Self-compatibility of types must not be described", entry, 
        TechnologyPackage.Literals.COMPATIBILITY_MATRIX_ENTRY__TECHNOLOGY);
    }
  }
  
  /**
   * For imported types, only the forms "imported compatible types -> local mapping type" or
   * "local compatible types <- imported mapping type" is allowed. That is, the compatibility
   * matrix must declare which imported types may be converted _into_ its types. A bidirectional
   * compatibility direction is prevented, because then all imported technology models must be
   * traversed to decide whether a compatibility entry exists. Furthermore, for an entry with
   * imported types it must always be declared that imported types are convertible into local
   * types. This follows the direction of an initialized parameter of a microservices that has a
   * technology assigned.
   */
  @Check
  public void checkImportedTypeCompatibilityDirection(final PossiblyImportedTechnologySpecificType type) {
    TechnologyImport _import = type.getImport();
    boolean _tripleEquals = (_import == null);
    if (_tripleEquals) {
      return;
    }
    final CompatibilityMatrixEntry containingEntry = EcoreUtil2.<CompatibilityMatrixEntry>getContainerOfType(type, CompatibilityMatrixEntry.class);
    final PossiblyImportedTechnologySpecificType mappingType = containingEntry.getMappingType();
    final EList<PossiblyImportedTechnologySpecificType> compatibleTypes = containingEntry.getCompatibleTypes();
    final CompatibilityDirection direction = containingEntry.getDirection();
    final boolean conversionFromImportedToLocal = ((Objects.equal(mappingType, type) && 
      (direction == CompatibilityDirection.MAPPING_TO_COMPATIBLE_TYPES)) || 
      (compatibleTypes.contains(type) && 
        (direction == CompatibilityDirection.COMPATIBLE_TYPES_TO_MAPPING)));
    if ((!conversionFromImportedToLocal)) {
      this.error("Compatibility entry must describe conversion from imported to local types", containingEntry, TechnologyPackage.Literals.COMPATIBILITY_MATRIX_ENTRY__DIRECTION);
    }
  }
  
  /**
   * Warn, if an entry of the compatibility matrix, that maps two technology-specific primitive
   * types with basic built-in types, overrides built-in type conversion rules
   */
  @Check
  public void checkCompatibilityEntryOverridesBuiltinCoompatibilityRules(final CompatibilityMatrixEntry entry) {
    PossiblyImportedTechnologySpecificType _mappingType = entry.getMappingType();
    boolean _not = (!(_mappingType instanceof TechnologySpecificPrimitiveType));
    if (_not) {
      return;
    }
    PossiblyImportedTechnologySpecificType _mappingType_1 = entry.getMappingType();
    final TechnologySpecificPrimitiveType mappingPrimitiveType = ((TechnologySpecificPrimitiveType) _mappingType_1);
    boolean _isEmpty = mappingPrimitiveType.getBasicBuiltinPrimitiveTypes().isEmpty();
    if (_isEmpty) {
      return;
    }
    final Function1<PossiblyImportedTechnologySpecificType, Boolean> _function = (PossiblyImportedTechnologySpecificType it) -> {
      return Boolean.valueOf(((it instanceof TechnologySpecificPrimitiveType) && 
        (!((TechnologySpecificPrimitiveType) it).getBasicBuiltinPrimitiveTypes().isEmpty())));
    };
    final Function1<PossiblyImportedTechnologySpecificType, TechnologySpecificPrimitiveType> _function_1 = (PossiblyImportedTechnologySpecificType it) -> {
      return ((TechnologySpecificPrimitiveType) it);
    };
    final List<TechnologySpecificPrimitiveType> compatiblePrimitiveTypes = IterableExtensions.<TechnologySpecificPrimitiveType>toList(IterableExtensions.<PossiblyImportedTechnologySpecificType, TechnologySpecificPrimitiveType>map(IterableExtensions.<PossiblyImportedTechnologySpecificType>filter(entry.getCompatibleTypes(), _function), _function_1));
    boolean _isEmpty_1 = compatiblePrimitiveTypes.isEmpty();
    if (_isEmpty_1) {
      return;
    }
    final StringBuilder overriddenDefaultsString = new StringBuilder();
    final Consumer<TechnologySpecificPrimitiveType> _function_2 = (TechnologySpecificPrimitiveType it) -> {
      final HashMap<PrimitiveType, List<PrimitiveType>> compatibilityChecksTodo = this.buildCanonicalCompatibilityCheckMap(
        mappingPrimitiveType.getBasicBuiltinPrimitiveTypes(), it.getBasicBuiltinPrimitiveTypes(), 
        entry.getDirection());
      final BiConsumer<PrimitiveType, List<PrimitiveType>> _function_3 = (PrimitiveType basicType, List<PrimitiveType> typesToCheck) -> {
        final Consumer<PrimitiveType> _function_4 = (PrimitiveType typeToCheck) -> {
          boolean _isCompatibleWith = basicType.isCompatibleWith(typeToCheck);
          if (_isCompatibleWith) {
            StringConcatenation _builder = new StringConcatenation();
            String _typeName = typeToCheck.getTypeName();
            _builder.append(_typeName);
            _builder.append(" to ");
            String _typeName_1 = basicType.getTypeName();
            _builder.append(_typeName_1);
            _builder.append(", ");
            overriddenDefaultsString.append(_builder);
          }
        };
        typesToCheck.forEach(_function_4);
      };
      compatibilityChecksTodo.forEach(_function_3);
    };
    compatiblePrimitiveTypes.forEach(_function_2);
    final int overriddenStringLength = overriddenDefaultsString.length();
    if ((overriddenStringLength > 0)) {
      String _substring = overriddenDefaultsString.toString().substring(0, (overriddenStringLength - 2));
      final String message = ("Entry corresponds to built-in primitive conversion rules " + _substring);
      this.warning(message, entry, 
        TechnologyPackage.Literals.COMPATIBILITY_MATRIX_ENTRY__TECHNOLOGY);
    }
  }
  
  /**
   * Helper method to build a map of a canonical representation for checking of a compatibility
   * matrix entry overrides a built-in type conversion rule
   */
  public HashMap<PrimitiveType, List<PrimitiveType>> buildCanonicalCompatibilityCheckMap(final List<PrimitiveType> mappingTypes, final List<PrimitiveType> compatibleTypes, final CompatibilityDirection direction) {
    final HashMap<PrimitiveType, List<PrimitiveType>> canonicalCheckMap = CollectionLiterals.<PrimitiveType, List<PrimitiveType>>newHashMap();
    final Consumer<PrimitiveType> _function = (PrimitiveType mappingType) -> {
      final Consumer<PrimitiveType> _function_1 = (PrimitiveType compatibleType) -> {
        if ((direction == CompatibilityDirection.MAPPING_TO_COMPATIBLE_TYPES)) {
          canonicalCheckMap.putIfAbsent(compatibleType, CollectionLiterals.<PrimitiveType>newArrayList());
          canonicalCheckMap.get(compatibleType).add(mappingType);
        } else {
          if ((direction == CompatibilityDirection.COMPATIBLE_TYPES_TO_MAPPING)) {
            canonicalCheckMap.putIfAbsent(mappingType, CollectionLiterals.<PrimitiveType>newArrayList());
            canonicalCheckMap.get(mappingType).add(compatibleType);
          } else {
            if ((direction == CompatibilityDirection.BIDIRECTIONAL)) {
              canonicalCheckMap.putIfAbsent(compatibleType, CollectionLiterals.<PrimitiveType>newArrayList());
              canonicalCheckMap.get(compatibleType).add(mappingType);
              canonicalCheckMap.putIfAbsent(mappingType, CollectionLiterals.<PrimitiveType>newArrayList());
              canonicalCheckMap.get(mappingType).add(compatibleType);
            }
          }
        }
      };
      compatibleTypes.forEach(_function_1);
    };
    mappingTypes.forEach(_function);
    return canonicalCheckMap;
  }
  
  /**
   * Check that the assigned default value of a technology-specific property matches its type
   */
  @Check
  public void checkDefaultValueType(final PrimitiveValue defaultValue) {
    final TechnologySpecificProperty property = EcoreUtil2.<TechnologySpecificProperty>getContainerOfType(defaultValue, TechnologySpecificProperty.class);
    if (((property != null) && (!defaultValue.isOfType(property.getType())))) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Value is not of type ");
      String _typeName = property.getType().getTypeName();
      _builder.append(_typeName);
      _builder.append(" ");
      this.error(_builder.toString(), property, 
        TechnologyPackage.Literals.TECHNOLOGY_SPECIFIC_PROPERTY__DEFAULT_VALUE);
    }
  }
  
  /**
   * Check uniqueness of operation environments' names in an operation technology
   */
  @Check
  public void checkOperationEnvironmentsUniqueNames(final OperationTechnology operationTechnology) {
    final EList<OperationEnvironment> operationEnvironments = operationTechnology.getOperationEnvironments();
    final Function<OperationEnvironment, String> _function = (OperationEnvironment it) -> {
      return it.getEnvironmentName();
    };
    final Integer duplicateIndex = DdmmUtils.<OperationEnvironment, String>getDuplicateIndex(operationEnvironments, _function);
    if (((duplicateIndex).intValue() > (-1))) {
      final OperationEnvironment duplicateEnvironment = operationEnvironments.get((duplicateIndex).intValue());
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Duplicate operation environment ");
      String _environmentName = duplicateEnvironment.getEnvironmentName();
      _builder.append(_environmentName);
      this.error(_builder.toString(), duplicateEnvironment, 
        TechnologyPackage.Literals.OPERATION_ENVIRONMENT__ENVIRONMENT_NAME, (duplicateIndex).intValue());
    }
  }
  
  /**
   * Check that there is exactly one default operation environment, if more than on environment
   * is specified for an operation technology
   */
  @Check
  public void checkOperationEnvironmentsDefault(final OperationTechnology operationTechnology) {
    final EList<OperationEnvironment> operationEnvironments = operationTechnology.getOperationEnvironments();
    int _size = operationEnvironments.size();
    boolean _lessEqualsThan = (_size <= 1);
    if (_lessEqualsThan) {
      return;
    } else {
      final Function1<OperationEnvironment, Boolean> _function = (OperationEnvironment it) -> {
        return Boolean.valueOf(it.isDefault());
      };
      boolean _exists = IterableExtensions.<OperationEnvironment>exists(operationEnvironments, _function);
      boolean _not = (!_exists);
      if (_not) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("There must be exactly one default environment");
        this.error(_builder.toString(), operationTechnology, TechnologyPackage.Literals.OPERATION_TECHNOLOGY__NAME);
      }
    }
    final Function<OperationEnvironment, Boolean> _function_1 = (OperationEnvironment it) -> {
      return Boolean.valueOf(it.isDefault());
    };
    final Predicate<OperationEnvironment> _function_2 = (OperationEnvironment it) -> {
      boolean _isDefault = it.isDefault();
      return (Boolean.valueOf(_isDefault) == Boolean.valueOf(true));
    };
    final Integer duplicateDefaultIndex = DdmmUtils.<OperationEnvironment, Boolean>getDuplicateIndex(operationEnvironments, _function_1, _function_2);
    if (((duplicateDefaultIndex).intValue() > (-1))) {
      final OperationEnvironment duplicateEnvironment = operationEnvironments.get((duplicateDefaultIndex).intValue());
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("There may only be one default environment");
      this.error(_builder_1.toString(), duplicateEnvironment, TechnologyPackage.Literals.OPERATION_ENVIRONMENT__DEFAULT, (duplicateDefaultIndex).intValue());
    }
  }
  
  /**
   * Check uniqueness of service properties' names in an operation technology
   */
  @Check
  public void checkServicePropertiesUniqueNames(final OperationTechnology operationTechnology) {
    final EList<TechnologySpecificProperty> serviceProperties = operationTechnology.getServiceProperties();
    final Function<TechnologySpecificProperty, String> _function = (TechnologySpecificProperty it) -> {
      return it.getName();
    };
    final Integer duplicateIndex = DdmmUtils.<TechnologySpecificProperty, String>getDuplicateIndex(serviceProperties, _function);
    if (((duplicateIndex).intValue() > (-1))) {
      final TechnologySpecificProperty duplicateProperty = serviceProperties.get((duplicateIndex).intValue());
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Duplicate service property ");
      String _name = duplicateProperty.getName();
      _builder.append(_name);
      this.error(_builder.toString(), duplicateProperty, TechnologyPackage.Literals.TECHNOLOGY_SPECIFIC_PROPERTY__NAME);
    }
  }
  
  /**
   * Check that per type only one pointcut exists in a service aspect selector
   */
  @Check
  public void checkPointcutUniqueness(final ServiceAspectPointcutSelector selector) {
    final Function<ServiceAspectPointcut, PointcutType> _function = (ServiceAspectPointcut it) -> {
      return it.getEffectiveType();
    };
    final Integer duplicateIndex = DdmmUtils.<ServiceAspectPointcut, PointcutType>getDuplicateIndex(selector.getPointcuts(), _function);
    if (((duplicateIndex).intValue() > (-1))) {
      final ServiceAspectPointcut duplicatePoincut = selector.getPointcuts().get((duplicateIndex).intValue());
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Duplicate pointcut ");
      String _effectiveSelectorName = duplicatePoincut.getEffectiveSelectorName();
      _builder.append(_effectiveSelectorName);
      this.error(_builder.toString(), 
        TechnologyPackage.Literals.SERVICE_ASPECT_POINTCUT_SELECTOR__POINTCUTS, (duplicateIndex).intValue());
    }
  }
  
  /**
   * Check aspect uniqueness considering different types of aspects and join points
   */
  @Check
  public void checkAspectUniqueness(final Technology technologyModel) {
    ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, 2, true);
    for (final Integer i : _doubleDotLessThan) {
      {
        EList<? extends TechnologyAspect> _switchResult = null;
        if (i != null) {
          switch (i) {
            case 0:
              _switchResult = technologyModel.getServiceAspects();
              break;
            case 1:
              _switchResult = technologyModel.getOperationAspects();
              break;
          }
        }
        final EList<? extends TechnologyAspect> aspects = _switchResult;
        final HashMap<String, List<TechnologyAspect>> nameToAspectsMap = CollectionLiterals.<String, List<TechnologyAspect>>newHashMap();
        final Consumer<TechnologyAspect> _function = (TechnologyAspect it) -> {
          List<TechnologyAspect> aspectsList = nameToAspectsMap.get(it.getName());
          if ((aspectsList == null)) {
            aspectsList = CollectionLiterals.<TechnologyAspect>newArrayList();
            nameToAspectsMap.put(it.getName(), aspectsList);
          }
          aspectsList.add(it);
        };
        aspects.forEach(_function);
        final Function1<Map.Entry<String, List<TechnologyAspect>>, Boolean> _function_1 = (Map.Entry<String, List<TechnologyAspect>> it) -> {
          int _size = it.getValue().size();
          return Boolean.valueOf((_size > 1));
        };
        final Consumer<Map.Entry<String, List<TechnologyAspect>>> _function_2 = (Map.Entry<String, List<TechnologyAspect>> it) -> {
          final List<TechnologyAspect> eponymousAspects = it.getValue();
          final HashSet<JoinPointType> uniqueJoinPoints = CollectionLiterals.<JoinPointType>newHashSet();
          final Consumer<TechnologyAspect> _function_3 = (TechnologyAspect aspect) -> {
            final Consumer<JoinPointType> _function_4 = (JoinPointType joinPoint) -> {
              boolean _add = uniqueJoinPoints.add(joinPoint);
              final boolean duplicateJoinPoint = (!_add);
              if (duplicateJoinPoint) {
                StringConcatenation _builder = new StringConcatenation();
                _builder.append("Duplicate aspect ");
                String _name = aspect.getName();
                _builder.append(_name);
                _builder.append(" for join point ");
                StringConcatenation _builder_1 = new StringConcatenation();
                String _lowerCase = joinPoint.getName().toLowerCase();
                _builder_1.append(_lowerCase);
                String _plus = (_builder.toString() + _builder_1);
                this.error(_plus, aspect, 
                  TechnologyPackage.Literals.TECHNOLOGY_ASPECT__NAME);
              }
            };
            aspect.getJoinPoints().forEach(_function_4);
          };
          eponymousAspects.forEach(_function_3);
        };
        IterableExtensions.<Map.Entry<String, List<TechnologyAspect>>>filter(nameToAspectsMap.entrySet(), _function_1).forEach(_function_2);
      }
    }
  }
  
  /**
   * Check that join points of an aspect are unique
   */
  @Check
  public void checkJoinPointUniqueness(final TechnologyAspect aspect) {
    final Function<JoinPointType, JoinPointType> _function = (JoinPointType it) -> {
      return it;
    };
    final Integer duplicateIndex = DdmmUtils.<JoinPointType, JoinPointType>getDuplicateIndex(aspect.getJoinPoints(), _function);
    if (((duplicateIndex).intValue() > (-1))) {
      this.error("Duplicate join point", 
        TechnologyPackage.Literals.TECHNOLOGY_ASPECT__JOIN_POINTS, (duplicateIndex).intValue());
    }
  }
  
  /**
   * Check that properties of an aspect are unique
   */
  @Check
  public void checkPropertyUniqueness(final TechnologyAspect aspect) {
    final Function<TechnologySpecificProperty, String> _function = (TechnologySpecificProperty it) -> {
      return it.getName();
    };
    final Integer duplicateIndex = DdmmUtils.<TechnologySpecificProperty, String>getDuplicateIndex(aspect.getProperties(), _function);
    if (((duplicateIndex).intValue() > (-1))) {
      this.error("Duplicate property", 
        TechnologyPackage.Literals.TECHNOLOGY_ASPECT__PROPERTIES, (duplicateIndex).intValue());
    }
  }
  
  /**
   * Check that selectors of a service aspect are unique
   */
  @Check
  public void checkSelectorUniqueness(final ServiceAspect aspect) {
    final Function<ServiceAspectPointcutSelector, String> _function = (ServiceAspectPointcutSelector it) -> {
      return it.getSelectorString();
    };
    final Integer duplicateIndex = DdmmUtils.<ServiceAspectPointcutSelector, String>getDuplicateIndex(aspect.getPointcutSelectors(), _function);
    if (((duplicateIndex).intValue() > (-1))) {
      this.error("Duplicate selector", 
        TechnologyPackage.Literals.SERVICE_ASPECT__POINTCUT_SELECTORS, (duplicateIndex).intValue());
    }
  }
  
  /**
   * Check that "exchange pattern" or "communication type" pointcut is specified in conjunction
   * with "parameters" or "data fields" join point
   */
  @Check
  public void checkParametersPointcut(final ServiceAspectPointcut pointcut) {
    if (((pointcut.getEffectiveType() != PointcutType.EXCHANGE_PATTERN) && 
      (pointcut.getEffectiveType() != PointcutType.COMMUNICATION_TYPE))) {
      return;
    }
    final EList<JoinPointType> joinPoints = pointcut.getSelector().getServiceAspect().getJoinPoints();
    final List<JoinPointType> allowedJoinPoints = Collections.<JoinPointType>unmodifiableList(CollectionLiterals.<JoinPointType>newArrayList(JoinPointType.PARAMETERS, JoinPointType.DATA_FIELDS));
    final Function1<JoinPointType, Boolean> _function = (JoinPointType it) -> {
      return Boolean.valueOf(allowedJoinPoints.contains(it));
    };
    boolean _exists = IterableExtensions.<JoinPointType>exists(joinPoints, _function);
    boolean _not = (!_exists);
    if (_not) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Pointcut \"");
      String _effectiveSelectorName = pointcut.getEffectiveSelectorName();
      _builder.append(_effectiveSelectorName);
      _builder.append("\" may only be specified in ");
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("conjunction with join point \"parameters\" or \"fields\"");
      String _plus = (_builder.toString() + _builder_1);
      this.error(_plus, pointcut, 
        TechnologyPackage.Literals.SERVICE_ASPECT_POINTCUT__SELECTOR);
    }
  }
  
  /**
   * Warn if pointcut selector is more generic than other
   */
  @Check
  public void warnIfSelectorsIsMoreGeneric(final ServiceAspectPointcutSelector selector) {
    final Function1<ServiceAspectPointcutSelector, Boolean> _function = (ServiceAspectPointcutSelector it) -> {
      return Boolean.valueOf((!Objects.equal(it, selector)));
    };
    final Iterable<ServiceAspectPointcutSelector> otherSelectors = IterableExtensions.<ServiceAspectPointcutSelector>filter(selector.getServiceAspect().getPointcutSelectors(), _function);
    final Consumer<ServiceAspectPointcutSelector> _function_1 = (ServiceAspectPointcutSelector it) -> {
      boolean _isMoreGenericThan = selector.isMoreGenericThan(it);
      if (_isMoreGenericThan) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Selector \"");
        String _selectorString = selector.getSelectorString();
        _builder.append(_selectorString);
        _builder.append("\" is more generic");
        this.warning(_builder.toString(), it, 
          TechnologyPackage.Literals.SERVICE_ASPECT_POINTCUT_SELECTOR__SELECTOR_STRING);
      }
    };
    otherSelectors.forEach(_function_1);
  }
}
