/**
 * generated by Xtext 2.12.0
 */
package de.fhdo.ddmm.data.validation;

import com.google.common.base.Function;
import de.fhdo.ddmm.data.ComplexTypeImport;
import de.fhdo.ddmm.data.DataField;
import de.fhdo.ddmm.data.DataModel;
import de.fhdo.ddmm.data.DataPackage;
import de.fhdo.ddmm.data.DataStructure;
import de.fhdo.ddmm.data.Type;
import de.fhdo.ddmm.data.Version;
import de.fhdo.ddmm.data.validation.AbstractDataDslValidator;
import de.fhdo.ddmm.utils.DdmmUtils;
import java.util.List;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.ListExtensions;

/**
 * This class contains validation rules for the Data DSL.
 * 
 * @author <a href="mailto:florian.rademacher@fh-dortmund.de">Florian Rademacher</a>
 */
@SuppressWarnings("all")
public class DataDslValidator extends AbstractDataDslValidator {
  /**
   * Check import aliases for uniqueness. Normally, this should be done by
   * DataDslNamesAreUniqueValidationHelper, but it does not react to
   */
  @Check
  public void checkImportAlias(final DataModel dataModel) {
    final Function<ComplexTypeImport, String> _function = (ComplexTypeImport it) -> {
      return it.getName();
    };
    final Integer duplicateIndex = DdmmUtils.<ComplexTypeImport, String>getDuplicateIndex(dataModel.getComplexTypeImports(), _function);
    if (((duplicateIndex).intValue() == (-1))) {
      return;
    }
    final ComplexTypeImport duplicate = dataModel.getComplexTypeImports().get((duplicateIndex).intValue());
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("Duplicate import alias ");
    String _name = duplicate.getName();
    _builder.append(_name);
    this.error(_builder.toString(), duplicate, 
      DataPackage.Literals.COMPLEX_TYPE_IMPORT__NAME);
  }
  
  /**
   * Check that imported file is imported exactly once
   */
  @Check
  public void checkImportFileUniqueness(final DataModel dataModel) {
    final Function<ComplexTypeImport, String> _function = (ComplexTypeImport it) -> {
      return it.getImportURI();
    };
    final Integer duplicateIndex = DdmmUtils.<ComplexTypeImport, String>getDuplicateIndex(dataModel.getComplexTypeImports(), _function);
    if (((duplicateIndex).intValue() == (-1))) {
      return;
    }
    final ComplexTypeImport duplicate = dataModel.getComplexTypeImports().get((duplicateIndex).intValue());
    this.error("File is already being imported", duplicate, 
      DataPackage.Literals.COMPLEX_TYPE_IMPORT__IMPORT_URI);
  }
  
  /**
   * Check that imported file defines a data model
   */
  @Check
  public void checkImportType(final ComplexTypeImport complexTypeImport) {
    boolean _isImportOfType = DdmmUtils.<DataModel>isImportOfType(complexTypeImport.eResource(), complexTypeImport.getImportURI(), 
      DataModel.class);
    boolean _not = (!_isImportOfType);
    if (_not) {
      this.error("File does not contain a data model definition", complexTypeImport, 
        DataPackage.Literals.COMPLEX_TYPE_IMPORT__IMPORT_URI);
    }
  }
  
  /**
   * Perform checks on data fields
   */
  @Check
  public void checkDataField(final DataField dataField) {
    if (((dataField.getEffectiveType() == null) && (!dataField.isHidden()))) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Field must have a type or be hidden");
      this.error(_builder.toString(), dataField, 
        DataPackage.Literals.DATA_FIELD__NAME);
      return;
    }
    final DataField equalSuperField = dataField.findEponymousSuperField();
    if (((equalSuperField == null) || equalSuperField.isHidden())) {
      Type _effectiveType = dataField.getEffectiveType();
      boolean _tripleEquals = (_effectiveType == null);
      if (_tripleEquals) {
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("Field must have a type");
        this.error(_builder_1.toString(), dataField, 
          DataPackage.Literals.DATA_FIELD__NAME);
      }
    } else {
      if (((equalSuperField != null) && (!equalSuperField.isHidden()))) {
        String superQualifiedName = QualifiedName.create(equalSuperField.getQualifiedNameParts()).toString();
        Type _effectiveType_1 = dataField.getEffectiveType();
        boolean _tripleNotEquals = (_effectiveType_1 != null);
        if (_tripleNotEquals) {
          StringConcatenation _builder_2 = new StringConcatenation();
          _builder_2.append("Field cannot redefine inherited field ");
          _builder_2.append(superQualifiedName);
          _builder_2.append(" ");
          this.error(_builder_2.toString(), dataField, 
            DataPackage.Literals.DATA_FIELD__NAME);
        }
      }
    }
  }
  
  /**
   * Check if an imported file exists
   */
  @Check
  public void checkImportFileExists(final ComplexTypeImport complexTypeImport) {
    boolean _importFileExists = DdmmUtils.importFileExists(complexTypeImport.eResource(), complexTypeImport.getImportURI());
    boolean _not = (!_importFileExists);
    if (_not) {
      this.error("File not found", complexTypeImport, 
        DataPackage.Literals.COMPLEX_TYPE_IMPORT__IMPORT_URI);
    }
  }
  
  /**
   * Check for cyclic inheritance relationships between data structures
   */
  @Check
  public void checkCyclicInheritance(final DataStructure dataStructure) {
    final Function<DataStructure, DataStructure> _function = (DataStructure it) -> {
      return it.getSuper();
    };
    boolean _hasCyclicInheritance = DdmmUtils.<DataStructure>hasCyclicInheritance(dataStructure, _function);
    if (_hasCyclicInheritance) {
      this.error("Cyclic inheritance detected", dataStructure, 
        DataPackage.Literals.COMPLEX_TYPE__NAME);
    }
  }
  
  /**
   * Check for cyclic imports (non-transitive)
   */
  @Check
  public void checkForCyclicImports(final ComplexTypeImport complexTypeImport) {
    final Function<DataModel, List<Resource>> _function = (DataModel it) -> {
      final Function1<ComplexTypeImport, Resource> _function_1 = (ComplexTypeImport it_1) -> {
        return EcoreUtil2.getResource(it_1.eResource(), it_1.getImportURI());
      };
      return ListExtensions.<ComplexTypeImport, Resource>map(it.getComplexTypeImports(), _function_1);
    };
    final Function<DataModel, List<Resource>> getImportedDataModelResources = _function;
    boolean _isCyclicImport = DdmmUtils.<ComplexTypeImport, DataModel>isCyclicImport(complexTypeImport, DataModel.class, getImportedDataModelResources);
    if (_isCyclicImport) {
      this.error("Cyclic import detected", complexTypeImport, 
        DataPackage.Literals.COMPLEX_TYPE_IMPORT__IMPORT_URI);
    }
  }
  
  /**
   * Check versions for non-emptyness
   */
  @Check
  public void checkVersionNotEmpty(final Version version) {
    if ((version.getContexts().isEmpty() && version.getComplexTypes().isEmpty())) {
      this.error("A version must define at least one context or complex type", version, 
        DataPackage.Literals.VERSION__NAME);
    }
  }
}
