/**
 * generated by Xtext 2.12.0
 */
package de.fhdo.lemma.technology.mappingdsl.scoping;

import com.google.common.base.Function;
import com.google.common.base.Objects;
import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;
import de.fhdo.lemma.data.CollectionType;
import de.fhdo.lemma.data.ComplexType;
import de.fhdo.lemma.data.DataModel;
import de.fhdo.lemma.data.DataStructure;
import de.fhdo.lemma.data.Enumeration;
import de.fhdo.lemma.data.PrimitiveType;
import de.fhdo.lemma.data.Type;
import de.fhdo.lemma.service.Import;
import de.fhdo.lemma.service.ImportType;
import de.fhdo.lemma.service.ImportedType;
import de.fhdo.lemma.service.Interface;
import de.fhdo.lemma.service.Microservice;
import de.fhdo.lemma.service.Operation;
import de.fhdo.lemma.service.Parameter;
import de.fhdo.lemma.service.ReferredOperation;
import de.fhdo.lemma.service.ServiceModel;
import de.fhdo.lemma.service.ServicePackage;
import de.fhdo.lemma.service.TechnologyReference;
import de.fhdo.lemma.technology.CommunicationType;
import de.fhdo.lemma.technology.DataFormat;
import de.fhdo.lemma.technology.ExchangePattern;
import de.fhdo.lemma.technology.JoinPointType;
import de.fhdo.lemma.technology.Protocol;
import de.fhdo.lemma.technology.ServiceAspect;
import de.fhdo.lemma.technology.Technology;
import de.fhdo.lemma.technology.TechnologyPackage;
import de.fhdo.lemma.technology.TechnologySpecificCollectionType;
import de.fhdo.lemma.technology.TechnologySpecificDataStructure;
import de.fhdo.lemma.technology.TechnologySpecificPrimitiveType;
import de.fhdo.lemma.technology.TechnologySpecificPropertyValueAssignment;
import de.fhdo.lemma.technology.mapping.ComplexParameterMapping;
import de.fhdo.lemma.technology.mapping.ComplexTypeMapping;
import de.fhdo.lemma.technology.mapping.DataOperationMapping;
import de.fhdo.lemma.technology.mapping.DataOperationParameterMapping;
import de.fhdo.lemma.technology.mapping.DataOperationReturnTypeMapping;
import de.fhdo.lemma.technology.mapping.ImportedComplexTypeToMap;
import de.fhdo.lemma.technology.mapping.ImportedMicroservice;
import de.fhdo.lemma.technology.mapping.InterfaceMapping;
import de.fhdo.lemma.technology.mapping.MappingPackage;
import de.fhdo.lemma.technology.mapping.MicroserviceMapping;
import de.fhdo.lemma.technology.mapping.OperationMapping;
import de.fhdo.lemma.technology.mapping.ParameterMapping;
import de.fhdo.lemma.technology.mapping.PrimitiveParameterMapping;
import de.fhdo.lemma.technology.mapping.ReferredOperationMapping;
import de.fhdo.lemma.technology.mapping.TechnologyMapping;
import de.fhdo.lemma.technology.mapping.TechnologySpecificEndpoint;
import de.fhdo.lemma.technology.mapping.TechnologySpecificFieldMapping;
import de.fhdo.lemma.technology.mapping.TechnologySpecificImportedServiceAspect;
import de.fhdo.lemma.technology.mapping.TechnologySpecificProtocol;
import de.fhdo.lemma.technology.mapping.TechnologySpecificProtocolSpecification;
import de.fhdo.lemma.utils.LemmaUtils;
import java.util.AbstractCollection;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.ExclusiveRange;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.Pair;

/**
 * This class implements a custom scope provider for the Mapping DSL.
 * 
 * @author <a href="mailto:florian.rademacher@fh-dortmund.de">Florian Rademacher</a>
 */
@SuppressWarnings("all")
public class MappingDslScopeProvider extends AbstractMappingDslScopeProvider {
  /**
   * Build scope for a given context and a given reference
   */
  @Override
  public IScope getScope(final EObject context, final EReference reference) {
    IScope _switchResult = null;
    boolean _matched = false;
    if (context instanceof ImportedComplexTypeToMap) {
      _matched=true;
      _switchResult = this.getScope(((ImportedComplexTypeToMap)context), reference);
    }
    if (!_matched) {
      if (context instanceof ComplexTypeMapping) {
        _matched=true;
        _switchResult = this.getScope(((ComplexTypeMapping)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof DataOperationMapping) {
        _matched=true;
        _switchResult = this.getScope(((DataOperationMapping)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof DataOperationReturnTypeMapping) {
        _matched=true;
        _switchResult = this.getScope(((DataOperationReturnTypeMapping)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof DataOperationParameterMapping) {
        _matched=true;
        _switchResult = this.getScope(((DataOperationParameterMapping)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof MicroserviceMapping) {
        _matched=true;
        _switchResult = this.getScope(((MicroserviceMapping)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof TechnologyReference) {
        _matched=true;
        _switchResult = this.getScope(((TechnologyReference)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof ImportedMicroservice) {
        _matched=true;
        _switchResult = this.getScope(((ImportedMicroservice)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof TechnologySpecificProtocolSpecification) {
        _matched=true;
        _switchResult = this.getScope(((TechnologySpecificProtocolSpecification)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof TechnologySpecificProtocol) {
        _matched=true;
        _switchResult = this.getScope(((TechnologySpecificProtocol)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof TechnologySpecificEndpoint) {
        _matched=true;
        _switchResult = this.getScope(((TechnologySpecificEndpoint)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof InterfaceMapping) {
        _matched=true;
        _switchResult = this.getScope(((InterfaceMapping)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof OperationMapping) {
        _matched=true;
        _switchResult = this.getScope(((OperationMapping)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof ReferredOperationMapping) {
        _matched=true;
        _switchResult = this.getScope(((ReferredOperationMapping)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof PrimitiveParameterMapping) {
        _matched=true;
        _switchResult = this.getScope(((PrimitiveParameterMapping)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof ComplexParameterMapping) {
        _matched=true;
        _switchResult = this.getScope(((ComplexParameterMapping)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof TechnologySpecificFieldMapping) {
        _matched=true;
        _switchResult = this.getScope(((TechnologySpecificFieldMapping)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof TechnologySpecificImportedServiceAspect) {
        _matched=true;
        _switchResult = this.getScope(((TechnologySpecificImportedServiceAspect)context), reference);
      }
    }
    if (!_matched) {
      if (context instanceof TechnologySpecificPropertyValueAssignment) {
        _matched=true;
        _switchResult = this.getScope(((TechnologySpecificPropertyValueAssignment)context), reference);
      }
    }
    final IScope scope = _switchResult;
    if ((scope != null)) {
      return scope;
    } else {
      if ((scope == null)) {
        return super.getScope(context, reference);
      }
    }
    return null;
  }
  
  /**
   * Build scope for imported complex types to map
   */
  private IScope getScope(final ImportedComplexTypeToMap type, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.IMPORTED_COMPLEX_TYPE_TO_MAP__SERVICE_MODEL_IMPORT)) {
      _matched=true;
      return this.getScopeForImportsOfType(type.getTypeMapping(), ServiceModel.class);
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.IMPORTED_COMPLEX_TYPE_TO_MAP__DATA_MODEL_IMPORT)) {
        _matched=true;
        return this.getScopeForDomainModelImports(type);
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.IMPORTED_COMPLEX_TYPE_TO_MAP__TYPE)) {
        _matched=true;
        return this.getScopeForComplexTypes(type);
      }
    }
    return null;
  }
  
  /**
   * Build scope for complex type mappings and the given reference
   */
  private IScope getScope(final ComplexTypeMapping mapping, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.IMPORTED_COMPLEX_TYPE_TO_MAP__SERVICE_MODEL_IMPORT)) {
      _matched=true;
      return this.getScopeForImportsOfType(mapping, ServiceModel.class);
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForAnnotatedTechnologies(mapping);
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_FIELD_MAPPING__DATA_FIELD)) {
        _matched=true;
        return this.getScopeForDataFields(mapping);
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_FIELD_MAPPING__ENUMERATION_FIELD)) {
        _matched=true;
        return this.getScopeForEnumerationFields(mapping);
      }
    }
    return null;
  }
  
  /**
   * Build scope for data operation mappings and the given reference
   */
  private IScope getScope(final DataOperationMapping mapping, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.DATA_OPERATION_MAPPING__DATA_OPERATION)) {
      _matched=true;
      return this.getScopeForDataOperations(mapping);
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForAnnotatedTechnologies(mapping);
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.DATA_OPERATION_PARAMETER_MAPPING__PARAMETER)) {
        _matched=true;
        return Scopes.scopeFor(mapping.getDataOperation().getParameters());
      }
    }
    return null;
  }
  
  /**
   * Build scope for data operation parameter mappings and the given reference
   */
  private IScope getScope(final DataOperationReturnTypeMapping mapping, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__TECHNOLOGY)) {
      _matched=true;
      return this.getScopeForAnnotatedTechnologies(mapping);
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.DATA_OPERATION_RETURN_TYPE_MAPPING__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForAnnotatedTechnologies(mapping);
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.DATA_OPERATION_RETURN_TYPE_MAPPING__TYPE)) {
        _matched=true;
        return this.getScopeForMappingTypes(mapping);
      }
    }
    return null;
  }
  
  /**
   * Build scope for data operation parameter mappings and the given reference
   */
  private IScope getScope(final DataOperationParameterMapping mapping, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.DATA_OPERATION_PARAMETER_MAPPING__PARAMETER)) {
      _matched=true;
      return Scopes.scopeFor(mapping.getOperationMapping().getDataOperation().getParameters());
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForAnnotatedTechnologies(mapping);
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.DATA_OPERATION_PARAMETER_MAPPING__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForAnnotatedTechnologies(mapping);
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.DATA_OPERATION_PARAMETER_MAPPING__TYPE)) {
        _matched=true;
        return this.getScopeForMappingTypes(mapping);
      }
    }
    return null;
  }
  
  /**
   * Build scope for microservice mappings and the given reference
   */
  private IScope getScope(final MicroserviceMapping mapping, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.IMPORTED_MICROSERVICE__IMPORT)) {
      _matched=true;
      return this.getScopeForImportsOfType(mapping, ServiceModel.class);
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_PROTOCOL__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForAnnotatedTechnologies(mapping);
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForAnnotatedTechnologies(mapping);
      }
    }
    return null;
  }
  
  /**
   * Build scope for technology references and the given reference
   */
  private IScope getScope(final TechnologyReference technologyReference, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, ServicePackage.Literals.TECHNOLOGY_REFERENCE__TECHNOLOGY)) {
      _matched=true;
      return this.getScopeForImportsOfType(technologyReference, Technology.class);
    }
    return null;
  }
  
  /**
   * Build scope for interface mappings and the given reference
   */
  private IScope getScope(final InterfaceMapping mapping, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.INTERFACE_MAPPING__INTERFACE)) {
      _matched=true;
      return this.getScopeForInterfaces(mapping);
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_PROTOCOL__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForAnnotatedTechnologies(mapping);
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForAnnotatedTechnologies(mapping);
      }
    }
    return null;
  }
  
  /**
   * Build scope for operation mappings and the given reference
   */
  private IScope getScope(final OperationMapping mapping, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.OPERATION_MAPPING__OPERATION)) {
      _matched=true;
      return this.getScopeForOperations(mapping);
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_PROTOCOL__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForAnnotatedTechnologies(mapping);
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForAnnotatedTechnologies(mapping);
      }
    }
    return null;
  }
  
  /**
   * Build scope for referred operation mappings and the given reference
   */
  private IScope getScope(final ReferredOperationMapping mapping, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.REFERRED_OPERATION_MAPPING__OPERATION)) {
      _matched=true;
      return this.getScopeForReferredOperations(mapping);
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_PROTOCOL__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForAnnotatedTechnologies(mapping);
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForAnnotatedTechnologies(mapping.getMicroserviceMapping());
      }
    }
    return null;
  }
  
  /**
   * Build scope for imported microservices
   */
  private IScope getScope(final ImportedMicroservice microservice, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.IMPORTED_MICROSERVICE__IMPORT)) {
      _matched=true;
      return this.getScopeForImportsOfType(microservice, ServiceModel.class);
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.IMPORTED_MICROSERVICE__MICROSERVICE)) {
        _matched=true;
        return this.getScopeForImportedMicroservices(microservice.getImport());
      }
    }
    return null;
  }
  
  /**
   * Build scope for technology-specific protocols and the given reference
   */
  private IScope getScope(final TechnologySpecificProtocolSpecification protocolSpecification, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_PROTOCOL__TECHNOLOGY)) {
      _matched=true;
      return this.getScopeForAnnotatedTechnologies(protocolSpecification);
    }
    return null;
  }
  
  /**
   * Build scope that comprises annotated technologies of a technology-annotatable concept
   * instance or its technology-annotatable container
   */
  private IScope getScopeForAnnotatedTechnologies(final EObject element) {
    EObject _elvis = null;
    ComplexTypeMapping _containerOfType = EcoreUtil2.<ComplexTypeMapping>getContainerOfType(element, ComplexTypeMapping.class);
    if (_containerOfType != null) {
      _elvis = _containerOfType;
    } else {
      MicroserviceMapping _containerOfType_1 = EcoreUtil2.<MicroserviceMapping>getContainerOfType(element, MicroserviceMapping.class);
      _elvis = _containerOfType_1;
    }
    final EObject parentMapping = _elvis;
    if ((parentMapping == null)) {
      return null;
    }
    IScope _xifexpression = null;
    if ((parentMapping instanceof ComplexTypeMapping)) {
      final Function1<TechnologyReference, Import> _function = (TechnologyReference it) -> {
        return it.getTechnology();
      };
      _xifexpression = Scopes.scopeFor(ListExtensions.<TechnologyReference, Import>map(((ComplexTypeMapping)parentMapping).getTechnologyReferences(), _function));
    } else {
      IScope _xifexpression_1 = null;
      if ((parentMapping instanceof MicroserviceMapping)) {
        final Function1<TechnologyReference, Import> _function_1 = (TechnologyReference it) -> {
          return it.getTechnology();
        };
        _xifexpression_1 = Scopes.scopeFor(ListExtensions.<TechnologyReference, Import>map(((MicroserviceMapping)parentMapping).getTechnologyReferences(), _function_1));
      }
      _xifexpression = _xifexpression_1;
    }
    return _xifexpression;
  }
  
  /**
   * Build scope for technology protocols and the given reference
   */
  private IScope getScope(final TechnologySpecificProtocol protocol, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_PROTOCOL__PROTOCOL)) {
      _matched=true;
      return this.getScopeForTechnologySpecificProtocols(protocol);
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_PROTOCOL__DATA_FORMAT)) {
        _matched=true;
        return this.getScopeForDataFormats(protocol);
      }
    }
    return null;
  }
  
  /**
   * Build scope for technology-specific endpoints and the given reference
   */
  private IScope getScope(final TechnologySpecificEndpoint endpoint, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_PROTOCOL__TECHNOLOGY)) {
      _matched=true;
      return this.getScopeForAnnotatedTechnologies(endpoint);
    }
    return null;
  }
  
  /**
   * Build scope for primitive parameter mappings and the given reference
   */
  private IScope getScope(final PrimitiveParameterMapping mapping, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.PARAMETER_MAPPING__PARAMETER)) {
      _matched=true;
      return this.getScopeForPrimitiveParameters(mapping);
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.PRIMITIVE_PARAMETER_MAPPING__PRIMITIVE_TYPE)) {
        _matched=true;
        return this.getScopeForMappingTypes(mapping);
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForAnnotatedTechnologies(mapping);
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.PRIMITIVE_PARAMETER_MAPPING__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForTypeDefinitionTechnology(mapping);
      }
    }
    return null;
  }
  
  /**
   * Build scope for complex parameter mappings and the given reference
   */
  private IScope getScope(final ComplexParameterMapping mapping, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.PARAMETER_MAPPING__PARAMETER)) {
      _matched=true;
      return this.getScopeForComplexParameters(mapping);
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForAnnotatedTechnologies(mapping);
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.COMPLEX_PARAMETER_MAPPING__TECHNOLOGY)) {
        _matched=true;
        return this.getScopeForTypeDefinitionTechnology(mapping);
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.COMPLEX_PARAMETER_MAPPING__TECHNOLOGY_SPECIFIC_COMPLEX_TYPE)) {
        _matched=true;
        return this.getScopeForMappingTypes(mapping);
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_FIELD_MAPPING__DATA_FIELD)) {
        _matched=true;
        return this.getScopeForDataFields(mapping);
      }
    }
    return null;
  }
  
  /**
   * Build scope for technology-specific field mappings and the given reference
   */
  private IScope getScope(final TechnologySpecificFieldMapping mapping, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_FIELD_MAPPING__DATA_FIELD)) {
      _matched=true;
      return this.getScopeForDataFields(mapping.eContainer());
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_FIELD_MAPPING__ENUMERATION_FIELD)) {
        _matched=true;
        return this.getScopeForEnumerationFields(mapping.eContainer());
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_FIELD_MAPPING__TECHNOLOGY)) {
        _matched=true;
      }
      if (!_matched) {
        if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__TECHNOLOGY)) {
          _matched=true;
        }
      }
      if (_matched) {
        return this.getScopeForAnnotatedTechnologies(mapping);
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_FIELD_MAPPING__TYPE)) {
        _matched=true;
        return this.getScopeForMappingTypes(mapping);
      }
    }
    return null;
  }
  
  /**
   * Build scope for domain model imports of imported complex types
   */
  private IScope getScopeForDomainModelImports(final ImportedComplexTypeToMap type) {
    final ServiceModel serviceModel = LemmaUtils.<ServiceModel>getImportedModelRoot(type.eResource(), 
      type.getServiceModelImport().getImportURI(), ServiceModel.class);
    EList<Import> _imports = null;
    if (serviceModel!=null) {
      _imports=serviceModel.getImports();
    }
    Iterable<Import> _filter = null;
    if (_imports!=null) {
      final Function1<Import, Boolean> _function = (Import it) -> {
        ImportType _importType = it.getImportType();
        return Boolean.valueOf(Objects.equal(_importType, ImportType.DATATYPES));
      };
      _filter=IterableExtensions.<Import>filter(_imports, _function);
    }
    final Iterable<Import> dataModels = _filter;
    if ((dataModels != null)) {
      return Scopes.scopeFor(dataModels);
    }
    return null;
  }
  
  /**
   * Build scope for complex types to be imported
   */
  private IScope getScopeForComplexTypes(final ImportedComplexTypeToMap type) {
    Import _dataModelImport = type.getDataModelImport();
    boolean _tripleEquals = (_dataModelImport == null);
    if (_tripleEquals) {
      return IScope.NULLSCOPE;
    }
    final Function<DataModel, List<ComplexType>> _function = (DataModel it) -> {
      return IterableExtensions.<ComplexType>toList(it.getContainedComplexTypes());
    };
    final Function<ComplexType, List<String>> _function_1 = (ComplexType it) -> {
      return it.getQualifiedNameParts();
    };
    return LemmaUtils.<Import, DataModel, ComplexType>getScopeForPossiblyImportedConcept(
      type.getDataModelImport(), 
      null, 
      DataModel.class, 
      type.getDataModelImport().getImportURI(), _function, _function_1);
  }
  
  /**
   * Build scope for interfaces
   */
  private IScope getScopeForInterfaces(final InterfaceMapping mapping) {
    final MicroserviceMapping microserviceMapping = mapping.getMicroserviceMapping();
    final Microservice microservice = microserviceMapping.getMicroservice().getMicroservice();
    final Function<Interface, QualifiedName> _function = (Interface it) -> {
      QualifiedName _xifexpression = null;
      String _version = it.getVersion();
      boolean _tripleNotEquals = (_version != null);
      if (_tripleNotEquals) {
        _xifexpression = QualifiedName.create(it.getVersion(), it.getName());
      } else {
        _xifexpression = QualifiedName.create(it.getName());
      }
      return _xifexpression;
    };
    return Scopes.<Interface>scopeFor(
      microservice.getInterfaces(), _function, 
      IScope.NULLSCOPE);
  }
  
  /**
   * Build scope for operations
   */
  private IScope getScopeForOperations(final OperationMapping mapping) {
    final MicroserviceMapping microserviceMapping = mapping.getMicroserviceMapping();
    final Microservice microservice = microserviceMapping.getMicroservice().getMicroservice();
    if ((microservice == null)) {
      return IScope.NULLSCOPE;
    }
    final Function1<Interface, EList<Operation>> _function = (Interface it) -> {
      return it.getOperations();
    };
    final Iterable<Operation> operations = Iterables.<Operation>concat(ListExtensions.<Interface, EList<Operation>>map(microservice.getInterfaces(), _function));
    final Function<Operation, QualifiedName> _function_1 = (Operation it) -> {
      QualifiedName _xifexpression = null;
      String _version = it.getInterface().getVersion();
      boolean _tripleNotEquals = (_version != null);
      if (_tripleNotEquals) {
        _xifexpression = QualifiedName.create(it.getInterface().getVersion(), it.getInterface().getName(), it.getName());
      } else {
        _xifexpression = QualifiedName.create(it.getInterface().getName(), it.getName());
      }
      return _xifexpression;
    };
    return Scopes.<Operation>scopeFor(operations, _function_1, 
      IScope.NULLSCOPE);
  }
  
  /**
   * Build scope for primitive parameters of operations
   */
  private IScope getScopeForPrimitiveParameters(final PrimitiveParameterMapping mapping) {
    final Function1<Parameter, Boolean> _function = (Parameter it) -> {
      PrimitiveType _primitiveType = it.getPrimitiveType();
      return Boolean.valueOf((_primitiveType != null));
    };
    final List<Parameter> primitiveParameters = IterableExtensions.<Parameter>toList(IterableExtensions.<Parameter>filter(mapping.getOperationMapping().getOperation().getParameters(), _function));
    final Function1<Parameter, Boolean> _function_1 = (Parameter it) -> {
      return Boolean.valueOf(((it.getImportedType() != null) && (it.getImportedType().getType() instanceof TechnologySpecificPrimitiveType)));
    };
    Iterables.<Parameter>addAll(primitiveParameters, 
      IterableExtensions.<Parameter>filter(mapping.getOperationMapping().getOperation().getParameters(), _function_1));
    return Scopes.scopeFor(primitiveParameters);
  }
  
  /**
   * Build scope for complex parameters of operations
   */
  private IScope getScopeForComplexParameters(final ComplexParameterMapping mapping) {
    final Function1<Parameter, Boolean> _function = (Parameter it) -> {
      return Boolean.valueOf(((it.getImportedType() != null) && (it.getImportedType().getType() instanceof ComplexType)));
    };
    final Iterable<Parameter> complexParameters = IterableExtensions.<Parameter>filter(mapping.getOperationMapping().getOperation().getParameters(), _function);
    return Scopes.scopeFor(complexParameters);
  }
  
  /**
   * Build scope for technology-specific types
   */
  private IScope getScopeForMappingTypes(final EObject mapping) {
    Type originalType = null;
    Import technology = null;
    boolean _matched = false;
    if (mapping instanceof PrimitiveParameterMapping) {
      _matched=true;
      originalType = ((PrimitiveParameterMapping)mapping).getParameter().getEffectiveType();
      technology = ((PrimitiveParameterMapping)mapping).getTechnology();
    }
    if (!_matched) {
      if (mapping instanceof ComplexParameterMapping) {
        _matched=true;
        Parameter _parameter = null;
        if (((ComplexParameterMapping)mapping)!=null) {
          _parameter=((ComplexParameterMapping)mapping).getParameter();
        }
        ImportedType _importedType = null;
        if (_parameter!=null) {
          _importedType=_parameter.getImportedType();
        }
        Type _type = null;
        if (_importedType!=null) {
          _type=_importedType.getType();
        }
        originalType = _type;
        technology = ((ComplexParameterMapping)mapping).getTechnology();
      }
    }
    if (!_matched) {
      if (mapping instanceof TechnologySpecificFieldMapping) {
        _matched=true;
        originalType = ((TechnologySpecificFieldMapping)mapping).getDataField().getEffectiveType();
        technology = ((TechnologySpecificFieldMapping)mapping).getTechnology();
      }
    }
    if (!_matched) {
      if (mapping instanceof DataOperationParameterMapping) {
        _matched=true;
        originalType = ((DataOperationParameterMapping)mapping).getParameter().getEffectiveType();
        technology = ((DataOperationParameterMapping)mapping).getTechnology();
      }
    }
    if (!_matched) {
      if (mapping instanceof DataOperationReturnTypeMapping) {
        _matched=true;
        originalType = ((DataOperationReturnTypeMapping)mapping).getOperationMapping().getDataOperation().getPrimitiveOrComplexReturnType();
        technology = ((DataOperationReturnTypeMapping)mapping).getTechnology();
      }
    }
    if (!_matched) {
      return IScope.NULLSCOPE;
    }
    if ((originalType == null)) {
      return IScope.NULLSCOPE;
    }
    Function<Technology, List<Type>> getImportedConcepts = null;
    Function<Type, List<String>> getConceptNameParts = null;
    if ((originalType instanceof PrimitiveType)) {
      final Function<Technology, List<Type>> _function = (Technology it) -> {
        final Function1<TechnologySpecificPrimitiveType, Type> _function_1 = (TechnologySpecificPrimitiveType it_1) -> {
          return ((Type) it_1);
        };
        return ListExtensions.<TechnologySpecificPrimitiveType, Type>map(it.getPrimitiveTypes(), _function_1);
      };
      getImportedConcepts = _function;
      final Function<Type, List<String>> _function_1 = (Type it) -> {
        return ((TechnologySpecificPrimitiveType) it).getQualifiedNameParts();
      };
      getConceptNameParts = _function_1;
    } else {
      if ((originalType instanceof ComplexType)) {
        boolean _isIsStructure = ((ComplexType)originalType).isIsStructure();
        if (_isIsStructure) {
          final Function<Technology, List<Type>> _function_2 = (Technology it) -> {
            final Function1<TechnologySpecificDataStructure, Type> _function_3 = (TechnologySpecificDataStructure it_1) -> {
              return ((Type) it_1);
            };
            return ListExtensions.<TechnologySpecificDataStructure, Type>map(it.getDataStructures(), _function_3);
          };
          getImportedConcepts = _function_2;
          final Function<Type, List<String>> _function_3 = (Type it) -> {
            return ((TechnologySpecificDataStructure) it).getQualifiedNameParts();
          };
          getConceptNameParts = _function_3;
        } else {
          if ((((ComplexType)originalType).isIsStructuredCollection() || ((ComplexType)originalType).isIsPrimitiveCollection())) {
            final Function<Technology, List<Type>> _function_4 = (Technology it) -> {
              final Function1<TechnologySpecificCollectionType, Type> _function_5 = (TechnologySpecificCollectionType it_1) -> {
                return ((Type) it_1);
              };
              return ListExtensions.<TechnologySpecificCollectionType, Type>map(it.getCollectionTypes(), _function_5);
            };
            getImportedConcepts = _function_4;
            final Function<Type, List<String>> _function_5 = (Type it) -> {
              return ((TechnologySpecificCollectionType) it).getQualifiedNameParts();
            };
            getConceptNameParts = _function_5;
          } else {
            boolean _isIsEnumeration = ((ComplexType)originalType).isIsEnumeration();
            if (_isIsEnumeration) {
              return IScope.NULLSCOPE;
            }
          }
        }
      }
    }
    return LemmaUtils.<Import, Technology, Type>getScopeForPossiblyImportedConcept(technology, 
      null, 
      Technology.class, 
      technology.getImportURI(), getImportedConcepts, getConceptNameParts);
  }
  
  /**
   * Build scope for microservice mapping technology that defines types
   */
  private IScope getScopeForTypeDefinitionTechnology(final EObject context) {
    List<Import> _switchResult = null;
    boolean _matched = false;
    if (context instanceof ComplexTypeMapping) {
      _matched=true;
      final Function1<TechnologyReference, Import> _function = (TechnologyReference it) -> {
        return it.getTechnology();
      };
      _switchResult = ListExtensions.<TechnologyReference, Import>map(((ComplexTypeMapping)context).getTechnologyReferences(), _function);
    }
    if (!_matched) {
      if (context instanceof MicroserviceMapping) {
        _matched=true;
        final Function1<TechnologyReference, Import> _function = (TechnologyReference it) -> {
          return it.getTechnology();
        };
        _switchResult = ListExtensions.<TechnologyReference, Import>map(((MicroserviceMapping)context).getTechnologyReferences(), _function);
      }
    }
    if (!_matched) {
      List<Import> _elvis = null;
      MicroserviceMapping _containerOfType = EcoreUtil2.<MicroserviceMapping>getContainerOfType(context, MicroserviceMapping.class);
      EList<TechnologyReference> _technologyReferences = null;
      if (_containerOfType!=null) {
        _technologyReferences=_containerOfType.getTechnologyReferences();
      }
      final Function1<TechnologyReference, Import> _function = (TechnologyReference it) -> {
        return it.getTechnology();
      };
      List<Import> _map = ListExtensions.<TechnologyReference, Import>map(_technologyReferences, _function);
      if (_map != null) {
        _elvis = _map;
      } else {
        ComplexTypeMapping _containerOfType_1 = EcoreUtil2.<ComplexTypeMapping>getContainerOfType(context, ComplexTypeMapping.class);
        EList<TechnologyReference> _technologyReferences_1 = null;
        if (_containerOfType_1!=null) {
          _technologyReferences_1=_containerOfType_1.getTechnologyReferences();
        }
        final Function1<TechnologyReference, Import> _function_1 = (TechnologyReference it) -> {
          return it.getTechnology();
        };
        List<Import> _map_1 = ListExtensions.<TechnologyReference, Import>map(_technologyReferences_1, _function_1);
        _elvis = _map_1;
      }
      _switchResult = _elvis;
    }
    final List<Import> technologies = _switchResult;
    if ((technologies == null)) {
      return IScope.NULLSCOPE;
    }
    final Function1<Import, Boolean> _function_2 = (Import it) -> {
      boolean _xblockexpression = false;
      {
        final Technology modelRoot = LemmaUtils.<Technology>getImportedModelRoot(it.eResource(), it.getImportURI(), Technology.class);
        _xblockexpression = ((modelRoot != null) && (!modelRoot.getPrimitiveTypes().isEmpty()));
      }
      return Boolean.valueOf(_xblockexpression);
    };
    final Import typeDefinitionTechnology = IterableExtensions.<Import>findFirst(technologies, _function_2);
    if ((typeDefinitionTechnology == null)) {
      return IScope.NULLSCOPE;
    }
    return Scopes.scopeFor(Collections.<EObject>unmodifiableList(CollectionLiterals.<EObject>newArrayList(typeDefinitionTechnology)));
  }
  
  /**
   * Build scope for data fields in complex type and parameter mappings
   */
  private IScope getScopeForDataFields(final EObject mapping) {
    ComplexType _xifexpression = null;
    if ((mapping instanceof ComplexParameterMapping)) {
      ComplexType _xifexpression_1 = null;
      ImportedType _importedType = ((ComplexParameterMapping)mapping).getParameter().getImportedType();
      boolean _tripleNotEquals = (_importedType != null);
      if (_tripleNotEquals) {
        Type _type = ((ComplexParameterMapping)mapping).getParameter().getImportedType().getType();
        _xifexpression_1 = ((ComplexType) _type);
      }
      _xifexpression = _xifexpression_1;
    } else {
      ComplexType _xifexpression_2 = null;
      if ((mapping instanceof ComplexTypeMapping)) {
        ComplexType _type_1 = ((ComplexTypeMapping)mapping).getType().getType();
        _xifexpression_2 = ((ComplexType) _type_1);
      }
      _xifexpression = _xifexpression_2;
    }
    final ComplexType complexType = _xifexpression;
    IScope _xifexpression_3 = null;
    if ((complexType == null)) {
      _xifexpression_3 = IScope.NULLSCOPE;
    } else {
      IScope _xifexpression_4 = null;
      boolean _isIsStructure = complexType.isIsStructure();
      if (_isIsStructure) {
        _xifexpression_4 = Scopes.scopeFor(((DataStructure) complexType).getDataFields());
      } else {
        IScope _xifexpression_5 = null;
        boolean _isIsStructuredCollection = complexType.isIsStructuredCollection();
        if (_isIsStructuredCollection) {
          _xifexpression_5 = Scopes.scopeFor(((CollectionType) complexType).getDataFields());
        } else {
          _xifexpression_5 = IScope.NULLSCOPE;
        }
        _xifexpression_4 = _xifexpression_5;
      }
      _xifexpression_3 = _xifexpression_4;
    }
    return _xifexpression_3;
  }
  
  /**
   * Build scope for enumeration fields in complex type mappings
   */
  private IScope getScopeForEnumerationFields(final EObject mapping) {
    Type _xifexpression = null;
    if ((mapping instanceof ComplexParameterMapping)) {
      _xifexpression = ((ComplexParameterMapping)mapping).getParameter().getImportedType().getType();
    } else {
      ComplexType _xifexpression_1 = null;
      if ((mapping instanceof ComplexTypeMapping)) {
        _xifexpression_1 = ((ComplexTypeMapping)mapping).getType().getType();
      }
      _xifexpression = _xifexpression_1;
    }
    final Type mappedType = _xifexpression;
    IScope _xifexpression_2 = null;
    if ((mappedType instanceof Enumeration)) {
      _xifexpression_2 = Scopes.scopeFor(((Enumeration) mappedType).getFields());
    } else {
      _xifexpression_2 = IScope.NULLSCOPE;
    }
    return _xifexpression_2;
  }
  
  /**
   * Build scope for data operations in complex type mappings
   */
  private IScope getScopeForDataOperations(final DataOperationMapping mapping) {
    ComplexType _type = mapping.getTypeMapping().getType().getType();
    ComplexType complexType = ((ComplexType) _type);
    IScope _xifexpression = null;
    if (((complexType != null) && complexType.isIsStructure())) {
      _xifexpression = Scopes.scopeFor(((DataStructure) complexType).getOperations());
    } else {
      _xifexpression = IScope.NULLSCOPE;
    }
    return _xifexpression;
  }
  
  /**
   * Build scope for referred operations
   */
  private IScope getScopeForReferredOperations(final ReferredOperationMapping mapping) {
    final MicroserviceMapping microserviceMapping = mapping.getMicroserviceMapping();
    final Microservice microservice = microserviceMapping.getMicroservice().getMicroservice();
    final Function1<Interface, EList<ReferredOperation>> _function = (Interface it) -> {
      return it.getReferredOperations();
    };
    final Iterable<ReferredOperation> operations = Iterables.<ReferredOperation>concat(ListExtensions.<Interface, EList<ReferredOperation>>map(microservice.getInterfaces(), _function));
    final Function<ReferredOperation, QualifiedName> _function_1 = (ReferredOperation it) -> {
      QualifiedName _xifexpression = null;
      String _version = it.getInterface().getVersion();
      boolean _tripleNotEquals = (_version != null);
      if (_tripleNotEquals) {
        _xifexpression = QualifiedName.create(it.getInterface().getVersion(), it.getInterface().getName(), it.getOperation().getName());
      } else {
        _xifexpression = QualifiedName.create(it.getInterface().getName(), it.getOperation().getName());
      }
      return _xifexpression;
    };
    return Scopes.<ReferredOperation>scopeFor(operations, _function_1, 
      IScope.NULLSCOPE);
  }
  
  /**
   * Build scope for technology-specific protocols
   */
  private IScope getScopeForTechnologySpecificProtocols(final TechnologySpecificProtocol protocol) {
    Import _technology = protocol.getTechnology();
    boolean _tripleEquals = (_technology == null);
    if (_tripleEquals) {
      return IScope.NULLSCOPE;
    }
    final TechnologySpecificProtocolSpecification protocolSpecification = protocol.getProtocolSpecification();
    CommunicationType _xifexpression = null;
    if ((protocolSpecification != null)) {
      _xifexpression = protocolSpecification.getCommunicationType();
    }
    final CommunicationType forCommunicationType = _xifexpression;
    List<Predicate<Protocol>> _xifexpression_1 = null;
    if ((forCommunicationType != null)) {
      final Predicate<Protocol> _function = (Protocol it) -> {
        CommunicationType _communicationType = it.getCommunicationType();
        return Objects.equal(forCommunicationType, _communicationType);
      };
      _xifexpression_1 = Collections.<Predicate<Protocol>>unmodifiableList(CollectionLiterals.<Predicate<Protocol>>newArrayList(_function));
    }
    List<Predicate<Protocol>> communicationTypeFilter = _xifexpression_1;
    final Function<Technology, List<Protocol>> _function_1 = (Technology it) -> {
      return IterableExtensions.<Protocol>toList(it.getProtocols());
    };
    final Function<Protocol, List<String>> _function_2 = (Protocol it) -> {
      return it.getQualifiedNameParts();
    };
    final List<Predicate<Protocol>> _converted_communicationTypeFilter = (List<Predicate<Protocol>>)communicationTypeFilter;
    return LemmaUtils.<Import, Technology, Protocol>getScopeForPossiblyImportedConcept(
      protocol.getTechnology(), 
      null, 
      Technology.class, 
      protocol.getTechnology().getImportURI(), _function_1, _function_2, ((Predicate<Protocol>[])Conversions.unwrapArray(_converted_communicationTypeFilter, Predicate.class)));
  }
  
  /**
   * Build scope for protocol data formats
   */
  private IScope getScopeForDataFormats(final TechnologySpecificProtocol protocol) {
    Protocol _protocol = protocol.getProtocol();
    boolean _tripleEquals = (_protocol == null);
    if (_tripleEquals) {
      return IScope.NULLSCOPE;
    }
    final String protocolName = protocol.getProtocol().getName();
    if ((protocolName == null)) {
      return IScope.NULLSCOPE;
    }
    final Function1<Protocol, Boolean> _function = (Protocol it) -> {
      String _name = it.getName();
      return Boolean.valueOf(Objects.equal(_name, protocolName));
    };
    final EList<DataFormat> scopeElements = IterableExtensions.<Protocol>findFirst(protocol.getProtocol().getTechnology().getProtocols(), _function).getDataFormats();
    final Function<DataFormat, QualifiedName> _function_1 = (DataFormat it) -> {
      return QualifiedName.create(it.getFormatName());
    };
    return Scopes.<DataFormat>scopeFor(scopeElements, _function_1, 
      IScope.NULLSCOPE);
  }
  
  /**
   * Build scope for the actual microservices if the import was already specified
   */
  private IScope getScopeForImportedMicroservices(final Import import_) {
    if ((import_ == null)) {
      return IScope.NULLSCOPE;
    }
    final Function<ServiceModel, List<Microservice>> _function = (ServiceModel it) -> {
      return IterableExtensions.<Microservice>toList(it.getMicroservices());
    };
    final Function<Microservice, List<String>> _function_1 = (Microservice it) -> {
      return it.getQualifiedNameParts();
    };
    return LemmaUtils.<Import, ServiceModel, Microservice>getScopeForPossiblyImportedConcept(import_, 
      null, 
      ServiceModel.class, 
      import_.getImportURI(), _function, _function_1);
  }
  
  /**
   * Build scope for imported service aspects used to annotate several modeled elements
   */
  private IScope getScope(final TechnologySpecificImportedServiceAspect importedAspect, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__TECHNOLOGY)) {
      _matched=true;
      return this.getScopeForAnnotatedTechnologies(importedAspect);
    }
    if (!_matched) {
      if (Objects.equal(reference, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__ASPECT)) {
        _matched=true;
        return this.getScopeForImportedAspect(importedAspect);
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, TechnologyPackage.Literals.TECHNOLOGY_SPECIFIC_PROPERTY_VALUE_ASSIGNMENT__PROPERTY)) {
        _matched=true;
        return this.getScopeForAspectProperty(importedAspect);
      }
    }
    return null;
  }
  
  /**
   * Build scope for technology-specific value assignment
   */
  private IScope getScope(final TechnologySpecificPropertyValueAssignment assignment, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, TechnologyPackage.Literals.TECHNOLOGY_SPECIFIC_PROPERTY_VALUE_ASSIGNMENT__PROPERTY)) {
      _matched=true;
      return this.getScopeForAspectProperty(EcoreUtil2.<TechnologySpecificImportedServiceAspect>getContainerOfType(assignment, 
        TechnologySpecificImportedServiceAspect.class));
    }
    return null;
  }
  
  /**
   * Build scope for aspect properties
   */
  private IScope getScopeForAspectProperty(final TechnologySpecificImportedServiceAspect importedAspect) {
    return Scopes.scopeFor(importedAspect.getAspect().getProperties());
  }
  
  /**
   * Build scope for aspect of imported service aspect
   */
  private IScope getScopeForImportedAspect(final TechnologySpecificImportedServiceAspect aspect) {
    Import _technology = aspect.getTechnology();
    boolean _tripleEquals = (_technology == null);
    if (_tripleEquals) {
      return IScope.NULLSCOPE;
    }
    ExchangePattern forExchangePattern = null;
    CommunicationType forCommunicationType = null;
    List<Pair<Protocol, DataFormat>> forProtocolsAndDataFormats = null;
    final EObject mapping = aspect.eContainer();
    JoinPointType _switchResult = null;
    boolean _matched = false;
    if (mapping instanceof ComplexTypeMapping) {
      _matched=true;
      _switchResult = JoinPointType.COMPLEX_TYPES;
    }
    if (!_matched) {
      if (mapping instanceof DataOperationMapping) {
        _matched=true;
        _switchResult = JoinPointType.DATA_OPERATIONS;
      }
    }
    if (!_matched) {
      if (mapping instanceof DataOperationParameterMapping) {
        _matched=true;
      }
      if (!_matched) {
        if (mapping instanceof DataOperationReturnTypeMapping) {
          _matched=true;
        }
      }
      if (_matched) {
        _switchResult = JoinPointType.DATA_OPERATION_PARAMETERS;
      }
    }
    if (!_matched) {
      if (mapping instanceof MicroserviceMapping) {
        _matched=true;
        JoinPointType _xblockexpression = null;
        {
          forProtocolsAndDataFormats = IterableExtensions.<Pair<Protocol, DataFormat>>toList(this.getEffectiveProtocolsAndDataFormats(((MicroserviceMapping)mapping)).values());
          _xblockexpression = JoinPointType.MICROSERVICES;
        }
        _switchResult = _xblockexpression;
      }
    }
    if (!_matched) {
      if (mapping instanceof InterfaceMapping) {
        _matched=true;
        JoinPointType _xblockexpression = null;
        {
          forProtocolsAndDataFormats = IterableExtensions.<Pair<Protocol, DataFormat>>toList(this.getEffectiveProtocolsAndDataFormats(((InterfaceMapping)mapping)).values());
          _xblockexpression = JoinPointType.INTERFACES;
        }
        _switchResult = _xblockexpression;
      }
    }
    if (!_matched) {
      if (mapping instanceof OperationMapping) {
        _matched=true;
        JoinPointType _xblockexpression = null;
        {
          forProtocolsAndDataFormats = IterableExtensions.<Pair<Protocol, DataFormat>>toList(this.getEffectiveProtocolsAndDataFormats(((OperationMapping)mapping)).values());
          _xblockexpression = JoinPointType.OPERATIONS;
        }
        _switchResult = _xblockexpression;
      }
    }
    if (!_matched) {
      if (mapping instanceof ReferredOperationMapping) {
        _matched=true;
        JoinPointType _xblockexpression = null;
        {
          forProtocolsAndDataFormats = IterableExtensions.<Pair<Protocol, DataFormat>>toList(this.getEffectiveProtocolsAndDataFormats(((ReferredOperationMapping)mapping)).values());
          _xblockexpression = JoinPointType.OPERATIONS;
        }
        _switchResult = _xblockexpression;
      }
    }
    if (!_matched) {
      if (mapping instanceof ParameterMapping) {
        _matched=true;
        JoinPointType _xblockexpression = null;
        {
          final Parameter parameter = ((ParameterMapping)mapping).getParameter();
          forCommunicationType = parameter.getCommunicationType();
          forExchangePattern = parameter.getExchangePattern();
          final Pair<Protocol, DataFormat> effectiveProtocolAndDataFormat = this.getEffectiveProtocolAndDataFormat(((ParameterMapping)mapping));
          List<Pair<Protocol, DataFormat>> _xifexpression = null;
          if ((effectiveProtocolAndDataFormat != null)) {
            _xifexpression = Collections.<Pair<Protocol, DataFormat>>unmodifiableList(CollectionLiterals.<Pair<Protocol, DataFormat>>newArrayList(effectiveProtocolAndDataFormat));
          } else {
            _xifexpression = null;
          }
          forProtocolsAndDataFormats = _xifexpression;
          _xblockexpression = JoinPointType.PARAMETERS;
        }
        _switchResult = _xblockexpression;
      }
    }
    if (!_matched) {
      if (mapping instanceof TechnologySpecificFieldMapping) {
        _matched=true;
        JoinPointType _xblockexpression = null;
        {
          ComplexParameterMapping _parameterMapping = ((TechnologySpecificFieldMapping)mapping).getParameterMapping();
          boolean _tripleNotEquals = (_parameterMapping != null);
          if (_tripleNotEquals) {
            final ComplexParameterMapping parameterMapping = ((TechnologySpecificFieldMapping)mapping).getParameterMapping();
            final Pair<Protocol, DataFormat> effectiveProtocolAndDataFormat = this.getEffectiveProtocolAndDataFormat(parameterMapping);
            List<Pair<Protocol, DataFormat>> _xifexpression = null;
            if ((effectiveProtocolAndDataFormat != null)) {
              _xifexpression = Collections.<Pair<Protocol, DataFormat>>unmodifiableList(CollectionLiterals.<Pair<Protocol, DataFormat>>newArrayList(effectiveProtocolAndDataFormat));
            } else {
              _xifexpression = null;
            }
            forProtocolsAndDataFormats = _xifexpression;
            final Parameter parameter = parameterMapping.getParameter();
            forCommunicationType = parameter.getCommunicationType();
            forExchangePattern = parameter.getExchangePattern();
          }
          _xblockexpression = JoinPointType.DATA_FIELDS;
        }
        _switchResult = _xblockexpression;
      }
    }
    final JoinPointType joinPoint = _switchResult;
    final List<EObject> resourceContents = LemmaUtils.getImportedModelContents(aspect.getTechnology().eResource(), 
      aspect.getTechnology().getImportURI());
    if (((resourceContents == null) || resourceContents.isEmpty())) {
      return IScope.NULLSCOPE;
    }
    EObject _get = resourceContents.get(0);
    final Function1<ServiceAspect, Boolean> _function = (ServiceAspect it) -> {
      return Boolean.valueOf(it.getJoinPoints().contains(joinPoint));
    };
    final List<ServiceAspect> declaredAspectsForJoinPoint = IterableExtensions.<ServiceAspect>toList(IterableExtensions.<ServiceAspect>filter(((Technology) _get).getServiceAspects(), _function));
    final AbstractCollection<ServiceAspect> scopeAspects = this.filterAspectsForMatching(joinPoint, declaredAspectsForJoinPoint, forExchangePattern, forCommunicationType, forProtocolsAndDataFormats);
    final Function<ServiceAspect, QualifiedName> _function_1 = (ServiceAspect it) -> {
      return QualifiedName.create(it.getQualifiedNameParts(false, true));
    };
    return Scopes.<ServiceAspect>scopeFor(scopeAspects, _function_1, 
      IScope.NULLSCOPE);
  }
  
  /**
   * Convenience method to create a scope for imports of certain types
   */
  private IScope getScopeForImportsOfType(final EObject context, final Class<? extends EObject>... types) {
    final EList<Import> allImports = EcoreUtil2.<TechnologyMapping>getContainerOfType(context, TechnologyMapping.class).getImports();
    final Function<Import, String> _function = (Import it) -> {
      return it.getImportURI();
    };
    final Iterable<Import> validImports = LemmaUtils.<Import>getImportsOfModelTypes(allImports, _function, types);
    return Scopes.scopeFor(validImports);
  }
  
  /**
   * Helper method to determine effective protocols and data formats of a microservice mapping
   */
  private Map<CommunicationType, Pair<Protocol, DataFormat>> getEffectiveProtocolsAndDataFormats(final MicroserviceMapping mapping) {
    final Map<CommunicationType, Pair<Protocol, DataFormat>> results = this.<EObject>getEffectiveProtocolsAndDataFormats(mapping.getProtocols(), null, null);
    final ArrayList<CommunicationType> missingCommunicationTypes = CollectionLiterals.<CommunicationType>newArrayList();
    boolean _containsKey = results.containsKey(CommunicationType.ASYNCHRONOUS);
    boolean _not = (!_containsKey);
    if (_not) {
      missingCommunicationTypes.add(CommunicationType.ASYNCHRONOUS);
    }
    boolean _containsKey_1 = results.containsKey(CommunicationType.SYNCHRONOUS);
    boolean _not_1 = (!_containsKey_1);
    if (_not_1) {
      missingCommunicationTypes.add(CommunicationType.SYNCHRONOUS);
    }
    boolean _isEmpty = missingCommunicationTypes.isEmpty();
    if (_isEmpty) {
      return results;
    }
    final Function1<TechnologyReference, Import> _function = (TechnologyReference it) -> {
      return it.getTechnology();
    };
    final Consumer<Import> _function_1 = (Import it) -> {
      final Technology technologyModel = LemmaUtils.<Technology>getImportedModelRoot(it.eResource(), it.getImportURI(), Technology.class);
      final Consumer<CommunicationType> _function_2 = (CommunicationType communicationType) -> {
        Protocol defaultProtocol = null;
        DataFormat defaultDataFormat = null;
        EList<Protocol> _protocols = null;
        if (technologyModel!=null) {
          _protocols=technologyModel.getProtocols();
        }
        Iterable<Protocol> _filter = null;
        if (_protocols!=null) {
          final Function1<Protocol, Boolean> _function_3 = (Protocol it_1) -> {
            CommunicationType _communicationType = it_1.getCommunicationType();
            return Boolean.valueOf(Objects.equal(_communicationType, communicationType));
          };
          _filter=IterableExtensions.<Protocol>filter(_protocols, _function_3);
        }
        Protocol _findFirst = null;
        if (_filter!=null) {
          final Function1<Protocol, Boolean> _function_4 = (Protocol it_1) -> {
            return Boolean.valueOf(it_1.isDefault());
          };
          _findFirst=IterableExtensions.<Protocol>findFirst(_filter, _function_4);
        }
        defaultProtocol = _findFirst;
        if ((defaultProtocol != null)) {
          defaultDataFormat = defaultProtocol.getDefaultFormat();
          results.put(communicationType, Pair.<Protocol, DataFormat>of(defaultProtocol, defaultDataFormat));
        }
      };
      missingCommunicationTypes.forEach(_function_2);
    };
    ListExtensions.<TechnologyReference, Import>map(mapping.getTechnologyReferences(), _function).forEach(_function_1);
    return results;
  }
  
  /**
   * Helper method to determine effective protocols and data formats of an interface mapping
   */
  private Map<CommunicationType, Pair<Protocol, DataFormat>> getEffectiveProtocolsAndDataFormats(final InterfaceMapping mapping) {
    final Function<MicroserviceMapping, Map<CommunicationType, Pair<Protocol, DataFormat>>> _function = (MicroserviceMapping it) -> {
      return this.getEffectiveProtocolsAndDataFormats(it);
    };
    return this.<MicroserviceMapping>getEffectiveProtocolsAndDataFormats(mapping.getProtocols(), mapping.getMicroserviceMapping(), _function);
  }
  
  /**
   * Helper method to determine effective protocols and data formats of an operation mapping
   */
  private Map<CommunicationType, Pair<Protocol, DataFormat>> getEffectiveProtocolsAndDataFormats(final OperationMapping mapping) {
    final Function<MicroserviceMapping, Map<CommunicationType, Pair<Protocol, DataFormat>>> _function = (MicroserviceMapping it) -> {
      return this.getEffectiveProtocolsAndDataFormats(it);
    };
    return this.<MicroserviceMapping>getEffectiveProtocolsAndDataFormats(mapping.getProtocols(), mapping.getMicroserviceMapping(), _function);
  }
  
  /**
   * Helper method to determine effective protocols and data formats of a referred operation
   * mapping
   */
  private Map<CommunicationType, Pair<Protocol, DataFormat>> getEffectiveProtocolsAndDataFormats(final ReferredOperationMapping mapping) {
    final Function<MicroserviceMapping, Map<CommunicationType, Pair<Protocol, DataFormat>>> _function = (MicroserviceMapping it) -> {
      return this.getEffectiveProtocolsAndDataFormats(it);
    };
    return this.<MicroserviceMapping>getEffectiveProtocolsAndDataFormats(mapping.getProtocols(), 
      mapping.getMicroserviceMapping(), _function);
  }
  
  /**
   * Helper method to determine effective protocol and data format for a parameter mapping with
   * consideration of its communication type
   */
  private Pair<Protocol, DataFormat> getEffectiveProtocolAndDataFormat(final ParameterMapping mapping) {
    final Map<CommunicationType, Pair<Protocol, DataFormat>> operationProtocolsAndDataFormats = this.getEffectiveProtocolsAndDataFormats(mapping.getOperationMapping());
    return operationProtocolsAndDataFormats.get(mapping.getParameter().getCommunicationType());
  }
  
  /**
   * Helper method to determine effective protocols and data formats from technology-specific
   * protocol specifications and possibly the containing concept, if protocol and data format
   * couldn't be determined for a communication type.
   * 
   * The method takes the following type arguments:
   *     - CONTAINER: The container of the technology-specific protocol specifications.
   * 
   * The function argument of the method returns for a given CONTAINER object the effective
   * protocols and data formats.
   */
  protected <CONTAINER extends EObject> Map<CommunicationType, Pair<Protocol, DataFormat>> getEffectiveProtocolsAndDataFormats(final List<TechnologySpecificProtocolSpecification> protocolSpecifications, final CONTAINER container, final Function<CONTAINER, Map<CommunicationType, Pair<Protocol, DataFormat>>> getFromContainer) {
    final Map<CommunicationType, Pair<Protocol, DataFormat>> results = CollectionLiterals.<CommunicationType, Pair<Protocol, DataFormat>>newHashMap();
    final ArrayList<CommunicationType> missingCommunicationTypes = CollectionLiterals.<CommunicationType>newArrayList();
    ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, 2, true);
    for (final Integer i : _doubleDotLessThan) {
      {
        CommunicationType _switchResult = null;
        if (i != null) {
          switch (i) {
            case 0:
              _switchResult = CommunicationType.ASYNCHRONOUS;
              break;
            case 1:
              _switchResult = CommunicationType.SYNCHRONOUS;
              break;
          }
        }
        final CommunicationType communicationType = _switchResult;
        Protocol protocol = null;
        DataFormat dataFormat = null;
        final Function1<TechnologySpecificProtocolSpecification, Boolean> _function = (TechnologySpecificProtocolSpecification it) -> {
          CommunicationType _communicationType = it.getCommunicationType();
          return Boolean.valueOf(Objects.equal(_communicationType, communicationType));
        };
        TechnologySpecificProtocolSpecification protocolSpecification = IterableExtensions.<TechnologySpecificProtocolSpecification>findFirst(protocolSpecifications, _function);
        if ((((protocolSpecification != null) && 
          (protocolSpecification.getTechnologySpecificProtocol() != null)) && 
          (protocolSpecification.getTechnologySpecificProtocol().getProtocol() != null))) {
          protocol = protocolSpecification.getTechnologySpecificProtocol().getProtocol();
          DataFormat _elvis = null;
          DataFormat _dataFormat = protocolSpecification.getTechnologySpecificProtocol().getDataFormat();
          if (_dataFormat != null) {
            _elvis = _dataFormat;
          } else {
            DataFormat _defaultFormat = protocol.getDefaultFormat();
            _elvis = _defaultFormat;
          }
          dataFormat = _elvis;
        }
        if ((protocol != null)) {
          results.put(communicationType, Pair.<Protocol, DataFormat>of(protocol, dataFormat));
        } else {
          missingCommunicationTypes.add(communicationType);
        }
      }
    }
    if ((((container != null) && (getFromContainer != null)) && (!missingCommunicationTypes.isEmpty()))) {
      final Map<CommunicationType, Pair<Protocol, DataFormat>> containerResults = getFromContainer.apply(container);
      final Function1<Map.Entry<CommunicationType, Pair<Protocol, DataFormat>>, Boolean> _function = (Map.Entry<CommunicationType, Pair<Protocol, DataFormat>> it) -> {
        return Boolean.valueOf(missingCommunicationTypes.contains(it.getKey()));
      };
      final Consumer<Map.Entry<CommunicationType, Pair<Protocol, DataFormat>>> _function_1 = (Map.Entry<CommunicationType, Pair<Protocol, DataFormat>> it) -> {
        results.put(it.getKey(), it.getValue());
      };
      IterableExtensions.<Map.Entry<CommunicationType, Pair<Protocol, DataFormat>>>filter(containerResults.entrySet(), _function).forEach(_function_1);
    }
    return results;
  }
}
