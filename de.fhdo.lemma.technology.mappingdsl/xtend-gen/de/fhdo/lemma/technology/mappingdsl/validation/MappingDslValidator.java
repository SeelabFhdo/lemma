/**
 * generated by Xtext 2.12.0
 */
package de.fhdo.lemma.technology.mappingdsl.validation;

import com.google.common.base.Function;
import com.google.common.base.Objects;
import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;
import de.fhdo.lemma.data.ComplexType;
import de.fhdo.lemma.data.DataField;
import de.fhdo.lemma.data.DataOperation;
import de.fhdo.lemma.data.EnumerationField;
import de.fhdo.lemma.data.PrimitiveType;
import de.fhdo.lemma.data.PrimitiveValue;
import de.fhdo.lemma.data.Type;
import de.fhdo.lemma.service.Endpoint;
import de.fhdo.lemma.service.Import;
import de.fhdo.lemma.service.ImportType;
import de.fhdo.lemma.service.ImportedProtocolAndDataFormat;
import de.fhdo.lemma.service.Interface;
import de.fhdo.lemma.service.Microservice;
import de.fhdo.lemma.service.Operation;
import de.fhdo.lemma.service.Parameter;
import de.fhdo.lemma.service.ReferredOperation;
import de.fhdo.lemma.service.ServiceModel;
import de.fhdo.lemma.service.ServicePackage;
import de.fhdo.lemma.service.TechnologyReference;
import de.fhdo.lemma.technology.CommunicationType;
import de.fhdo.lemma.technology.DataFormat;
import de.fhdo.lemma.technology.Protocol;
import de.fhdo.lemma.technology.ServiceAspect;
import de.fhdo.lemma.technology.Technology;
import de.fhdo.lemma.technology.TechnologySpecificPrimitiveType;
import de.fhdo.lemma.technology.TechnologySpecificProperty;
import de.fhdo.lemma.technology.TechnologySpecificPropertyValueAssignment;
import de.fhdo.lemma.technology.mapping.ComplexParameterMapping;
import de.fhdo.lemma.technology.mapping.ComplexTypeMapping;
import de.fhdo.lemma.technology.mapping.DataOperationMapping;
import de.fhdo.lemma.technology.mapping.DataOperationParameterMapping;
import de.fhdo.lemma.technology.mapping.DataOperationReturnTypeMapping;
import de.fhdo.lemma.technology.mapping.ImportedComplexTypeToMap;
import de.fhdo.lemma.technology.mapping.ImportedMicroservice;
import de.fhdo.lemma.technology.mapping.InterfaceMapping;
import de.fhdo.lemma.technology.mapping.MappingPackage;
import de.fhdo.lemma.technology.mapping.MicroserviceMapping;
import de.fhdo.lemma.technology.mapping.OperationMapping;
import de.fhdo.lemma.technology.mapping.ParameterMapping;
import de.fhdo.lemma.technology.mapping.PrimitiveParameterMapping;
import de.fhdo.lemma.technology.mapping.ReferredOperationMapping;
import de.fhdo.lemma.technology.mapping.TechnologyMapping;
import de.fhdo.lemma.technology.mapping.TechnologySpecificEndpoint;
import de.fhdo.lemma.technology.mapping.TechnologySpecificFieldMapping;
import de.fhdo.lemma.technology.mapping.TechnologySpecificImportedServiceAspect;
import de.fhdo.lemma.technology.mapping.TechnologySpecificProtocol;
import de.fhdo.lemma.technology.mapping.TechnologySpecificProtocolSpecification;
import de.fhdo.lemma.typechecking.TypeChecker;
import de.fhdo.lemma.typechecking.TypesNotCompatibleException;
import de.fhdo.lemma.utils.LemmaUtils;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.ExclusiveRange;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;

/**
 * This class contains validation rules for the Mapping DSL.
 * 
 * @author <a href="mailto:florian.rademacher@fh-dortmund.de">Florian Rademacher</a>
 */
@SuppressWarnings("all")
public class MappingDslValidator extends AbstractMappingDslValidator {
  /**
   * Check that model is not empty
   */
  @Check
  public void checkModelNotEmpty(final TechnologyMapping model) {
    final boolean modelEmpty = (model.getTypeMappings().isEmpty() && model.getServiceMappings().isEmpty());
    if (modelEmpty) {
      this.error("Model must define at least one type or service mapping", model, 
        MappingPackage.Literals.TECHNOLOGY_MAPPING__TYPE_MAPPINGS);
    }
  }
  
  /**
   * Check that imported file is imported exactly once
   */
  @Check
  public void checkImportFileUniqueness(final TechnologyMapping model) {
    final Function<Import, String> _function = (Import it) -> {
      return it.getImportURI();
    };
    final Integer duplicateIndex = LemmaUtils.<Import, String>getDuplicateIndex(model.getImports(), _function);
    if (((duplicateIndex).intValue() == (-1))) {
      return;
    }
    final Import duplicate = model.getImports().get((duplicateIndex).intValue());
    this.error("File is already being imported", duplicate, 
      ServicePackage.Literals.IMPORT__IMPORT_URI);
  }
  
  /**
   * Check import aliases for uniqueness
   */
  @Check
  public void checkImportAlias(final TechnologyMapping model) {
    final Function<Import, String> _function = (Import it) -> {
      return it.getName();
    };
    final Integer duplicateIndex = LemmaUtils.<Import, String>getDuplicateIndex(model.getImports(), _function);
    if (((duplicateIndex).intValue() == (-1))) {
      return;
    }
    final Import duplicate = model.getImports().get((duplicateIndex).intValue());
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("Duplicate import alias ");
    String _name = duplicate.getName();
    _builder.append(_name);
    this.error(_builder.toString(), duplicate, 
      ServicePackage.Literals.IMPORT__NAME);
  }
  
  /**
   * Check that technology is assigned only once to a complex type mapping
   */
  @Check
  public void checkTechnologyUniqueness(final ComplexTypeMapping mapping) {
    final String absolutePath = LemmaUtils.absolutePath(mapping.eResource());
    final Function1<TechnologyReference, String> _function = (TechnologyReference it) -> {
      return LemmaUtils.convertToAbsolutePath(it.getTechnology().getImportURI(), absolutePath);
    };
    final List<String> absoluteImportPaths = ListExtensions.<TechnologyReference, String>map(mapping.getTechnologyReferences(), _function);
    final Function<String, String> _function_1 = (String it) -> {
      return it;
    };
    final Integer duplicateIndex = LemmaUtils.<String, String>getDuplicateIndex(absoluteImportPaths, _function_1);
    if (((duplicateIndex).intValue() > (-1))) {
      this.error(
        "Duplicate technology assignment", 
        MappingPackage.Literals.COMPLEX_TYPE_MAPPING__TECHNOLOGY_REFERENCES, (duplicateIndex).intValue());
    }
  }
  
  /**
   * Check that technology is assigned only once to a microservice
   */
  @Check
  public void checkTechnologyUniqueness(final MicroserviceMapping mapping) {
    final Function1<TechnologyReference, Import> _function = (TechnologyReference it) -> {
      return it.getTechnology();
    };
    final Function<Import, Import> _function_1 = (Import it) -> {
      return it;
    };
    final Integer duplicateIndex = LemmaUtils.<Import, Import>getDuplicateIndex(
      ListExtensions.<TechnologyReference, Import>map(mapping.getTechnologyReferences(), _function), _function_1);
    if (((duplicateIndex).intValue() > (-1))) {
      this.error(
        "Duplicate technology assignment", 
        MappingPackage.Literals.MICROSERVICE_MAPPING__TECHNOLOGY_REFERENCES, (duplicateIndex).intValue());
    }
  }
  
  /**
   * Check that only one annotated technology of a microservice mapping contains type definitions
   */
  @Check
  public void checkUniqueTypeDefinitionTechnologyForMicroserviceMapping(final MicroserviceMapping mapping) {
    this.checkUniqueTypeDefinitionTechnology(mapping);
  }
  
  /**
   * Check that only one annotated technology of a complex type mapping contains type definitions
   */
  @Check
  public void checkUniqueTypeDefinitionTechnologyForComplexTypeMapping(final ComplexTypeMapping mapping) {
    this.checkUniqueTypeDefinitionTechnology(mapping);
  }
  
  /**
   * Helper for complex type and microservice mappings to check that only one annotated technology
   * contains type definitions or that one type definition technology is marked as the default one
   */
  public void checkUniqueTypeDefinitionTechnology(final EObject mapping) {
    List<TechnologyReference> technologyReferences = null;
    List<TechnologyReference> typeDefinitionTechnologyReferences = null;
    EReference technologyReferenceFeature = null;
    boolean _matched = false;
    if (mapping instanceof ComplexTypeMapping) {
      _matched=true;
      technologyReferences = ((ComplexTypeMapping)mapping).getTechnologyReferences();
      typeDefinitionTechnologyReferences = ((ComplexTypeMapping)mapping).getAllTypeDefinitionTechnologyReferences();
      technologyReferenceFeature = MappingPackage.Literals.COMPLEX_TYPE_MAPPING__TECHNOLOGY_REFERENCES;
    }
    if (!_matched) {
      if (mapping instanceof MicroserviceMapping) {
        _matched=true;
        technologyReferences = ((MicroserviceMapping)mapping).getTechnologyReferences();
        typeDefinitionTechnologyReferences = ((MicroserviceMapping)mapping).getAllTypeDefinitionTechnologyReferences();
        technologyReferenceFeature = MappingPackage.Literals.MICROSERVICE_MAPPING__TECHNOLOGY_REFERENCES;
      }
    }
    if (!_matched) {
      return;
    }
    final Function1<TechnologyReference, Boolean> _function = (TechnologyReference it) -> {
      return Boolean.valueOf(it.isIsTypeDefinitionTechnology());
    };
    final Function<Boolean, Boolean> _function_1 = (Boolean it) -> {
      return it;
    };
    final Predicate<Boolean> _function_2 = (Boolean it) -> {
      return (it == Boolean.valueOf(true));
    };
    final Integer duplicateIndex = LemmaUtils.<Boolean, Boolean>getDuplicateIndex(
      ListExtensions.<TechnologyReference, Boolean>map(technologyReferences, _function), _function_1, _function_2);
    if (((duplicateIndex).intValue() > (-1))) {
      this.error("Only one technology can be the default type definition technology", technologyReferenceFeature, (duplicateIndex).intValue());
      return;
    }
    final Function1<TechnologyReference, Boolean> _function_3 = (TechnologyReference it) -> {
      return Boolean.valueOf(it.isIsTypeDefinitionTechnology());
    };
    boolean _exists = IterableExtensions.<TechnologyReference>exists(technologyReferences, _function_3);
    if (_exists) {
      return;
    }
    if ((typeDefinitionTechnologyReferences.isEmpty() || 
      (typeDefinitionTechnologyReferences.size() == 1))) {
      return;
    }
    final Consumer<TechnologyReference> _function_4 = (TechnologyReference it) -> {
      this.error(("More than one type definition technology detected. One of them needs to " + 
        "explicitly be selected as the default type definition technology."), it, 
        ServicePackage.Literals.TECHNOLOGY_REFERENCE__TECHNOLOGY);
    };
    typeDefinitionTechnologyReferences.forEach(_function_4);
  }
  
  /**
   * Check that annotated technologies of complex type mappings define not only deployment-related
   * concepts
   */
  @Check
  public void checkTechnologiesForServiceConcepts(final ComplexTypeMapping mapping) {
    final Function1<TechnologyReference, Import> _function = (TechnologyReference it) -> {
      return it.getTechnology();
    };
    this.checkTechnologiesForServiceConcepts(mapping, ListExtensions.<TechnologyReference, Import>map(mapping.getTechnologyReferences(), _function), 
      MappingPackage.Literals.COMPLEX_TYPE_MAPPING__TECHNOLOGY_REFERENCES);
  }
  
  /**
   * Check that annotated technologies of microservice mappings define not only deployment-related
   * concepts
   */
  @Check
  public void checkTechnologiesForServiceConcepts(final MicroserviceMapping mapping) {
    final Function1<TechnologyReference, Import> _function = (TechnologyReference it) -> {
      return it.getTechnology();
    };
    this.checkTechnologiesForServiceConcepts(mapping, ListExtensions.<TechnologyReference, Import>map(mapping.getTechnologyReferences(), _function), 
      MappingPackage.Literals.MICROSERVICE_MAPPING__TECHNOLOGY_REFERENCES);
  }
  
  /**
   * Helper to check that annotated technologies define not only deployment-related concepts
   */
  public void checkTechnologiesForServiceConcepts(final EObject mapping, final List<Import> technologies, final EReference feature) {
    int _size = technologies.size();
    ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, _size, true);
    for (final Integer i : _doubleDotLessThan) {
      {
        final Import technologyImport = technologies.get((i).intValue());
        final Technology technologyModel = LemmaUtils.<Technology>getImportedModelRoot(technologyImport.eResource(), 
          technologyImport.getImportURI(), Technology.class);
        if (((technologyModel.getPrimitiveTypes().isEmpty() && 
          technologyModel.getProtocols().isEmpty()) && 
          technologyModel.getServiceAspects().isEmpty())) {
          this.error("Technology does not specify service-related concepts", mapping, feature, (i).intValue());
        }
      }
    }
  }
  
  /**
   * Check that a microservice specifies protocols that match its operation parameters'
   * communication types
   */
  @Check
  public void checkEffectiveProtocols(final MicroserviceMapping mapping) {
    this.checkEffectiveProtocolsForCommunicationType(mapping, CommunicationType.ASYNCHRONOUS);
    this.checkEffectiveProtocolsForCommunicationType(mapping, CommunicationType.SYNCHRONOUS);
  }
  
  /**
   * Helper to check if a microservice specifies protocols for its operation parameters'
   * communication types
   */
  private void checkEffectiveProtocolsForCommunicationType(final MicroserviceMapping mapping, final CommunicationType communicationType) {
    final Function1<TechnologySpecificProtocolSpecification, Boolean> _function = (TechnologySpecificProtocolSpecification it) -> {
      CommunicationType _communicationType = it.getCommunicationType();
      return Boolean.valueOf(Objects.equal(_communicationType, communicationType));
    };
    final TechnologySpecificProtocolSpecification explicitProtocol = IterableExtensions.<TechnologySpecificProtocolSpecification>findFirst(mapping.getProtocols(), _function);
    if ((explicitProtocol != null)) {
      return;
    }
    final Protocol implicitProtocol = this.getEffectiveDefaultProtocol(mapping, communicationType);
    if ((implicitProtocol != null)) {
      return;
    }
    final Microservice mappedMicroservice = mapping.getMicroservice().getMicroservice();
    boolean parameterForMissingProtocolExists = (IterableExtensions.<Operation>exists(mappedMicroservice.getContainedOperations(), 
      ((Function1<Operation, Boolean>) (Operation it) -> {
        final Function1<Parameter, Boolean> _function_1 = (Parameter it_1) -> {
          CommunicationType _communicationType = it_1.getCommunicationType();
          return Boolean.valueOf(Objects.equal(_communicationType, communicationType));
        };
        return Boolean.valueOf(IterableExtensions.<Parameter>exists(it.getParameters(), _function_1));
      })) || 
      IterableExtensions.<ReferredOperation>exists(mappedMicroservice.getContainedReferredOperations(), 
        ((Function1<ReferredOperation, Boolean>) (ReferredOperation it) -> {
          final Function1<Parameter, Boolean> _function_1 = (Parameter it_1) -> {
            CommunicationType _communicationType = it_1.getCommunicationType();
            return Boolean.valueOf(Objects.equal(_communicationType, communicationType));
          };
          return Boolean.valueOf(IterableExtensions.<Parameter>exists(it.getOperation().getParameters(), _function_1));
        })));
    if (parameterForMissingProtocolExists) {
      String _switchResult = null;
      if (communicationType != null) {
        switch (communicationType) {
          case SYNCHRONOUS:
            _switchResult = "synchronous";
            break;
          case ASYNCHRONOUS:
            _switchResult = "asynchronous";
            break;
          default:
            break;
        }
      }
      final String communicationTypeOutputString = _switchResult;
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Microservice does not specify ");
      _builder.append(communicationTypeOutputString);
      _builder.append(" protocol, ");
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("but its operations define ");
      _builder_1.append(communicationTypeOutputString);
      _builder_1.append(" parameters");
      String _plus = (_builder.toString() + _builder_1);
      this.error(_plus, mapping, MappingPackage.Literals.MICROSERVICE_MAPPING__MICROSERVICE);
    }
  }
  
  /**
   * Helper to find the effective default protocol of a microservice
   */
  private Protocol getEffectiveDefaultProtocol(final MicroserviceMapping mapping, final CommunicationType communicationType) {
    final Function1<TechnologyReference, Import> _function = (TechnologyReference it) -> {
      return it.getTechnology();
    };
    List<Import> _map = ListExtensions.<TechnologyReference, Import>map(mapping.getTechnologyReferences(), _function);
    for (final Import technologyImport : _map) {
      {
        final Technology technologyModel = LemmaUtils.<Technology>getImportedModelRoot(technologyImport.eResource(), 
          technologyImport.getImportURI(), Technology.class);
        final Function1<Protocol, Boolean> _function_1 = (Protocol it) -> {
          return Boolean.valueOf((it.isDefault() && (it.getCommunicationType() == communicationType)));
        };
        final Protocol defaultProtocolOfTechnology = IterableExtensions.<Protocol>findFirst(technologyModel.getProtocols(), _function_1);
        if ((defaultProtocolOfTechnology != null)) {
          return defaultProtocolOfTechnology;
        }
      }
    }
    return null;
  }
  
  /**
   * Check technologies of a microservice mapping per communication type for unambiguous default
   * protocols
   */
  @Check
  public void checkTechnologiesForUniqueDefaultProtocols(final MicroserviceMapping mapping) {
    boolean _isEmpty = mapping.getTechnologyReferences().isEmpty();
    if (_isEmpty) {
      return;
    }
    final Function1<CommunicationType, Boolean> _function = (CommunicationType communicationType) -> {
      final Function1<TechnologySpecificProtocolSpecification, Boolean> _function_1 = (TechnologySpecificProtocolSpecification it) -> {
        CommunicationType _communicationType = it.getCommunicationType();
        return Boolean.valueOf((communicationType == _communicationType));
      };
      boolean _exists = IterableExtensions.<TechnologySpecificProtocolSpecification>exists(mapping.getProtocols(), _function_1);
      return Boolean.valueOf((!_exists));
    };
    final Function1<CommunicationType, Boolean> _function_1 = (CommunicationType it) -> {
      boolean _isDefaultProtocolUnique = this.isDefaultProtocolUnique(mapping, it);
      return Boolean.valueOf((!_isDefaultProtocolUnique));
    };
    final Iterable<CommunicationType> nonUniqueCommunicationTypes = IterableExtensions.<CommunicationType>filter(IterableExtensions.<CommunicationType>filter(((Iterable<CommunicationType>)Conversions.doWrapArray(CommunicationType.values())), _function), _function_1);
    for (final CommunicationType communicationType : nonUniqueCommunicationTypes) {
      {
        String _switchResult = null;
        if (communicationType != null) {
          switch (communicationType) {
            case ASYNCHRONOUS:
              _switchResult = "asynchronous";
              break;
            case SYNCHRONOUS:
              _switchResult = "synchronous";
              break;
            default:
              break;
          }
        }
        final String typeString = _switchResult;
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Ambiguous default protocol for ");
        _builder.append(typeString);
        _builder.append(" communication. The ");
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("mapping needs to explicitly specify a protocol for ");
        _builder_1.append(typeString);
        _builder_1.append(" ");
        String _plus = (_builder.toString() + _builder_1);
        StringConcatenation _builder_2 = new StringConcatenation();
        _builder_2.append("communication.");
        String _plus_1 = (_plus + _builder_2);
        this.error(_plus_1, mapping, 
          MappingPackage.Literals.MICROSERVICE_MAPPING__MICROSERVICE);
      }
    }
  }
  
  /**
   * Helper to check if default protocol of a microservice mapping is unique for a given
   * communication type
   */
  private boolean isDefaultProtocolUnique(final MicroserviceMapping mapping, final CommunicationType communicationType) {
    boolean alreadyFoundDefaultProtocolForCommunicationType = false;
    final Function1<TechnologyReference, Import> _function = (TechnologyReference it) -> {
      return it.getTechnology();
    };
    List<Import> _map = ListExtensions.<TechnologyReference, Import>map(mapping.getTechnologyReferences(), _function);
    for (final Import technologyImport : _map) {
      {
        final Technology technologyModel = LemmaUtils.<Technology>getImportedModelRoot(technologyImport.eResource(), 
          technologyImport.getImportURI(), Technology.class);
        final Function1<Protocol, Boolean> _function_1 = (Protocol it) -> {
          return Boolean.valueOf((it.isDefault() && (it.getCommunicationType() == communicationType)));
        };
        final boolean hasDefaultProtocolForCommunicationType = IterableExtensions.<Protocol>exists(technologyModel.getProtocols(), _function_1);
        if (hasDefaultProtocolForCommunicationType) {
          if (alreadyFoundDefaultProtocolForCommunicationType) {
            return false;
          } else {
            alreadyFoundDefaultProtocolForCommunicationType = true;
          }
        }
      }
    }
    return true;
  }
  
  /**
   * Check that service mappings are unique
   */
  @Check
  public boolean checkMicroserviceMappingUniqueness(final TechnologyMapping model) {
    boolean _xblockexpression = false;
    {
      final Function1<MicroserviceMapping, Boolean> _function = (MicroserviceMapping it) -> {
        boolean _isEmpty = it.getTechnologyReferences().isEmpty();
        return Boolean.valueOf((!_isEmpty));
      };
      final List<MicroserviceMapping> modelMappingsWithTechnology = IterableExtensions.<MicroserviceMapping>toList(IterableExtensions.<MicroserviceMapping>filter(model.getServiceMappings(), _function));
      final Function<MicroserviceMapping, String> _function_1 = (MicroserviceMapping it) -> {
        ImportedMicroservice _microservice = it.getMicroservice();
        Import _import = null;
        if (_microservice!=null) {
          _import=_microservice.getImport();
        }
        String _name = null;
        if (_import!=null) {
          _name=_import.getName();
        }
        return _name;
      };
      final Function<MicroserviceMapping, List<String>> _function_2 = (MicroserviceMapping it) -> {
        return it.getMicroservice().getMicroservice().getQualifiedNameParts();
      };
      _xblockexpression = this.<MicroserviceMapping>checkFirstLevelMappingUniqueness(modelMappingsWithTechnology, 
        "Service", _function_1, _function_2, 
        MappingPackage.Literals.MICROSERVICE_MAPPING__MICROSERVICE);
    }
    return _xblockexpression;
  }
  
  /**
   * Check that complex type mappings are unique
   */
  @Check
  public boolean checkComplexTypeMappingUniqueness(final TechnologyMapping model) {
    boolean _xblockexpression = false;
    {
      final Function1<ComplexTypeMapping, Boolean> _function = (ComplexTypeMapping it) -> {
        boolean _isEmpty = it.getTechnologyReferences().isEmpty();
        return Boolean.valueOf((!_isEmpty));
      };
      final List<ComplexTypeMapping> modelMappingsWithTechnology = IterableExtensions.<ComplexTypeMapping>toList(IterableExtensions.<ComplexTypeMapping>filter(model.getTypeMappings(), _function));
      final Function<ComplexTypeMapping, String> _function_1 = (ComplexTypeMapping it) -> {
        ImportedComplexTypeToMap _type = it.getType();
        Import _dataModelImport = null;
        if (_type!=null) {
          _dataModelImport=_type.getDataModelImport();
        }
        String _name = null;
        if (_dataModelImport!=null) {
          _name=_dataModelImport.getName();
        }
        return _name;
      };
      final Function<ComplexTypeMapping, List<String>> _function_2 = (ComplexTypeMapping it) -> {
        return it.getType().getType().getQualifiedNameParts();
      };
      _xblockexpression = this.<ComplexTypeMapping>checkFirstLevelMappingUniqueness(modelMappingsWithTechnology, 
        "Type", _function_1, _function_2, 
        MappingPackage.Literals.COMPLEX_TYPE_MAPPING__TYPE);
    }
    return _xblockexpression;
  }
  
  /**
   * Helper to check that mappings of elements on the first level of the mapping model like
   * complex types and microservices are unique. This check considers duplicate mappings of
   * elements defined in the same source model, as well as duplicate mappings of elements from
   * different source models.
   */
  private <T extends EObject> boolean checkFirstLevelMappingUniqueness(final List<T> mappings, final String mappingName, final Function<T, String> getImportName, final Function<T, List<String>> getQualifiedNameParts, final EReference mappedElementFeature) {
    boolean _xblockexpression = false;
    {
      final Function<T, String> _function = (T it) -> {
        String _xblockexpression_1 = null;
        {
          final ArrayList<String> qualifiedNameSegments = CollectionLiterals.<String>newArrayList();
          final String importName = getImportName.apply(it);
          if ((importName != null)) {
            qualifiedNameSegments.add(importName);
          }
          qualifiedNameSegments.addAll(getQualifiedNameParts.apply(it));
          _xblockexpression_1 = QualifiedName.create(qualifiedNameSegments).toString();
        }
        return _xblockexpression_1;
      };
      final boolean duplicateMappingFound = this.<T>checkMappingUniqueness(mappings, mappingName, _function, mappedElementFeature);
      boolean _xifexpression = false;
      if ((!duplicateMappingFound)) {
        final Function<T, String> _function_1 = (T it) -> {
          return QualifiedName.create(getQualifiedNameParts.apply(it)).toString();
        };
        StringConcatenation _builder = new StringConcatenation();
        _builder.append(mappingName);
        _builder.append(" with the same qualified name but from another model has ");
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("already been mapped");
        String _plus = (_builder.toString() + _builder_1);
        _xifexpression = this.<T>checkMappingUniqueness(mappings, _function_1, mappedElementFeature, _plus);
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  /**
   * Check that data operation mappings are unique
   */
  @Check
  public boolean checkDataOperationMappingUniqueness(final ComplexTypeMapping typeMapping) {
    final Function<DataOperationMapping, String> _function = (DataOperationMapping it) -> {
      return QualifiedName.create(it.getDataOperation().getQualifiedNameParts()).toString();
    };
    return this.<DataOperationMapping>checkMappingUniqueness(typeMapping.getOperationMappings(), "Data operation", _function, 
      MappingPackage.Literals.DATA_OPERATION_MAPPING__DATA_OPERATION);
  }
  
  /**
   * Check that data operation maps its return type only if the original data operation has a
   * return type
   */
  @Check
  public void checkDataOperationReturnTypeMapping(final DataOperationReturnTypeMapping returnTypeMapping) {
    final DataOperation originalOperation = returnTypeMapping.getOperationMapping().getDataOperation();
    boolean _isHasNoReturnType = originalOperation.isHasNoReturnType();
    if (_isHasNoReturnType) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Domain operation ");
      String _name = originalOperation.getName();
      _builder.append(_name);
      _builder.append(" has no return type");
      this.error(_builder.toString(), 
        returnTypeMapping.getOperationMapping(), 
        MappingPackage.Literals.DATA_OPERATION_MAPPING__RETURN_TYPE_MAPPING);
    }
  }
  
  /**
   * Check that data operation parameter mappings are unique
   */
  @Check
  public boolean checkDataOperationParameterMappingUniqueness(final DataOperationMapping operationMapping) {
    final Function<DataOperationParameterMapping, String> _function = (DataOperationParameterMapping it) -> {
      return QualifiedName.create(it.getParameter().getQualifiedNameParts()).toString();
    };
    return this.<DataOperationParameterMapping>checkMappingUniqueness(operationMapping.getParameterMappings(), "Parameter", _function, 
      MappingPackage.Literals.DATA_OPERATION_PARAMETER_MAPPING__PARAMETER);
  }
  
  /**
   * Check that interface mappings are unique
   */
  @Check
  public boolean checkInterfaceMappingUniqueness(final MicroserviceMapping microserviceMapping) {
    final Function<InterfaceMapping, String> _function = (InterfaceMapping it) -> {
      return QualifiedName.create(it.getInterface().getQualifiedNameParts()).toString();
    };
    return this.<InterfaceMapping>checkMappingUniqueness(microserviceMapping.getInterfaceMappings(), "Interface", _function, 
      MappingPackage.Literals.INTERFACE_MAPPING__INTERFACE);
  }
  
  /**
   * Check that operation mappings are unique
   */
  @Check
  public boolean checkOperationMappingUniqueness(final MicroserviceMapping microserviceMapping) {
    final Function<OperationMapping, String> _function = (OperationMapping it) -> {
      return QualifiedName.create(it.getOperation().getQualifiedNameParts()).toString();
    };
    return this.<OperationMapping>checkMappingUniqueness(microserviceMapping.getOperationMappings(), "Operation", _function, 
      MappingPackage.Literals.OPERATION_MAPPING__OPERATION);
  }
  
  /**
   * Check that referred operation mappings are unique
   */
  @Check
  public boolean checkReferredOperationMappingUniqueness(final MicroserviceMapping microserviceMapping) {
    final Function<ReferredOperationMapping, String> _function = (ReferredOperationMapping it) -> {
      return QualifiedName.create(it.getOperation().getQualifiedNameParts()).toString();
    };
    return this.<ReferredOperationMapping>checkMappingUniqueness(microserviceMapping.getReferredOperationMappings(), "Referred operation", _function, 
      MappingPackage.Literals.REFERRED_OPERATION_MAPPING__OPERATION);
  }
  
  /**
   * Check that communication types and endpoint protocols of technology-specific protocol
   * specifications of a microservice mapping are unique
   */
  @Check
  public void checkProtocolSpecificationCommunicationTypesUniqueness(final MicroserviceMapping microserviceMapping) {
    this.checkCommunicationTypeUniqueness(microserviceMapping.getProtocols());
    this.checkEndpointProtocolUniqueness(microserviceMapping.getEndpoints());
  }
  
  /**
   * Check that communication types and endpoint protocols  of technology-specific protocol
   * specifications of an interface mapping are unique
   */
  @Check
  public void checkProtocolSpecificationCommunicationTypesUniqueness(final InterfaceMapping interfaceMapping) {
    this.checkCommunicationTypeUniqueness(interfaceMapping.getProtocols());
    this.checkEndpointProtocolUniqueness(interfaceMapping.getEndpoints());
  }
  
  /**
   * Check that communication types and endpoint protocols  of technology-specific protocol
   * specifications of an operation mapping are unique
   */
  @Check
  public void checkProtocolSpecificationCommunicationTypesUniqueness(final OperationMapping operationMapping) {
    this.checkCommunicationTypeUniqueness(operationMapping.getProtocols());
    this.checkEndpointProtocolUniqueness(operationMapping.getEndpoints());
  }
  
  /**
   * Check that communication types and endpoint protocols  of technology-specific protocol
   * specifications of a referred operation mapping are unique
   */
  @Check
  public void checkProtocolSpecificationCommunicationTypesUniqueness(final ReferredOperationMapping operationMapping) {
    this.checkCommunicationTypeUniqueness(operationMapping.getProtocols());
    this.checkEndpointProtocolUniqueness(operationMapping.getEndpoints());
  }
  
  /**
   * Helper to check that protocol/format combinations in endpoint mappings are unique
   */
  private void checkEndpointProtocolUniqueness(final List<TechnologySpecificEndpoint> endpoints) {
    final HashSet<String> protocolSet = CollectionLiterals.<String>newHashSet();
    final Consumer<TechnologySpecificEndpoint> _function = (TechnologySpecificEndpoint endpoint) -> {
      int _size = endpoint.getTechnologySpecificProtocols().size();
      ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, _size, true);
      for (final Integer i : _doubleDotLessThan) {
        {
          final TechnologySpecificProtocol technologySpecificProtocol = endpoint.getTechnologySpecificProtocols().get((i).intValue());
          String protocolId = technologySpecificProtocol.getProtocol().getName();
          if ((protocolId != null)) {
            String _xifexpression = null;
            DataFormat _dataFormat = technologySpecificProtocol.getDataFormat();
            boolean _tripleNotEquals = (_dataFormat != null);
            if (_tripleNotEquals) {
              _xifexpression = technologySpecificProtocol.getDataFormat().getFormatName();
            } else {
              _xifexpression = technologySpecificProtocol.getProtocol().getDefaultFormat().getFormatName();
            }
            final String formatName = _xifexpression;
            String _protocolId = protocolId;
            StringConcatenation _builder = new StringConcatenation();
            _builder.append("(");
            _builder.append(formatName);
            _builder.append(")");
            protocolId = (_protocolId + _builder);
          }
          boolean _xifexpression_1 = false;
          if ((protocolId != null)) {
            boolean _add = protocolSet.add(protocolId);
            _xifexpression_1 = (!_add);
          } else {
            _xifexpression_1 = false;
          }
          final boolean isDuplicate = _xifexpression_1;
          if (isDuplicate) {
            StringConcatenation _builder_1 = new StringConcatenation();
            _builder_1.append("Duplicate protocol specification for endpoint ");
            _builder_1.append(protocolId);
            this.error(_builder_1.toString(), endpoint, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_ENDPOINT__TECHNOLOGY_SPECIFIC_PROTOCOLS, (i).intValue());
          }
        }
      }
    };
    endpoints.forEach(_function);
  }
  
  /**
   * Check uniqueness of an endpoint's addresses
   */
  @Check
  public void checkUniqueEndpointAddresses(final TechnologySpecificEndpoint endpoint) {
    final Function<String, String> _function = (String it) -> {
      return it;
    };
    final Integer duplicateIndex = LemmaUtils.<String, String>getDuplicateIndex(endpoint.getAddresses(), _function);
    if (((duplicateIndex).intValue() > (-1))) {
      final String duplicate = endpoint.getAddresses().get((duplicateIndex).intValue());
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Duplicate address ");
      _builder.append(duplicate);
      this.error(_builder.toString(), endpoint, 
        MappingPackage.Literals.TECHNOLOGY_SPECIFIC_ENDPOINT__ADDRESSES, (duplicateIndex).intValue());
    }
  }
  
  /**
   * Warn about non-unique microservice endpoints' addresses per protocol/data format combination
   */
  @Check
  public void warnUniqueEndpointAddresses(final TechnologyMapping model) {
    final Function1<Import, Boolean> _function = (Import it) -> {
      ImportType _importType = it.getImportType();
      return Boolean.valueOf((_importType == ImportType.MICROSERVICES));
    };
    final Function1<Import, ServiceModel> _function_1 = (Import it) -> {
      ServiceModel _xblockexpression = null;
      {
        final String modelFileUri = LemmaUtils.absoluteFileUriFromResourceBase(it.getImportURI(), it.eResource());
        _xblockexpression = LemmaUtils.<ServiceModel>getImportedModelRoot(it.eResource(), modelFileUri, ServiceModel.class);
      }
      return _xblockexpression;
    };
    final Iterable<ServiceModel> allImportedServiceModels = IterableExtensions.<Import, ServiceModel>map(IterableExtensions.<Import>filter(model.getImports(), _function), _function_1);
    final Function1<MicroserviceMapping, Microservice> _function_2 = (MicroserviceMapping it) -> {
      return it.getMicroservice().getMicroservice();
    };
    final List<Microservice> allMappedMicroservices = IterableExtensions.<Microservice>toList(ListExtensions.<MicroserviceMapping, Microservice>map(model.getServiceMappings(), _function_2));
    final Function1<ServiceModel, EList<Microservice>> _function_3 = (ServiceModel it) -> {
      return it.getMicroservices();
    };
    final Function1<Microservice, Boolean> _function_4 = (Microservice it) -> {
      boolean _contains = allMappedMicroservices.contains(it);
      return Boolean.valueOf((!_contains));
    };
    final Iterable<Microservice> nonMappedMicroservices = IterableExtensions.<Microservice>filter(Iterables.<Microservice>concat(IterableExtensions.<ServiceModel, EList<Microservice>>map(allImportedServiceModels, _function_3)), _function_4);
    final Function1<MicroserviceMapping, EList<TechnologySpecificEndpoint>> _function_5 = (MicroserviceMapping it) -> {
      return it.getEndpoints();
    };
    final List<TechnologySpecificEndpoint> allMappedEndpoints = IterableExtensions.<TechnologySpecificEndpoint>toList(Iterables.<TechnologySpecificEndpoint>concat(ListExtensions.<MicroserviceMapping, EList<TechnologySpecificEndpoint>>map(model.getServiceMappings(), _function_5)));
    final Function1<Microservice, EList<Endpoint>> _function_6 = (Microservice it) -> {
      return it.getEndpoints();
    };
    final List<Endpoint> nonMappedEndpoints = IterableExtensions.<Endpoint>toList(Iterables.<Endpoint>concat(IterableExtensions.<Microservice, EList<Endpoint>>map(nonMappedMicroservices, _function_6)));
    final Function<EObject, String> _function_7 = (EObject it) -> {
      String _xifexpression = null;
      if ((it instanceof Endpoint)) {
        _xifexpression = ((Endpoint)it).getMicroservice().buildQualifiedName(".");
      } else {
        String _xifexpression_1 = null;
        if ((it instanceof TechnologySpecificEndpoint)) {
          _xifexpression_1 = ((TechnologySpecificEndpoint)it).getMicroserviceMapping().getMicroservice().getMicroservice().buildQualifiedName(".");
        } else {
          _xifexpression_1 = null;
        }
        _xifexpression = _xifexpression_1;
      }
      return _xifexpression;
    };
    this.warnUniqueEndpointAddresses(allMappedEndpoints, nonMappedEndpoints, "microservice", _function_7);
  }
  
  /**
   * Warn about non-unique interface endpoints' addresses per protocol/data format combination
   */
  @Check
  public void warnUniqueEndpointAddresses(final MicroserviceMapping serviceMapping) {
    final Function1<InterfaceMapping, Interface> _function = (InterfaceMapping it) -> {
      return it.getInterface();
    };
    final List<Interface> mappedInterfaces = ListExtensions.<InterfaceMapping, Interface>map(serviceMapping.getInterfaceMappings(), _function);
    final Function1<Interface, Boolean> _function_1 = (Interface it) -> {
      boolean _contains = mappedInterfaces.contains(it);
      return Boolean.valueOf((!_contains));
    };
    final Iterable<Interface> nonMappedInterfaces = IterableExtensions.<Interface>filter(serviceMapping.getMicroservice().getMicroservice().getInterfaces(), _function_1);
    final Function1<InterfaceMapping, EList<TechnologySpecificEndpoint>> _function_2 = (InterfaceMapping it) -> {
      return it.getEndpoints();
    };
    final List<TechnologySpecificEndpoint> allMappedEndpoints = IterableExtensions.<TechnologySpecificEndpoint>toList(Iterables.<TechnologySpecificEndpoint>concat(ListExtensions.<InterfaceMapping, EList<TechnologySpecificEndpoint>>map(serviceMapping.getInterfaceMappings(), _function_2)));
    final Function1<Interface, EList<Endpoint>> _function_3 = (Interface it) -> {
      return it.getEndpoints();
    };
    final List<Endpoint> nonMappedEndpoints = IterableExtensions.<Endpoint>toList(Iterables.<Endpoint>concat(IterableExtensions.<Interface, EList<Endpoint>>map(nonMappedInterfaces, _function_3)));
    final Function<EObject, String> _function_4 = (EObject it) -> {
      String _xifexpression = null;
      if ((it instanceof Endpoint)) {
        _xifexpression = ((Endpoint)it).getInterface().buildQualifiedName(".");
      } else {
        String _xifexpression_1 = null;
        if ((it instanceof TechnologySpecificEndpoint)) {
          _xifexpression_1 = ((TechnologySpecificEndpoint)it).getInterfaceMapping().getInterface().buildQualifiedName(".");
        } else {
          _xifexpression_1 = null;
        }
        _xifexpression = _xifexpression_1;
      }
      return _xifexpression;
    };
    this.warnUniqueEndpointAddresses(allMappedEndpoints, nonMappedEndpoints, "interface", _function_4);
  }
  
  /**
   * Warn if operation and referred operation endpoints' addresses are not unique per
   * protocol/data format combination
   */
  @Check
  public void warnUniqueEndpointAddressesOfOperations(final MicroserviceMapping serviceMapping) {
    final Function1<OperationMapping, Interface> _function = (OperationMapping it) -> {
      return it.getOperation().getInterface();
    };
    Set<Interface> _set = IterableExtensions.<Interface>toSet(ListExtensions.<OperationMapping, Interface>map(serviceMapping.getOperationMappings(), _function));
    final Function1<ReferredOperationMapping, Interface> _function_1 = (ReferredOperationMapping it) -> {
      return it.getOperation().getInterface();
    };
    Set<Interface> _set_1 = IterableExtensions.<Interface>toSet(ListExtensions.<ReferredOperationMapping, Interface>map(serviceMapping.getReferredOperationMappings(), _function_1));
    final Iterable<Interface> mappedOperationsInterfaces = Iterables.<Interface>concat(_set, _set_1);
    final Microservice mappedMicroservice = serviceMapping.getMicroservice().getMicroservice();
    final Consumer<Interface> _function_2 = (Interface currentInterface) -> {
      final Function1<OperationMapping, Boolean> _function_3 = (OperationMapping it) -> {
        Interface _interface = it.getOperation().getInterface();
        return Boolean.valueOf(Objects.equal(_interface, currentInterface));
      };
      Iterable<OperationMapping> _filter = IterableExtensions.<OperationMapping>filter(serviceMapping.getOperationMappings(), _function_3);
      final Function1<ReferredOperationMapping, Boolean> _function_4 = (ReferredOperationMapping it) -> {
        Interface _interface = it.getOperation().getInterface();
        return Boolean.valueOf(Objects.equal(_interface, currentInterface));
      };
      Iterable<ReferredOperationMapping> _filter_1 = IterableExtensions.<ReferredOperationMapping>filter(serviceMapping.getReferredOperationMappings(), _function_4);
      final List<EObject> mappedOperationsOfInterface = IterableExtensions.<EObject>toList(Iterables.<EObject>concat(_filter, _filter_1));
      final Function1<Operation, Boolean> _function_5 = (Operation it) -> {
        return Boolean.valueOf((Objects.equal(it.getInterface(), currentInterface) && 
          (!mappedOperationsOfInterface.contains(it))));
      };
      Iterable<Operation> _filter_2 = IterableExtensions.<Operation>filter(mappedMicroservice.getContainedOperations(), _function_5);
      final Function1<ReferredOperation, Boolean> _function_6 = (ReferredOperation it) -> {
        return Boolean.valueOf((Objects.equal(it.getInterface(), currentInterface) && 
          (!mappedOperationsOfInterface.contains(it))));
      };
      Iterable<ReferredOperation> _filter_3 = IterableExtensions.<ReferredOperation>filter(mappedMicroservice.getContainedReferredOperations(), _function_6);
      final List<EObject> nonMappedOperationsOfInterface = IterableExtensions.<EObject>toList(Iterables.<EObject>concat(_filter_2, _filter_3));
      final Function1<EObject, EList<TechnologySpecificEndpoint>> _function_7 = (EObject it) -> {
        EList<TechnologySpecificEndpoint> _xifexpression = null;
        if ((it instanceof OperationMapping)) {
          _xifexpression = ((OperationMapping)it).getEndpoints();
        } else {
          EList<TechnologySpecificEndpoint> _xifexpression_1 = null;
          if ((it instanceof ReferredOperationMapping)) {
            _xifexpression_1 = ((ReferredOperationMapping)it).getEndpoints();
          }
          _xifexpression = _xifexpression_1;
        }
        return _xifexpression;
      };
      final List<TechnologySpecificEndpoint> allMappedEndpoints = IterableExtensions.<TechnologySpecificEndpoint>toList(Iterables.<TechnologySpecificEndpoint>concat(ListExtensions.<EObject, EList<TechnologySpecificEndpoint>>map(mappedOperationsOfInterface, _function_7)));
      final Function1<EObject, EList<Endpoint>> _function_8 = (EObject it) -> {
        EList<Endpoint> _xifexpression = null;
        if ((it instanceof Operation)) {
          _xifexpression = ((Operation)it).getEndpoints();
        } else {
          EList<Endpoint> _xifexpression_1 = null;
          if ((it instanceof ReferredOperation)) {
            _xifexpression_1 = ((ReferredOperation)it).getEndpoints();
          }
          _xifexpression = _xifexpression_1;
        }
        return _xifexpression;
      };
      final List<Endpoint> nonMappedEndpoints = IterableExtensions.<Endpoint>toList(Iterables.<Endpoint>concat(ListExtensions.<EObject, EList<Endpoint>>map(nonMappedOperationsOfInterface, _function_8)));
      final Function<EObject, String> _function_9 = (EObject it) -> {
        String _xifexpression = null;
        if ((it instanceof Endpoint)) {
          String _xifexpression_1 = null;
          Operation _operation = ((Endpoint)it).getOperation();
          boolean _tripleNotEquals = (_operation != null);
          if (_tripleNotEquals) {
            _xifexpression_1 = ((Endpoint)it).getOperation().buildQualifiedName(".");
          } else {
            String _xifexpression_2 = null;
            ReferredOperation _referredOperation = ((Endpoint)it).getReferredOperation();
            boolean _tripleNotEquals_1 = (_referredOperation != null);
            if (_tripleNotEquals_1) {
              _xifexpression_2 = ((Endpoint)it).getReferredOperation().buildQualifiedName(".");
            }
            _xifexpression_1 = _xifexpression_2;
          }
          _xifexpression = _xifexpression_1;
        } else {
          String _xifexpression_3 = null;
          if ((it instanceof TechnologySpecificEndpoint)) {
            String _xifexpression_4 = null;
            OperationMapping _operationMapping = ((TechnologySpecificEndpoint)it).getOperationMapping();
            boolean _tripleNotEquals_2 = (_operationMapping != null);
            if (_tripleNotEquals_2) {
              _xifexpression_4 = ((TechnologySpecificEndpoint)it).getOperationMapping().getOperation().buildQualifiedName(".");
            } else {
              String _xifexpression_5 = null;
              ReferredOperationMapping _referredOperationMapping = ((TechnologySpecificEndpoint)it).getReferredOperationMapping();
              boolean _tripleNotEquals_3 = (_referredOperationMapping != null);
              if (_tripleNotEquals_3) {
                _xifexpression_5 = ((TechnologySpecificEndpoint)it).getReferredOperationMapping().getOperation().buildQualifiedName(".");
              }
              _xifexpression_4 = _xifexpression_5;
            }
            _xifexpression_3 = _xifexpression_4;
          } else {
            _xifexpression_3 = null;
          }
          _xifexpression = _xifexpression_3;
        }
        return _xifexpression;
      };
      this.warnUniqueEndpointAddresses(allMappedEndpoints, nonMappedEndpoints, "operation", _function_9);
    };
    mappedOperationsInterfaces.forEach(_function_2);
  }
  
  /**
   * Helper to warn if addresses of mapped as well as non-mapped endpoints are not unique in the
   * context of a given container, e.g., a microservice
   */
  private void warnUniqueEndpointAddresses(final List<TechnologySpecificEndpoint> mappedEndpoints, final List<Endpoint> nonMappedEndpoints, final String containerTypeName, final Function<EObject, String> getContainerName) {
    final HashMap<String, TechnologySpecificEndpoint> mappedAddressesToEndpoints = CollectionLiterals.<String, TechnologySpecificEndpoint>newHashMap();
    final Consumer<TechnologySpecificEndpoint> _function = (TechnologySpecificEndpoint endpoint) -> {
      int _size = endpoint.getAddresses().size();
      ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, _size, true);
      for (final Integer i : _doubleDotLessThan) {
        final Consumer<TechnologySpecificProtocol> _function_1 = (TechnologySpecificProtocol protocol) -> {
          final String address = endpoint.getAddresses().get((i).intValue());
          String _name = protocol.getTechnology().getName();
          String _plus = (_name + "::");
          String _name_1 = protocol.getProtocol().getName();
          String protocolName = (_plus + _name_1);
          final DataFormat dataFormat = protocol.getDataFormat();
          String _formatName = null;
          if (dataFormat!=null) {
            _formatName=dataFormat.getFormatName();
          }
          boolean _tripleNotEquals = (_formatName != null);
          if (_tripleNotEquals) {
            String _protocolName = protocolName;
            StringConcatenation _builder = new StringConcatenation();
            _builder.append("(");
            String _formatName_1 = dataFormat.getFormatName();
            _builder.append(_formatName_1);
            _builder.append(")");
            protocolName = (_protocolName + _builder);
          } else {
            String _protocolName_1 = protocolName;
            StringConcatenation _builder_1 = new StringConcatenation();
            _builder_1.append("(");
            String _formatName_2 = protocol.getProtocol().getDefaultFormat().getFormatName();
            _builder_1.append(_formatName_2);
            _builder_1.append(")");
            protocolName = (_protocolName_1 + _builder_1);
          }
          final String addressPrefixedByProtocol = (protocolName + address);
          boolean _containsKey = mappedAddressesToEndpoints.containsKey(addressPrefixedByProtocol);
          if (_containsKey) {
            final String containerName = getContainerName.apply(endpoint);
            StringConcatenation _builder_2 = new StringConcatenation();
            _builder_2.append("Address ");
            _builder_2.append(address);
            _builder_2.append(" is already specified for protocol ");
            StringConcatenation _builder_3 = new StringConcatenation();
            _builder_3.append(protocolName);
            _builder_3.append(" on ");
            _builder_3.append(containerTypeName);
            _builder_3.append(" ");
            _builder_3.append(containerName);
            String _plus_1 = (_builder_2.toString() + _builder_3);
            this.warning(_plus_1, endpoint, 
              MappingPackage.Literals.TECHNOLOGY_SPECIFIC_ENDPOINT__ADDRESSES, (i).intValue());
          } else {
            mappedAddressesToEndpoints.put(addressPrefixedByProtocol, endpoint);
          }
        };
        endpoint.getTechnologySpecificProtocols().forEach(_function_1);
      }
    };
    mappedEndpoints.forEach(_function);
    final Consumer<Endpoint> _function_1 = (Endpoint nonMappedEndpoint) -> {
      int _size = nonMappedEndpoint.getAddresses().size();
      ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, _size, true);
      for (final Integer i : _doubleDotLessThan) {
        final Consumer<ImportedProtocolAndDataFormat> _function_2 = (ImportedProtocolAndDataFormat protocol) -> {
          final String address = nonMappedEndpoint.getAddresses().get((i).intValue());
          String _name = protocol.getImport().getName();
          String _plus = (_name + "::");
          String _name_1 = protocol.getImportedProtocol().getName();
          String protocolName = (_plus + _name_1);
          final DataFormat dataFormat = protocol.getDataFormat();
          String _formatName = null;
          if (dataFormat!=null) {
            _formatName=dataFormat.getFormatName();
          }
          boolean _tripleNotEquals = (_formatName != null);
          if (_tripleNotEquals) {
            String _protocolName = protocolName;
            StringConcatenation _builder = new StringConcatenation();
            _builder.append("(");
            String _formatName_1 = dataFormat.getFormatName();
            _builder.append(_formatName_1);
            _builder.append(")");
            protocolName = (_protocolName + _builder);
          } else {
            String _protocolName_1 = protocolName;
            StringConcatenation _builder_1 = new StringConcatenation();
            _builder_1.append("(");
            String _formatName_2 = protocol.getImportedProtocol().getDefaultFormat().getFormatName();
            _builder_1.append(_formatName_2);
            _builder_1.append(")");
            protocolName = (_protocolName_1 + _builder_1);
          }
          final String addressPrefixedByProtocol = (protocolName + address);
          final TechnologySpecificEndpoint duplicateMappedEndpoint = mappedAddressesToEndpoints.get(addressPrefixedByProtocol);
          if ((duplicateMappedEndpoint != null)) {
            final int mappedAddressIndex = duplicateMappedEndpoint.getAddresses().indexOf(address);
            final String mappedContainerName = getContainerName.apply(duplicateMappedEndpoint);
            final String containerName = getContainerName.apply(nonMappedEndpoint);
            boolean _notEquals = (!Objects.equal(mappedContainerName, containerName));
            if (_notEquals) {
              StringConcatenation _builder_2 = new StringConcatenation();
              _builder_2.append("Address ");
              _builder_2.append(address);
              _builder_2.append(" is already specified for protocol ");
              StringConcatenation _builder_3 = new StringConcatenation();
              _builder_3.append(protocolName);
              _builder_3.append(" on ");
              _builder_3.append(containerTypeName);
              _builder_3.append(" ");
              _builder_3.append(containerName);
              _builder_3.append(" in ");
              String _plus_1 = (_builder_2.toString() + _builder_3);
              String _plus_2 = (_plus_1 + 
                "another service model");
              this.warning(_plus_2, duplicateMappedEndpoint, 
                MappingPackage.Literals.TECHNOLOGY_SPECIFIC_ENDPOINT__ADDRESSES, mappedAddressIndex);
            }
          }
        };
        nonMappedEndpoint.getProtocols().forEach(_function_2);
      }
    };
    nonMappedEndpoints.forEach(_function_1);
  }
  
  /**
   * Check and warn if types of a data operation mapping with primitive return type are not
   * compatible. Note that we just place a warning in case of (suspected) type incompatibility, as
   * we also do it in the Service DSL.
   */
  @Check
  public void warnReturnTypeCompatibility(final DataOperationReturnTypeMapping mapping) {
    boolean _isPrimitiveTypeMapping = this.isPrimitiveTypeMapping(mapping);
    if (_isPrimitiveTypeMapping) {
      this.warnPrimitiveTypeMappingCompatibility(mapping);
    }
  }
  
  /**
   * Check and warn if types of a primitive parameter mapping are not compatible. Note that we
   * just place a warning in case of (suspected) type incompatibility, as we also do it in the
   * Service DSL.
   */
  @Check
  public void warnPrimitiveParameterMappingTypeCompatibility(final PrimitiveParameterMapping mapping) {
    TechnologySpecificPrimitiveType _primitiveType = mapping.getPrimitiveType();
    boolean _tripleNotEquals = (_primitiveType != null);
    if (_tripleNotEquals) {
      this.warnPrimitiveTypeMappingCompatibility(mapping);
    }
  }
  
  /**
   * Check and warn if types of a data field mapping are not compatible. Note that we just place a
   * warning in case of (suspected) type incompatibility, as we also do it in the Service DSL.
   */
  @Check
  public void warnFieldMappingTypeCompatibility(final TechnologySpecificFieldMapping mapping) {
    boolean _isPrimitiveTypeMapping = this.isPrimitiveTypeMapping(mapping);
    if (_isPrimitiveTypeMapping) {
      this.warnPrimitiveTypeMappingCompatibility(mapping);
    }
  }
  
  /**
   * Check and warn if types of a data operation parameter primitive type mapping are not
   * compatible. Note that we just place a warning in case of (suspected) type incompatibility, as
   * we also do it in the Service DSL.
   */
  @Check
  public void warnDataOperationParameterTypeCompatibility(final DataOperationParameterMapping mapping) {
    boolean _isPrimitiveTypeMapping = this.isPrimitiveTypeMapping(mapping);
    if (_isPrimitiveTypeMapping) {
      this.warnPrimitiveTypeMappingCompatibility(mapping);
    }
  }
  
  /**
   * Convenience method for warning if primitive types within a mapping are not compatible with
   * each other
   */
  private void warnPrimitiveTypeMappingCompatibility(final EObject mapping) {
    boolean _isPrimitiveTypeMapping = this.isPrimitiveTypeMapping(mapping);
    boolean _not = (!_isPrimitiveTypeMapping);
    if (_not) {
      return;
    }
    Type mappedType = null;
    String mappedTypeName = null;
    Type originalType = null;
    EStructuralFeature erroneousMappingFeature = null;
    boolean _matched = false;
    if (mapping instanceof TechnologySpecificFieldMapping) {
      _matched=true;
      mappedType = ((TechnologySpecificFieldMapping)mapping).getType();
      mappedTypeName = ((TechnologySpecificPrimitiveType) mappedType).getName();
      originalType = ((TechnologySpecificFieldMapping)mapping).getDataField().getEffectiveType();
      erroneousMappingFeature = MappingPackage.Literals.TECHNOLOGY_SPECIFIC_FIELD_MAPPING__DATA_FIELD;
    }
    if (!_matched) {
      if (mapping instanceof DataOperationReturnTypeMapping) {
        _matched=true;
        mappedType = ((DataOperationReturnTypeMapping)mapping).getType();
        mappedTypeName = ((TechnologySpecificPrimitiveType) mappedType).getName();
        originalType = ((DataOperationReturnTypeMapping)mapping).getOperationMapping().getDataOperation().getPrimitiveReturnType();
        erroneousMappingFeature = MappingPackage.Literals.DATA_OPERATION_RETURN_TYPE_MAPPING__TYPE;
      }
    }
    if (!_matched) {
      if (mapping instanceof DataOperationParameterMapping) {
        _matched=true;
        mappedType = ((DataOperationParameterMapping)mapping).getType();
        mappedTypeName = ((TechnologySpecificPrimitiveType) mappedType).getName();
        originalType = ((DataOperationParameterMapping)mapping).getParameter().getPrimitiveType();
        erroneousMappingFeature = MappingPackage.Literals.DATA_OPERATION_PARAMETER_MAPPING__PARAMETER;
      }
    }
    if (!_matched) {
      if (mapping instanceof PrimitiveParameterMapping) {
        _matched=true;
        mappedType = ((PrimitiveParameterMapping)mapping).getPrimitiveType();
        mappedTypeName = ((PrimitiveParameterMapping)mapping).getPrimitiveType().getName();
        originalType = ((PrimitiveParameterMapping)mapping).getParameter().getPrimitiveType();
        erroneousMappingFeature = MappingPackage.Literals.PARAMETER_MAPPING__PARAMETER;
      }
    }
    if (((originalType == null) || (mappedType == null))) {
      return;
    }
    try {
      new TypeChecker().checkTypeCompatibility(originalType, mappedType);
    } catch (final Throwable _t) {
      if (_t instanceof TypesNotCompatibleException) {
        String _xifexpression = null;
        if ((originalType instanceof TechnologySpecificPrimitiveType)) {
          _xifexpression = ((TechnologySpecificPrimitiveType)originalType).buildQualifiedName(".");
        } else {
          String _xifexpression_1 = null;
          if ((originalType instanceof PrimitiveType)) {
            _xifexpression_1 = ((PrimitiveType)originalType).getTypeName();
          }
          _xifexpression = _xifexpression_1;
        }
        final String originalTypeName = _xifexpression;
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Original type ");
        _builder.append(originalTypeName);
        _builder.append(" is not directly compatible with ");
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("mapped type ");
        _builder_1.append(mappedTypeName);
        _builder_1.append(" ");
        String _plus = (_builder.toString() + _builder_1);
        this.warning(_plus, mapping, erroneousMappingFeature);
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
  }
  
  /**
   * Helper to check if a mapping is for a primitive type
   */
  private boolean isPrimitiveTypeMapping(final EObject mapping) {
    boolean _or = false;
    if ((mapping instanceof PrimitiveParameterMapping)) {
      _or = true;
    } else {
      boolean _xifexpression = false;
      if ((mapping instanceof TechnologySpecificFieldMapping)) {
        Type _type = ((TechnologySpecificFieldMapping)mapping).getType();
        _xifexpression = (_type instanceof TechnologySpecificPrimitiveType);
      } else {
        boolean _xifexpression_1 = false;
        if ((mapping instanceof DataOperationReturnTypeMapping)) {
          Type _type_1 = ((DataOperationReturnTypeMapping)mapping).getType();
          _xifexpression_1 = (_type_1 instanceof TechnologySpecificPrimitiveType);
        } else {
          boolean _xifexpression_2 = false;
          if ((mapping instanceof DataOperationParameterMapping)) {
            Type _type_2 = ((DataOperationParameterMapping)mapping).getType();
            _xifexpression_2 = (_type_2 instanceof TechnologySpecificPrimitiveType);
          } else {
            _xifexpression_2 = false;
          }
          _xifexpression_1 = _xifexpression_2;
        }
        _xifexpression = _xifexpression_1;
      }
      _or = _xifexpression;
    }
    return _or;
  }
  
  /**
   * Check for differing technology assignments to parameters
   */
  @Check
  public void checkDifferingParameterTechnologies(final MicroserviceMapping mapping) {
    if (((mapping.getTechnologyReferences().isEmpty() || 
      (mapping.getMicroservice() == null)) || 
      (mapping.getMicroservice().getMicroservice() == null))) {
      return;
    }
    final Microservice mappedService = mapping.getMicroservice().getMicroservice();
    boolean _isEmpty = mappedService.getTechnologyReferences().isEmpty();
    if (_isEmpty) {
      return;
    }
    final Technology mappedTypeTechnology = mappedService.getTypeDefinitionTechnology();
    if ((mappedTypeTechnology == null)) {
      return;
    }
    final Technology mappingTypeTechnology = mapping.getTypeDefinitionTechnology();
    if ((mappedTypeTechnology == null)) {
      return;
    } else {
      String _name = mappedTypeTechnology.getName();
      String _name_1 = mappingTypeTechnology.getName();
      boolean _equals = Objects.equal(_name, _name_1);
      if (_equals) {
        return;
      }
    }
    final EList<Operation> mappedServiceOperations = mappedService.getContainedOperations();
    final Function1<ReferredOperation, Operation> _function = (ReferredOperation it) -> {
      return it.getOperation();
    };
    mappedServiceOperations.addAll(ListExtensions.<ReferredOperation, Operation>map(mappedService.getContainedReferredOperations(), _function));
    final Function1<Operation, Boolean> _function_1 = (Operation it) -> {
      final Function1<Parameter, Boolean> _function_2 = (Parameter it_1) -> {
        return Boolean.valueOf(it_1.isTechnologySpecificEffectiveType());
      };
      return Boolean.valueOf(IterableExtensions.<Parameter>exists(it.getParameters(), _function_2));
    };
    boolean _exists = IterableExtensions.<Operation>exists(mappedServiceOperations, _function_1);
    if (_exists) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Type definition technology \"");
      String _name_2 = mappedTypeTechnology.getName();
      _builder.append(_name_2);
      _builder.append("\" in the service ");
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("model differs from type definition technology \"");
      String _name_3 = mappingTypeTechnology.getName();
      _builder_1.append(_name_3);
      _builder_1.append("\"");
      String _plus = (_builder.toString() + _builder_1);
      String _plus_1 = (_plus + 
        "used for the mapping. Moreover, the mapped microservice refers to ");
      String _plus_2 = (_plus_1 + 
        "technology-specific types in the parameters of its operations. Subsequent ");
      String _plus_3 = (_plus_2 + 
        "transformations of the microservice will not be possible. Please remove the ");
      String _plus_4 = (_plus_3 + 
        "technology-dependence of the service in its service model.");
      this.error(_plus_4, mapping, 
        MappingPackage.Literals.MICROSERVICE_MAPPING__MICROSERVICE);
    }
  }
  
  /**
   * Check that interface mapping is not empty
   */
  @Check
  public void checkNotEmpty(final InterfaceMapping mapping) {
    final boolean isEmpty = ((mapping.getProtocols().isEmpty() && 
      mapping.getEndpoints().isEmpty()) && 
      mapping.getAspects().isEmpty());
    if (isEmpty) {
      this.error("Mapping must not be empty", mapping, 
        MappingPackage.Literals.INTERFACE_MAPPING__INTERFACE);
    }
  }
  
  /**
   * Check that operation mapping is not empty
   */
  @Check
  public void checkNotEmpty(final OperationMapping mapping) {
    final boolean isEmpty = (((mapping.getProtocols().isEmpty() && 
      mapping.getEndpoints().isEmpty()) && 
      mapping.getParameterMappings().isEmpty()) && 
      mapping.getAspects().isEmpty());
    if (isEmpty) {
      this.error("Mapping must not be empty", mapping, 
        MappingPackage.Literals.OPERATION_MAPPING__OPERATION);
    }
  }
  
  /**
   * Check that referred operation mapping is not empty
   */
  @Check
  public void checkNotEmpty(final ReferredOperationMapping mapping) {
    final boolean isEmpty = ((mapping.getProtocols().isEmpty() && 
      mapping.getEndpoints().isEmpty()) && 
      mapping.getAspects().isEmpty());
    if (isEmpty) {
      this.error("Mapping must not be empty", mapping, 
        MappingPackage.Literals.REFERRED_OPERATION_MAPPING__OPERATION);
    }
  }
  
  /**
   * Check that primitive parameter mapping is not empty
   */
  @Check
  public void checkNotEmpty(final PrimitiveParameterMapping mapping) {
    final boolean isEmpty = ((mapping.getPrimitiveType() == null) && mapping.getAspects().isEmpty());
    if (isEmpty) {
      this.error("Mapping must not be empty", mapping, 
        MappingPackage.Literals.PARAMETER_MAPPING__PARAMETER);
    }
  }
  
  /**
   * Check that complex parameter mapping is not empty
   */
  @Check
  public void checkNotEmpty(final ComplexParameterMapping mapping) {
    final boolean isEmpty = (((mapping.getTechnologySpecificComplexType() == null) && 
      mapping.getAspects().isEmpty()) && 
      mapping.getFieldMappings().isEmpty());
    if (isEmpty) {
      this.error("Mapping must not be empty", mapping, 
        MappingPackage.Literals.PARAMETER_MAPPING__PARAMETER);
    }
  }
  
  /**
   * Check that a parameter is mapped only once in an operation mapping
   */
  @Check
  public void checkComplexParameterMappingUniqueParameters(final OperationMapping mapping) {
    final Function<ParameterMapping, Parameter> _function = (ParameterMapping it) -> {
      return it.getParameter();
    };
    final Integer duplicateIndex = LemmaUtils.<ParameterMapping, Parameter>getDuplicateIndex(mapping.getParameterMappings(), _function);
    if (((duplicateIndex).intValue() > (-1))) {
      final ParameterMapping duplicateMapping = mapping.getParameterMappings().get((duplicateIndex).intValue());
      final Parameter duplicateParameter = mapping.getParameterMappings().get((duplicateIndex).intValue()).getParameter();
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Duplicate mapping for parameter ");
      String _name = duplicateParameter.getName();
      _builder.append(_name);
      this.error(_builder.toString(), duplicateMapping, MappingPackage.Literals.PARAMETER_MAPPING__PARAMETER);
    }
  }
  
  /**
   * Check that a field is mapped only once in a complex parameter mapping
   */
  @Check
  public void checkComplexParameterMappingUniqueFields(final ComplexParameterMapping mapping) {
    Type _type = mapping.getParameter().getImportedType().getType();
    this.checkFieldMappingUniqueness(((ComplexType) _type), 
      mapping.getFieldMappings());
  }
  
  /**
   * Check that a field is mapped only once in a complex type mapping
   */
  @Check
  public void checkComplexTypeMappingUniqueFields(final ComplexTypeMapping mapping) {
    this.checkFieldMappingUniqueness(mapping.getType().getType(), mapping.getFieldMappings());
  }
  
  /**
   * Helper to check that fields are mapped only once
   */
  private void checkFieldMappingUniqueness(final ComplexType type, final List<TechnologySpecificFieldMapping> mappings) {
    Integer _xifexpression = null;
    boolean _isIsEnumeration = type.isIsEnumeration();
    if (_isIsEnumeration) {
      final Function<TechnologySpecificFieldMapping, EnumerationField> _function = (TechnologySpecificFieldMapping it) -> {
        return it.getEnumerationField();
      };
      _xifexpression = LemmaUtils.<TechnologySpecificFieldMapping, EnumerationField>getDuplicateIndex(mappings, _function);
    } else {
      final Function<TechnologySpecificFieldMapping, DataField> _function_1 = (TechnologySpecificFieldMapping it) -> {
        return it.getDataField();
      };
      _xifexpression = LemmaUtils.<TechnologySpecificFieldMapping, DataField>getDuplicateIndex(mappings, _function_1);
    }
    final Integer duplicateIndex = _xifexpression;
    if (((duplicateIndex).intValue() == (-1))) {
      return;
    }
    final TechnologySpecificFieldMapping duplicateMapping = mappings.get((duplicateIndex).intValue());
    String duplicateFieldName = null;
    EReference duplicateFieldReference = null;
    boolean _isIsEnumeration_1 = type.isIsEnumeration();
    if (_isIsEnumeration_1) {
      duplicateFieldName = duplicateMapping.getEnumerationField().getName();
      duplicateFieldReference = MappingPackage.Literals.TECHNOLOGY_SPECIFIC_FIELD_MAPPING__ENUMERATION_FIELD;
    } else {
      duplicateFieldName = duplicateMapping.getDataField().getName();
      duplicateFieldReference = MappingPackage.Literals.TECHNOLOGY_SPECIFIC_FIELD_MAPPING__DATA_FIELD;
    }
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("Duplicate mapping for field ");
    _builder.append(duplicateFieldName);
    this.error(_builder.toString(), duplicateMapping, duplicateFieldReference);
  }
  
  /**
   * Check that a technology-specific field mapping is not empty
   */
  @Check
  public void checkTechnologySpecificFieldMappingNotEmpty(final TechnologySpecificFieldMapping mapping) {
    DataField _dataField = mapping.getDataField();
    boolean _tripleEquals = (_dataField == null);
    if (_tripleEquals) {
      return;
    }
    if (((mapping.getType() == null) && mapping.getAspects().isEmpty())) {
      this.error("Mapping must not be empty", mapping, 
        MappingPackage.Literals.TECHNOLOGY_SPECIFIC_FIELD_MAPPING__DATA_FIELD);
    }
  }
  
  /**
   * Check that a data operation mapping is not empty
   */
  @Check
  public void checkDataOperationMappingNotEmpty(final DataOperationMapping mapping) {
    if ((((mapping.getReturnTypeMapping() == null) && 
      mapping.getParameterMappings().isEmpty()) && 
      mapping.getAspects().isEmpty())) {
      this.error("Mapping must not be empty", mapping, 
        MappingPackage.Literals.DATA_OPERATION_MAPPING__DATA_OPERATION);
    }
  }
  
  /**
   * Check that a data operation return type mapping is not empty
   */
  @Check
  public void checkDataOperationReturnTypeMappingNotEmpty(final DataOperationReturnTypeMapping mapping) {
    if (((mapping.getType() == null) && mapping.getAspects().isEmpty())) {
      this.error("Mapping must not be empty", mapping.getOperationMapping(), 
        MappingPackage.Literals.DATA_OPERATION_MAPPING__RETURN_TYPE_MAPPING);
    }
  }
  
  /**
   * Helper to check that communication types are unique
   */
  private void checkCommunicationTypeUniqueness(final List<TechnologySpecificProtocolSpecification> protocolSpecifications) {
    ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, 2, true);
    for (final int i : _doubleDotLessThan) {
      {
        CommunicationType _switchResult = null;
        switch (i) {
          case 0:
            _switchResult = CommunicationType.SYNCHRONOUS;
            break;
          case 1:
            _switchResult = CommunicationType.ASYNCHRONOUS;
            break;
        }
        final CommunicationType currentCommunicationType = _switchResult;
        String _switchResult_1 = null;
        if (currentCommunicationType != null) {
          switch (currentCommunicationType) {
            case SYNCHRONOUS:
              _switchResult_1 = "synchronous";
              break;
            case ASYNCHRONOUS:
              _switchResult_1 = "asynchronous";
              break;
            default:
              break;
          }
        }
        final String currentCommunicationTypeName = _switchResult_1;
        final Function<TechnologySpecificProtocolSpecification, CommunicationType> _function = (TechnologySpecificProtocolSpecification it) -> {
          return it.getCommunicationType();
        };
        final Predicate<TechnologySpecificProtocolSpecification> _function_1 = (TechnologySpecificProtocolSpecification it) -> {
          CommunicationType _communicationType = it.getCommunicationType();
          return Objects.equal(currentCommunicationType, _communicationType);
        };
        final Integer duplicateIndex = LemmaUtils.<TechnologySpecificProtocolSpecification, CommunicationType>getDuplicateIndex(protocolSpecifications, _function, _function_1);
        if (((duplicateIndex).intValue() == (-1))) {
          return;
        }
        final TechnologySpecificProtocolSpecification duplicate = protocolSpecifications.get((duplicateIndex).intValue());
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("There must not be more than one ");
        _builder.append(currentCommunicationTypeName);
        _builder.append(" protocol ");
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("being mapped");
        String _plus = (_builder.toString() + _builder_1);
        this.error(_plus, duplicate, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_PROTOCOL_SPECIFICATION__COMMUNICATION_TYPE);
      }
    }
  }
  
  /**
   * Helper to check that service-specific mappings are unique
   */
  private <T extends EObject> boolean checkMappingUniqueness(final List<T> mappingsToCheck, final String mappingName, final Function<T, String> getMappingObjectName, final EReference mappingFeature) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append(mappingName);
    _builder.append(" is already mapped");
    return this.<T>checkMappingUniqueness(mappingsToCheck, getMappingObjectName, mappingFeature, _builder.toString());
  }
  
  /**
   * Helper to check that service-specific mappings are unique with a custom error message
   */
  private <T extends EObject> boolean checkMappingUniqueness(final List<T> mappingsToCheck, final Function<T, String> getMappingObjectName, final EReference mappingFeature, final String errorMessage) {
    final Integer duplicateIndex = LemmaUtils.<T, String>getDuplicateIndex(mappingsToCheck, getMappingObjectName);
    if (((duplicateIndex).intValue() == (-1))) {
      return false;
    }
    final T duplicate = mappingsToCheck.get((duplicateIndex).intValue());
    this.error(errorMessage, duplicate, mappingFeature);
    return true;
  }
  
  /**
   * Check uniqueness of aspects
   */
  @Check
  public void checkAspectsUniqueness(final TechnologySpecificImportedServiceAspect importedAspect) {
    if ((((((importedAspect.getTechnology() == null) || (importedAspect.getTechnology().getName() == null)) || 
      (importedAspect.getAspect() == null)) || (importedAspect.getAspect().getName() == null)) || 
      (!importedAspect.getAspect().isIsSingleValued()))) {
      return;
    }
    final String qualifiedAspectName = QualifiedName.create(importedAspect.getTechnology().getName(), 
      importedAspect.getAspect().getName()).toString();
    final Function1<TechnologySpecificImportedServiceAspect, Boolean> _function = (TechnologySpecificImportedServiceAspect it) -> {
      boolean _xifexpression = false;
      if (((it.getAspect().getName() != null) && (it != importedAspect))) {
        boolean _xblockexpression = false;
        {
          final String otherQualifiedAspectName = QualifiedName.create(
            importedAspect.getTechnology().getName(), 
            it.getAspect().getName()).toString();
          _xblockexpression = Objects.equal(qualifiedAspectName, otherQualifiedAspectName);
        }
        _xifexpression = _xblockexpression;
      } else {
        _xifexpression = false;
      }
      return Boolean.valueOf(_xifexpression);
    };
    final Iterable<TechnologySpecificImportedServiceAspect> eponymousAspectsOfContainer = IterableExtensions.<TechnologySpecificImportedServiceAspect>filter(EcoreUtil2.<TechnologySpecificImportedServiceAspect>getSiblingsOfType(importedAspect, 
      TechnologySpecificImportedServiceAspect.class), _function);
    boolean _isEmpty = IterableExtensions.isEmpty(eponymousAspectsOfContainer);
    boolean _not = (!_isEmpty);
    if (_not) {
      final TechnologySpecificImportedServiceAspect duplicateAspect = ((TechnologySpecificImportedServiceAspect[])Conversions.unwrapArray(eponymousAspectsOfContainer, TechnologySpecificImportedServiceAspect.class))[0];
      this.error("Aspect may be specified at most once", duplicateAspect, 
        MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__ASPECT);
    }
  }
  
  /**
   * Check that aspect has only one property, if only a single value is specified, and that the
   * specified value matches the property's type
   */
  @Check
  public void checkSingleAspectProperty(final TechnologySpecificImportedServiceAspect importedAspect) {
    final PrimitiveValue propertyValue = importedAspect.getSinglePropertyValue();
    if ((propertyValue == null)) {
      return;
    }
    final int propertyCount = importedAspect.getAspect().getProperties().size();
    if ((propertyCount == 0)) {
      this.error("Aspect does not define properties", importedAspect, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__SINGLE_PROPERTY_VALUE);
    } else {
      if ((propertyCount > 1)) {
        this.error("Ambiguous value assignment", importedAspect, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__SINGLE_PROPERTY_VALUE);
      } else {
        if ((propertyCount == 1)) {
          final TechnologySpecificProperty targetProperty = importedAspect.getAspect().getProperties().get(0);
          final PrimitiveType targetPropertyType = targetProperty.getType();
          boolean _isOfType = propertyValue.isOfType(targetPropertyType);
          boolean _not = (!_isOfType);
          if (_not) {
            StringConcatenation _builder = new StringConcatenation();
            _builder.append("Value is not of type ");
            String _typeName = targetPropertyType.getTypeName();
            _builder.append(_typeName);
            _builder.append(" as expected by ");
            StringConcatenation _builder_1 = new StringConcatenation();
            _builder_1.append("property ");
            String _name = targetProperty.getName();
            _builder_1.append(_name);
            String _plus = (_builder.toString() + _builder_1);
            this.error(_plus, importedAspect, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__SINGLE_PROPERTY_VALUE);
          }
        }
      }
    }
  }
  
  /**
   * Check that mandatory properties of aspects have values
   */
  @Check
  public void checkMandatoryAspectProperties(final TechnologySpecificImportedServiceAspect importedAspect) {
    final ServiceAspect aspect = importedAspect.getAspect();
    final EList<TechnologySpecificProperty> aspectProperties = aspect.getProperties();
    final Function1<TechnologySpecificProperty, Boolean> _function = (TechnologySpecificProperty it) -> {
      return Boolean.valueOf(it.isIsMandatory());
    };
    final Iterable<TechnologySpecificProperty> mandatoryProperties = IterableExtensions.<TechnologySpecificProperty>filter(aspectProperties, _function);
    final Function1<TechnologySpecificProperty, Boolean> _function_1 = (TechnologySpecificProperty it) -> {
      final Function1<TechnologySpecificPropertyValueAssignment, TechnologySpecificProperty> _function_2 = (TechnologySpecificPropertyValueAssignment it_1) -> {
        return it_1.getProperty();
      };
      boolean _contains = ListExtensions.<TechnologySpecificPropertyValueAssignment, TechnologySpecificProperty>map(importedAspect.getValues(), _function_2).contains(it);
      return Boolean.valueOf((!_contains));
    };
    final Iterable<TechnologySpecificProperty> mandatoryPropertiesWithoutValues = IterableExtensions.<TechnologySpecificProperty>filter(mandatoryProperties, _function_1);
    final boolean allMandatoryPropertiesHaveValues = IterableExtensions.isEmpty(mandatoryPropertiesWithoutValues);
    final boolean aspectHasExactlyOneMandatoryProperty = ((aspectProperties.size() == 1) && 
      (!IterableExtensions.isEmpty(mandatoryProperties)));
    if (aspectHasExactlyOneMandatoryProperty) {
      if (((importedAspect.getSinglePropertyValue() == null) && (!allMandatoryPropertiesHaveValues))) {
        final TechnologySpecificProperty mandatoryProperty = ((TechnologySpecificProperty[])Conversions.unwrapArray(mandatoryProperties, TechnologySpecificProperty.class))[0];
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Mandatory property ");
        String _name = mandatoryProperty.getName();
        _builder.append(_name);
        _builder.append(" does not have value");
        this.error(_builder.toString(), importedAspect, MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__ASPECT);
      }
    } else {
      if ((!allMandatoryPropertiesHaveValues)) {
        final Consumer<TechnologySpecificProperty> _function_2 = (TechnologySpecificProperty it) -> {
          StringConcatenation _builder_1 = new StringConcatenation();
          _builder_1.append("Mandatory property ");
          String _name_1 = it.getName();
          _builder_1.append(_name_1);
          _builder_1.append(" does not have value");
          this.error(_builder_1.toString(), importedAspect, 
            MappingPackage.Literals.TECHNOLOGY_SPECIFIC_IMPORTED_SERVICE_ASPECT__ASPECT);
        };
        mandatoryPropertiesWithoutValues.forEach(_function_2);
      }
    }
  }
}
