/**
 * generated by Xtext 2.12.0
 */
package de.fhdo.ddmm.validation;

import com.google.common.base.Function;
import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import com.google.inject.Inject;
import de.fhdo.ddmm.ServiceDslQualifiedNameProvider;
import de.fhdo.ddmm.data.DataModel;
import de.fhdo.ddmm.data.PrimitiveType;
import de.fhdo.ddmm.data.PrimitiveValue;
import de.fhdo.ddmm.data.Type;
import de.fhdo.ddmm.service.Endpoint;
import de.fhdo.ddmm.service.Import;
import de.fhdo.ddmm.service.ImportType;
import de.fhdo.ddmm.service.ImportedProtocolAndDataFormat;
import de.fhdo.ddmm.service.ImportedServiceAspect;
import de.fhdo.ddmm.service.Interface;
import de.fhdo.ddmm.service.Microservice;
import de.fhdo.ddmm.service.Operation;
import de.fhdo.ddmm.service.Parameter;
import de.fhdo.ddmm.service.PossiblyImportedInterface;
import de.fhdo.ddmm.service.PossiblyImportedMicroservice;
import de.fhdo.ddmm.service.PossiblyImportedOperation;
import de.fhdo.ddmm.service.ProtocolSpecification;
import de.fhdo.ddmm.service.ReferredOperation;
import de.fhdo.ddmm.service.ServiceModel;
import de.fhdo.ddmm.service.ServicePackage;
import de.fhdo.ddmm.service.Visibility;
import de.fhdo.ddmm.technology.CommunicationType;
import de.fhdo.ddmm.technology.DataFormat;
import de.fhdo.ddmm.technology.ExchangePattern;
import de.fhdo.ddmm.technology.ServiceAspect;
import de.fhdo.ddmm.technology.Technology;
import de.fhdo.ddmm.technology.TechnologyPackage;
import de.fhdo.ddmm.technology.TechnologySpecificPrimitiveType;
import de.fhdo.ddmm.technology.TechnologySpecificProperty;
import de.fhdo.ddmm.technology.TechnologySpecificPropertyValueAssignment;
import de.fhdo.ddmm.typechecking.TypeChecker;
import de.fhdo.ddmm.typechecking.TypesNotCompatibleException;
import de.fhdo.ddmm.utils.DdmmUtils;
import de.fhdo.ddmm.validation.AbstractServiceDslValidator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.ExclusiveRange;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;

/**
 * This class contains custom validation rules for service models.
 * 
 * @author <a href="mailto:florian.rademacher@fh-dortmund.de">Florian Rademacher</a>
 */
@SuppressWarnings("all")
public class ServiceDslValidator extends AbstractServiceDslValidator {
  @Inject
  private ServiceDslQualifiedNameProvider nameProvider;
  
  /**
   * Check if an imported file exists
   */
  @Check
  public void checkImportFileExists(final Import import_) {
    boolean _importFileExists = DdmmUtils.importFileExists(import_.eResource(), import_.getImportURI());
    boolean _not = (!_importFileExists);
    if (_not) {
      this.error("File not found", ServicePackage.Literals.IMPORT__IMPORT_URI);
    }
  }
  
  /**
   * Check that imported file defines a model that fits the given import type
   */
  @Check
  public void checkImportType(final Import import_) {
    Class<? extends EObject> expectedModelType = null;
    String expectedModelTypeName = null;
    ImportType _importType = import_.getImportType();
    if (_importType != null) {
      switch (_importType) {
        case DATATYPES:
          expectedModelType = DataModel.class;
          expectedModelTypeName = "data";
          break;
        case MICROSERVICES:
          expectedModelType = ServiceModel.class;
          expectedModelTypeName = "service";
          break;
        case TECHNOLOGY:
          expectedModelType = Technology.class;
          expectedModelTypeName = "technology";
          break;
        default:
          return;
      }
    } else {
      return;
    }
    boolean _isImportOfType = DdmmUtils.isImportOfType(import_.eResource(), import_.getImportURI(), expectedModelType);
    boolean _not = (!_isImportOfType);
    if (_not) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("File does not contain a ");
      _builder.append(expectedModelTypeName);
      _builder.append(" model definition");
      this.error(_builder.toString(), import_, 
        ServicePackage.Literals.IMPORT__IMPORT_URI);
    }
  }
  
  /**
   * Check that model does not import itself
   */
  @Check
  public void checkForSelfImport(final Import import_) {
    ImportType _importType = import_.getImportType();
    boolean _tripleNotEquals = (_importType != ImportType.MICROSERVICES);
    if (_tripleNotEquals) {
      return;
    }
    final ServiceModel thisModel = import_.getServiceModel();
    final Function<Import, String> _function = (Import it) -> {
      return it.getImportURI();
    };
    final Iterable<Import> serviceImports = DdmmUtils.<Import>getImportsOfModelTypes(thisModel.getImports(), _function, 
      ServiceModel.class);
    final Consumer<Import> _function_1 = (Import it) -> {
      final EList<EObject> root = DdmmUtils.getImportedModelContents(it.eResource(), it.getImportURI());
      if (((!root.isEmpty()) && Objects.equal(root.get(0), thisModel))) {
        this.error("Model may not import itself", import_, 
          ServicePackage.Literals.IMPORT__IMPORT_URI);
      }
    };
    serviceImports.forEach(_function_1);
  }
  
  /**
   * Check that imported file is imported exactly once
   */
  @Check
  public void checkImportFileUniqueness(final ServiceModel serviceModel) {
    final Function<Import, String> _function = (Import it) -> {
      return it.getImportURI();
    };
    final int duplicateIndex = DdmmUtils.<Import, String>getDuplicateIndex(serviceModel.getImports(), _function);
    if ((duplicateIndex == (-1))) {
      return;
    }
    final Import duplicate = serviceModel.getImports().get(duplicateIndex);
    this.error("File is already being imported", duplicate, 
      ServicePackage.Literals.IMPORT__IMPORT_URI);
  }
  
  /**
   * Check that microservice, interface, and operation endpoints' addresses are unique per
   * protocol/data format combination
   */
  @Check
  public void checkUniqueEndpointAddresses(final ServiceModel serviceModel) {
    final Function1<Microservice, EList<Endpoint>> _function = (Microservice it) -> {
      return it.getEndpoints();
    };
    final List<Endpoint> microserviceEndpoints = IterableExtensions.<Endpoint>toList(Iterables.<Endpoint>concat(ListExtensions.<Microservice, EList<Endpoint>>map(serviceModel.getMicroservices(), _function)));
    final Function<Endpoint, List<String>> _function_1 = (Endpoint it) -> {
      return it.getMicroservice().getQualifiedNameParts();
    };
    this.checkUniqueEndpointAddresses(microserviceEndpoints, "microservice", _function_1);
    final Function1<Interface, EList<Endpoint>> _function_2 = (Interface it) -> {
      return it.getEndpoints();
    };
    final List<Endpoint> interfaceEndpoints = IterableExtensions.<Endpoint>toList(Iterables.<Endpoint>concat(ListExtensions.<Interface, EList<Endpoint>>map(serviceModel.getContainedInterfaces(), _function_2)));
    final Function<Endpoint, List<String>> _function_3 = (Endpoint it) -> {
      return it.getInterface().getQualifiedNameParts();
    };
    this.checkUniqueEndpointAddresses(interfaceEndpoints, "interface", _function_3);
    final List<Endpoint> operationEndpoints = CollectionLiterals.<Endpoint>newArrayList();
    final Function1<ReferredOperation, EList<Endpoint>> _function_4 = (ReferredOperation it) -> {
      return it.getEndpoints();
    };
    Iterables.<Endpoint>addAll(operationEndpoints, Iterables.<Endpoint>concat(ListExtensions.<ReferredOperation, EList<Endpoint>>map(serviceModel.getContainedReferredOperations(), _function_4)));
    final Function1<Operation, EList<Endpoint>> _function_5 = (Operation it) -> {
      return it.getEndpoints();
    };
    Iterables.<Endpoint>addAll(operationEndpoints, Iterables.<Endpoint>concat(ListExtensions.<Operation, EList<Endpoint>>map(serviceModel.getContainedOperations(), _function_5)));
    final Function<Endpoint, List<String>> _function_6 = (Endpoint it) -> {
      EList<String> _xifexpression = null;
      Operation _operation = it.getOperation();
      boolean _tripleNotEquals = (_operation != null);
      if (_tripleNotEquals) {
        _xifexpression = it.getOperation().getQualifiedNameParts();
      } else {
        EList<String> _xifexpression_1 = null;
        ReferredOperation _referredOperation = it.getReferredOperation();
        boolean _tripleNotEquals_1 = (_referredOperation != null);
        if (_tripleNotEquals_1) {
          _xifexpression_1 = it.getReferredOperation().getQualifiedNameParts();
        }
        _xifexpression = _xifexpression_1;
      }
      return _xifexpression;
    };
    this.checkUniqueEndpointAddresses(operationEndpoints, "operation", _function_6);
  }
  
  /**
   * Check that annotated technologies define types and protocols
   */
  @Check
  public void checkTechnologyForMandatoryConcepts(final Microservice microservice) {
    final Import technology = microservice.getTechnology();
    if ((((technology == null) || (technology.getImportURI() == null)) || technology.getImportURI().isEmpty())) {
      return;
    }
    final EList<EObject> technologyModelContents = DdmmUtils.getImportedModelContents(microservice.eResource(), 
      technology.getImportURI());
    if (((technologyModelContents == null) || technologyModelContents.isEmpty())) {
      return;
    }
    final EObject modelRoot = technologyModelContents.get(0);
    if ((!(modelRoot instanceof Technology))) {
      return;
    }
    final Technology technologyModel = ((Technology) modelRoot);
    if ((technologyModel == null)) {
      return;
    }
    if ((technologyModel.getPrimitiveTypes().isEmpty() && technologyModel.getProtocols().isEmpty())) {
      this.error("Technology does not specify primitive types, protocols, or both", microservice, ServicePackage.Literals.MICROSERVICE__TECHNOLOGY);
    }
  }
  
  /**
   * Check that interfaces are not empty, i.e., that they define or refer to at least one
   * operation
   */
  @Check
  public void checkInterfaceNotEmpty(final Interface interface_) {
    final boolean definesOperations = ((interface_.getOperations() != null) && (!interface_.getOperations().isEmpty()));
    final boolean refersOperations = ((interface_.getReferredOperations() != null) && 
      (!interface_.getReferredOperations().isEmpty()));
    if (((!definesOperations) && (!refersOperations))) {
      this.error("Interface must define or refer to at least one operation", interface_, 
        ServicePackage.Literals.INTERFACE__NAME);
    }
  }
  
  /**
   * Warn, if a required interface is already marked as being required by its containing
   * microservice
   */
  @Check
  public void warnAlreadyRequired(final PossiblyImportedInterface importedInterface) {
    if ((importedInterface.isRequired() && importedInterface.isRequiredByContainer())) {
      final QualifiedName containingMicroserviceName = this.nameProvider.qualifiedName(importedInterface.getInterface().getMicroservice());
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Interface is already required, because its microservice ");
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append(containingMicroserviceName);
      _builder_1.append("  is required");
      String _plus = (_builder.toString() + _builder_1);
      this.warning(_plus, importedInterface, 
        ServicePackage.Literals.POSSIBLY_IMPORTED_INTERFACE__INTERFACE);
    }
  }
  
  /**
   * Warn, if a required interface does not define any implemented methods
   */
  @Check
  public void warnNoImplementedOperations(final PossiblyImportedInterface importedInterface) {
    if ((importedInterface.isRequired() && (!importedInterface.getInterface().isEffectivelyImplemented()))) {
      this.warning("Interface does not define any implemented operation ", importedInterface, 
        ServicePackage.Literals.POSSIBLY_IMPORTED_INTERFACE__INTERFACE);
    }
  }
  
  /**
   * Warn, if a required microservice does not define any implemented methods
   */
  @Check
  public void warnNoImplementedOperations(final PossiblyImportedMicroservice importedMicroservice) {
    boolean _isEffectivelyImplemented = importedMicroservice.getMicroservice().isEffectivelyImplemented();
    boolean _not = (!_isEffectivelyImplemented);
    if (_not) {
      this.warning("Microservice does not define any implemented operation ", importedMicroservice, 
        ServicePackage.Literals.POSSIBLY_IMPORTED_MICROSERVICE__MICROSERVICE);
    }
  }
  
  /**
   * Warn, if the interface of an operation, that is marked as being not implemented, is also
   * marked as being not implemented. That is, the operation is already implicitly marked as being
   * not implemented by its containing interface.
   */
  @Check
  public void warnAlreadyNotImplemented(final Operation operation) {
    if ((operation.isNotImplemented() && operation.isNotImplementedByContainer())) {
      final String containingInterfaceName = operation.getInterface().getName();
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Operation is already marked as being not implemented, because ");
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("its interface ");
      _builder_1.append(containingInterfaceName);
      _builder_1.append(" is marked as being not implemented");
      String _plus = (_builder.toString() + _builder_1);
      this.warning(_plus, operation, ServicePackage.Literals.OPERATION__NOT_IMPLEMENTED);
    }
  }
  
  /**
   * Warn, if an internal operation is already implicitly internal because its containing
   * interface is internal
   */
  @Check
  public void warnAlreadyInternal(final Operation operation) {
    if (((operation.getVisibility() == Visibility.INTERNAL) && 
      operation.getInterface().isEffectivelyInternal())) {
      final String interfaceName = operation.getInterface().getName();
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Operation is already implicitly internal, because its interface ");
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append(interfaceName);
      _builder_1.append(" is effectively internal");
      String _plus = (_builder.toString() + _builder_1);
      this.warning(_plus, operation, 
        ServicePackage.Literals.OPERATION__VISIBILITY);
    }
  }
  
  /**
   * Warn, if a required operation is already required because its containing interface or
   * microservice are required
   */
  @Check
  public void warnAlreadyRequired(final PossiblyImportedOperation importedOperation) {
    if (((!importedOperation.isRequired()) || (!importedOperation.isRequiredByContainer()))) {
      return;
    }
    final boolean isInterfaceRequired = importedOperation.isRequiredByInterface();
    final boolean isServiceRequired = importedOperation.isRequiredByMicroservice();
    final Operation operation = importedOperation.getOperation();
    if ((isInterfaceRequired && isServiceRequired)) {
      final String interfaceName = operation.getInterface().getName();
      final String serviceName = operation.getInterface().getMicroservice().getName();
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Operation is already implicitly required, because both its interface ");
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append(interfaceName);
      _builder_1.append(" and microservice ");
      _builder_1.append(serviceName);
      _builder_1.append(" are required");
      String _plus = (_builder.toString() + _builder_1);
      this.warning(_plus, importedOperation, 
        ServicePackage.Literals.POSSIBLY_IMPORTED_OPERATION__REQUIRED_BY_CONTAINER);
    } else {
      if (isInterfaceRequired) {
        final String interfaceName_1 = operation.getInterface().getName();
        StringConcatenation _builder_2 = new StringConcatenation();
        _builder_2.append("Operation is already implicitly required, because its interface ");
        StringConcatenation _builder_3 = new StringConcatenation();
        _builder_3.append(interfaceName_1);
        _builder_3.append(" is required");
        String _plus_1 = (_builder_2.toString() + _builder_3);
        this.warning(_plus_1, importedOperation, 
          ServicePackage.Literals.POSSIBLY_IMPORTED_OPERATION__REQUIRED_BY_INTERFACE);
      } else {
        if (isServiceRequired) {
          final String serviceName_1 = operation.getInterface().getMicroservice().getName();
          StringConcatenation _builder_4 = new StringConcatenation();
          _builder_4.append("Operation is already implicitly required, because its microservice ");
          StringConcatenation _builder_5 = new StringConcatenation();
          _builder_5.append(serviceName_1);
          _builder_5.append(" is required");
          String _plus_2 = (_builder_4.toString() + _builder_5);
          this.warning(_plus_2, importedOperation, 
            ServicePackage.Literals.POSSIBLY_IMPORTED_OPERATION__REQUIRED_BY_MICROSERVICE);
        }
      }
    }
  }
  
  /**
   * Check that there is at most one protocol per communication type annotated on microservices,
   * interfaces, operations, or referred operations
   */
  @Check
  public void checkProtocolCommunicationType(final ProtocolSpecification protocolSpecification) {
    EList<ProtocolSpecification> _switchResult = null;
    EObject _eContainer = protocolSpecification.eContainer();
    boolean _matched = false;
    if (_eContainer instanceof Microservice) {
      _matched=true;
      EObject _eContainer_1 = protocolSpecification.eContainer();
      _switchResult = ((Microservice) _eContainer_1).getProtocols();
    }
    if (!_matched) {
      if (_eContainer instanceof Interface) {
        _matched=true;
        EObject _eContainer_1 = protocolSpecification.eContainer();
        _switchResult = ((Interface) _eContainer_1).getProtocols();
      }
    }
    if (!_matched) {
      if (_eContainer instanceof Operation) {
        _matched=true;
        EObject _eContainer_1 = protocolSpecification.eContainer();
        _switchResult = ((Operation) _eContainer_1).getProtocols();
      }
    }
    if (!_matched) {
      if (_eContainer instanceof ReferredOperation) {
        _matched=true;
        EObject _eContainer_1 = protocolSpecification.eContainer();
        _switchResult = ((ReferredOperation) _eContainer_1).getProtocols();
      }
    }
    if (!_matched) {
      _switchResult = null;
    }
    final EList<ProtocolSpecification> protocols = _switchResult;
    if (((protocols == null) || protocols.isEmpty())) {
      return;
    }
    String _switchResult_1 = null;
    EObject _eContainer_1 = protocolSpecification.eContainer();
    boolean _matched_1 = false;
    if (_eContainer_1 instanceof Microservice) {
      _matched_1=true;
      _switchResult_1 = "microservice";
    }
    if (!_matched_1) {
      if (_eContainer_1 instanceof Interface) {
        _matched_1=true;
        _switchResult_1 = "interface";
      }
    }
    if (!_matched_1) {
      if (_eContainer_1 instanceof Operation) {
        _matched_1=true;
      }
      if (!_matched_1) {
        if (_eContainer_1 instanceof ReferredOperation) {
          _matched_1=true;
        }
      }
      if (_matched_1) {
        _switchResult_1 = "operation";
      }
    }
    final String containerName = _switchResult_1;
    ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, 2, true);
    for (final int i : _doubleDotLessThan) {
      {
        CommunicationType _switchResult_2 = null;
        switch (i) {
          case 0:
            _switchResult_2 = CommunicationType.SYNCHRONOUS;
            break;
          case 1:
            _switchResult_2 = CommunicationType.ASYNCHRONOUS;
            break;
        }
        final CommunicationType communicationType = _switchResult_2;
        String _switchResult_3 = null;
        if (communicationType != null) {
          switch (communicationType) {
            case SYNCHRONOUS:
              _switchResult_3 = "synchronous";
              break;
            case ASYNCHRONOUS:
              _switchResult_3 = "asynchronous";
              break;
            default:
              break;
          }
        }
        final String communicationTypeName = _switchResult_3;
        final Function1<ProtocolSpecification, Boolean> _function = (ProtocolSpecification it) -> {
          CommunicationType _communicationType = it.getCommunicationType();
          return Boolean.valueOf(Objects.equal(communicationType, _communicationType));
        };
        final Iterable<ProtocolSpecification> protocolsOfType = IterableExtensions.<ProtocolSpecification>filter(protocols, _function);
        int _size = IterableExtensions.size(protocolsOfType);
        boolean _greaterThan = (_size > 1);
        if (_greaterThan) {
          StringConcatenation _builder = new StringConcatenation();
          _builder.append("There must not be more than one ");
          _builder.append(communicationTypeName);
          _builder.append(" protocol for ");
          StringConcatenation _builder_1 = new StringConcatenation();
          _builder_1.append("the ");
          _builder_1.append(containerName);
          String _plus = (_builder.toString() + _builder_1);
          this.error(_plus, ((EObject[])Conversions.unwrapArray(protocolsOfType, EObject.class))[1], 
            ServicePackage.Literals.PROTOCOL_SPECIFICATION__COMMUNICATION_TYPE);
        }
      }
    }
  }
  
  /**
   * Warn if initializing operation's parameters' output communication types do not match
   * initialized parameter's communication type
   */
  @Check
  public void warnCommunicationTypesNotMatching(final Parameter parameter) {
    PossiblyImportedOperation _initializedByOperation = parameter.getInitializedByOperation();
    boolean _tripleEquals = (_initializedByOperation == null);
    if (_tripleEquals) {
      return;
    }
    final Operation initializingOperation = parameter.getInitializedByOperation().getOperation();
    final Function1<Parameter, Boolean> _function = (Parameter it) -> {
      ExchangePattern _exchangePattern = it.getExchangePattern();
      return Boolean.valueOf((_exchangePattern == ExchangePattern.OUT));
    };
    final Function1<Parameter, Boolean> _function_1 = (Parameter it) -> {
      CommunicationType _communicationType = it.getCommunicationType();
      CommunicationType _communicationType_1 = parameter.getCommunicationType();
      return Boolean.valueOf((_communicationType == _communicationType_1));
    };
    final boolean existsOutParameterOfSameCommunicationType = IterableExtensions.<Parameter>exists(IterableExtensions.<Parameter>filter(initializingOperation.getParameters(), _function), _function_1);
    if ((!existsOutParameterOfSameCommunicationType)) {
      String _switchResult = null;
      CommunicationType _communicationType = parameter.getCommunicationType();
      if (_communicationType != null) {
        switch (_communicationType) {
          case ASYNCHRONOUS:
            _switchResult = "asynchronous";
            break;
          case SYNCHRONOUS:
            _switchResult = "synchronous";
            break;
          default:
            break;
        }
      }
      final String communicationTypeName = _switchResult;
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Operation does not have any outgoing parameters with communication type ");
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append(communicationTypeName);
      String _plus = (_builder.toString() + _builder_1);
      this.warning(_plus, parameter, 
        ServicePackage.Literals.PARAMETER__INITIALIZED_BY_OPERATION);
    }
  }
  
  /**
   * Check type compatibility of parameter and initializing operation, and warn if incompatible
   */
  @Check
  public void warnParameterInitializingTypeCompatibility(final PossiblyImportedOperation importedOperation) {
    final Operation operation = importedOperation.getOperation();
    EObject _eContainer = operation.eContainer();
    boolean _tripleEquals = (_eContainer == null);
    if (_tripleEquals) {
      return;
    }
    final Parameter initializedParameter = importedOperation.getInitializedParameter();
    if ((initializedParameter == null)) {
      return;
    }
    ExchangePattern _exchangePattern = initializedParameter.getExchangePattern();
    boolean _tripleEquals_1 = (_exchangePattern == ExchangePattern.OUT);
    if (_tripleEquals_1) {
      this.error("Outgoing parameters may not be initialized", initializedParameter, 
        ServicePackage.Literals.PARAMETER__EXCHANGE_PATTERN);
      return;
    }
    final Type parameterType = initializedParameter.getEffectiveType();
    if ((parameterType == null)) {
      return;
    }
    final Function1<Parameter, Boolean> _function = (Parameter it) -> {
      return Boolean.valueOf(((Objects.equal(it.getExchangePattern(), ExchangePattern.OUT) || Objects.equal(it.getExchangePattern(), ExchangePattern.INOUT)) && 
        Objects.equal(it.getEffectiveType(), parameterType)));
    };
    final boolean existsSameOutputType = IterableExtensions.<Parameter>exists(operation.getParameters(), _function);
    if (existsSameOutputType) {
      return;
    }
    boolean _warnParameterLacksPrimitiveType = this.warnParameterLacksPrimitiveType(initializedParameter);
    if (_warnParameterLacksPrimitiveType) {
      return;
    }
    final Function1<Parameter, Boolean> _function_1 = (Parameter it) -> {
      return Boolean.valueOf((((it.getEffectiveType() != null) && 
        (it.getCommunicationType() == initializedParameter.getCommunicationType())) && 
        ((it.getExchangePattern() == ExchangePattern.OUT) || 
          (it.getExchangePattern() == ExchangePattern.INOUT))));
    };
    final Function1<Parameter, Type> _function_2 = (Parameter it) -> {
      return it.getEffectiveType();
    };
    final Iterable<Type> outputTypesOfParametersCommunicationType = IterableExtensions.<Parameter, Type>map(IterableExtensions.<Parameter>filter(operation.getParameters(), _function_1), _function_2);
    boolean _isEmpty = IterableExtensions.isEmpty(outputTypesOfParametersCommunicationType);
    if (_isEmpty) {
      return;
    }
    this.warnInitializingTypeCompatibility(importedOperation, outputTypesOfParametersCommunicationType, parameterType);
  }
  
  /**
   * Helper method to determine if a technology-specific primitive type lacks underlying
   * built-in primitive types
   */
  private boolean warnParameterLacksPrimitiveType(final Parameter initializedParameter) {
    final Type parameterType = initializedParameter.getEffectiveType();
    if ((!(parameterType instanceof TechnologySpecificPrimitiveType))) {
      return false;
    }
    final TechnologySpecificPrimitiveType technologySpecificType = ((TechnologySpecificPrimitiveType) parameterType);
    boolean _isEmpty = technologySpecificType.getBasicBuiltinPrimitiveTypes().isEmpty();
    boolean _not = (!_isEmpty);
    if (_not) {
      return false;
    }
    final StringBuilder qualifiedTypeName = new StringBuilder();
    qualifiedTypeName.append(technologySpecificType.getTechnology().getName());
    qualifiedTypeName.append("::");
    qualifiedTypeName.append(QualifiedName.create(technologySpecificType.getQualifiedNameParts()));
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("Technology-specific primitive type ");
    _builder.append(qualifiedTypeName);
    _builder.append(" of parameter ");
    StringConcatenation _builder_1 = new StringConcatenation();
    String _name = initializedParameter.getName();
    _builder_1.append(_name);
    _builder_1.append(" has no basic type. To initialize the parameter, an ");
    String _plus = (_builder.toString() + _builder_1);
    StringConcatenation _builder_2 = new StringConcatenation();
    _builder_2.append("additional type conversion would need to be implemented.");
    String _plus_1 = (_plus + _builder_2);
    this.warning(_plus_1, initializedParameter, 
      ServicePackage.Literals.PARAMETER__INITIALIZED_BY_OPERATION);
    return true;
  }
  
  /**
   * Helper method to perform full type checks of a parameter and its initializing operation
   */
  private void warnInitializingTypeCompatibility(final PossiblyImportedOperation importedOperation, final Iterable<Type> outputTypes, final Type parameterType) {
    final TypeChecker typeChecker = new TypeChecker();
    boolean compatibleOutTypeFound = false;
    int i = 0;
    while (((i < IterableExtensions.size(outputTypes)) && (!compatibleOutTypeFound))) {
      {
        final Type outputType = ((Type[])Conversions.unwrapArray(outputTypes, Type.class))[i];
        try {
          typeChecker.checkTypeCompatibility(parameterType, outputType);
          compatibleOutTypeFound = true;
        } catch (final Throwable _t) {
          if (_t instanceof TypesNotCompatibleException) {
            final TypesNotCompatibleException ex = (TypesNotCompatibleException)_t;
            i++;
          } else {
            throw Exceptions.sneakyThrow(_t);
          }
        }
      }
    }
    if (compatibleOutTypeFound) {
      return;
    }
    final Parameter initializedParameter = importedOperation.getInitializedParameter();
    String typeName = QualifiedName.create(initializedParameter.getEffectiveTypeQualifiedNameParts()).toString();
    if ((parameterType instanceof TechnologySpecificPrimitiveType)) {
      String _name = ((TechnologySpecificPrimitiveType)parameterType).getTechnology().getName();
      String _plus = (_name + "::");
      String _plus_1 = (_plus + typeName);
      typeName = _plus_1;
    }
    String _switchResult = null;
    CommunicationType _communicationType = initializedParameter.getCommunicationType();
    if (_communicationType != null) {
      switch (_communicationType) {
        case ASYNCHRONOUS:
          _switchResult = "asynchronous";
          break;
        case SYNCHRONOUS:
          _switchResult = "synchronous";
          break;
        default:
          break;
      }
    }
    final String communicationTypeName = _switchResult;
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("Types of output parameters with communication type ");
    _builder.append(communicationTypeName);
    _builder.append(" ");
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("are not directly compatible with type ");
    _builder_1.append(typeName);
    _builder_1.append(" of parameter ");
    String _plus_2 = (_builder.toString() + _builder_1);
    StringConcatenation _builder_2 = new StringConcatenation();
    String _name_1 = initializedParameter.getName();
    _builder_2.append(_name_1);
    _builder_2.append(".");
    String _plus_3 = (_plus_2 + _builder_2);
    this.warning(_plus_3, importedOperation, 
      ServicePackage.Literals.POSSIBLY_IMPORTED_OPERATION__OPERATION);
  }
  
  /**
   * Check unique endpoints on microservice
   */
  @Check
  public void checkUniqueEndpoints(final Microservice microservice) {
    this.checkUniqueEndpoints(microservice.getEndpoints());
  }
  
  /**
   * Check unique endpoints on interface
   */
  @Check
  public void checkUniqueEndpoints(final Interface interface_) {
    this.checkUniqueEndpoints(interface_.getEndpoints());
  }
  
  /**
   * Check unique endpoints on operation
   */
  @Check
  public void checkUniqueEndpoints(final Operation operation) {
    this.checkUniqueEndpoints(operation.getEndpoints());
  }
  
  /**
   * Check uniqueness of an endpoint's addresses
   */
  @Check
  public void checkUniqueEndpointAddresses(final Endpoint endpoint) {
    final Function<String, String> _function = (String it) -> {
      return it;
    };
    final int duplicateIndex = DdmmUtils.<String, String>getDuplicateIndex(endpoint.getAddresses(), _function);
    if ((duplicateIndex > (-1))) {
      final String duplicate = endpoint.getAddresses().get(duplicateIndex);
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Duplicate address ");
      _builder.append(duplicate);
      this.error(_builder.toString(), endpoint, 
        ServicePackage.Literals.ENDPOINT__ADDRESSES, duplicateIndex);
    }
  }
  
  /**
   * Check uniqueness of aspects
   */
  @Check
  public void checkUniqueAspects(final ImportedServiceAspect aspect) {
    final List<ImportedServiceAspect> allAspectsOfContainer = EcoreUtil2.<ImportedServiceAspect>getAllContentsOfType(aspect.eContainer(), 
      ImportedServiceAspect.class);
    final Function<ImportedServiceAspect, String> _function = (ImportedServiceAspect it) -> {
      return it.getImportedAspect().getName();
    };
    final int duplicateIndex = DdmmUtils.<ImportedServiceAspect, String>getDuplicateIndex(allAspectsOfContainer, _function);
    if ((duplicateIndex > (-1))) {
      final ImportedServiceAspect duplicateAspect = allAspectsOfContainer.get(duplicateIndex);
      this.error("Aspect was already specified", duplicateAspect, 
        ServicePackage.Literals.IMPORTED_SERVICE_ASPECT__IMPORTED_ASPECT);
    }
  }
  
  /**
   * Check that aspect has only one property, if only a single value is specified, and that the
   * specified value matches the property's type
   */
  @Check
  public void checkSingleAspectProperty(final ImportedServiceAspect importedAspect) {
    final PrimitiveValue propertyValue = importedAspect.getSinglePropertyValue();
    if ((propertyValue == null)) {
      return;
    }
    final int propertyCount = importedAspect.getImportedAspect().getProperties().size();
    if ((propertyCount > 1)) {
      this.error("Ambiguous value assignment", importedAspect, 
        ServicePackage.Literals.IMPORTED_SERVICE_ASPECT__SINGLE_PROPERTY_VALUE);
    } else {
      if ((propertyCount == 1)) {
        final TechnologySpecificProperty targetProperty = importedAspect.getImportedAspect().getProperties().get(0);
        final PrimitiveType targetPropertyType = targetProperty.getType();
        boolean _isOfType = propertyValue.isOfType(targetPropertyType);
        boolean _not = (!_isOfType);
        if (_not) {
          StringConcatenation _builder = new StringConcatenation();
          _builder.append("Value is not of type ");
          String _typeName = targetPropertyType.getTypeName();
          _builder.append(_typeName);
          _builder.append(" as expected by ");
          StringConcatenation _builder_1 = new StringConcatenation();
          _builder_1.append("property ");
          String _name = targetProperty.getName();
          _builder_1.append(_name);
          String _plus = (_builder.toString() + _builder_1);
          this.error(_plus, importedAspect, 
            ServicePackage.Literals.IMPORTED_SERVICE_ASPECT__SINGLE_PROPERTY_VALUE);
        }
      }
    }
  }
  
  /**
   * Check that mandatory properties of aspects have values
   */
  @Check
  public void checkMandatoryAspectProperties(final ImportedServiceAspect importedAspect) {
    final ServiceAspect aspect = importedAspect.getImportedAspect();
    final EList<TechnologySpecificProperty> aspectProperties = aspect.getProperties();
    final Function1<TechnologySpecificProperty, Boolean> _function = (TechnologySpecificProperty it) -> {
      return Boolean.valueOf(it.isMandatory());
    };
    final Iterable<TechnologySpecificProperty> mandatoryProperties = IterableExtensions.<TechnologySpecificProperty>filter(aspectProperties, _function);
    final Function1<TechnologySpecificProperty, Boolean> _function_1 = (TechnologySpecificProperty it) -> {
      final Function1<TechnologySpecificPropertyValueAssignment, TechnologySpecificProperty> _function_2 = (TechnologySpecificPropertyValueAssignment it_1) -> {
        return it_1.getProperty();
      };
      boolean _contains = ListExtensions.<TechnologySpecificPropertyValueAssignment, TechnologySpecificProperty>map(importedAspect.getValues(), _function_2).contains(it);
      return Boolean.valueOf((!_contains));
    };
    final Iterable<TechnologySpecificProperty> mandatoryPropertiesWithoutValues = IterableExtensions.<TechnologySpecificProperty>filter(mandatoryProperties, _function_1);
    final boolean allMandatoryPropertiesHaveValues = IterableExtensions.isEmpty(mandatoryPropertiesWithoutValues);
    final boolean aspectHasExactlyOneMandatoryProperty = ((aspectProperties.size() == 1) && 
      (!IterableExtensions.isEmpty(mandatoryProperties)));
    if (aspectHasExactlyOneMandatoryProperty) {
      if (((importedAspect.getSinglePropertyValue() == null) && (!allMandatoryPropertiesHaveValues))) {
        final TechnologySpecificProperty mandatoryProperty = ((TechnologySpecificProperty[])Conversions.unwrapArray(mandatoryProperties, TechnologySpecificProperty.class))[0];
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Mandatory property ");
        String _name = mandatoryProperty.getName();
        _builder.append(_name);
        _builder.append(" does not have value");
        this.error(_builder.toString(), importedAspect, 
          ServicePackage.Literals.IMPORTED_SERVICE_ASPECT__IMPORTED_ASPECT);
      }
    } else {
      if ((!allMandatoryPropertiesHaveValues)) {
        final Consumer<TechnologySpecificProperty> _function_2 = (TechnologySpecificProperty it) -> {
          StringConcatenation _builder_1 = new StringConcatenation();
          _builder_1.append("Mandatory property ");
          String _name_1 = it.getName();
          _builder_1.append(_name_1);
          _builder_1.append(" does not have value");
          this.error(_builder_1.toString(), importedAspect, 
            ServicePackage.Literals.IMPORTED_SERVICE_ASPECT__IMPORTED_ASPECT);
        };
        mandatoryPropertiesWithoutValues.forEach(_function_2);
      }
    }
  }
  
  /**
   * Check that the assigned value of a service aspect property matches its type
   */
  @Check
  public void checkPropertyValueType(final TechnologySpecificPropertyValueAssignment propertyValue) {
    if (((propertyValue.getProperty() == null) || (propertyValue.getValue() == null))) {
      return;
    }
    final TechnologySpecificProperty serviceProperty = propertyValue.getProperty();
    final PrimitiveType servicePropertyType = serviceProperty.getType();
    boolean _isOfType = propertyValue.getValue().isOfType(servicePropertyType);
    boolean _not = (!_isOfType);
    if (_not) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Value is not of type ");
      String _typeName = servicePropertyType.getTypeName();
      _builder.append(_typeName);
      _builder.append(" ");
      this.error(_builder.toString(), propertyValue, 
        TechnologyPackage.Literals.TECHNOLOGY_SPECIFIC_PROPERTY_VALUE_ASSIGNMENT__VALUE);
    }
  }
  
  /**
   * Convenience method to check endpoint uniqueness in a list of endpoints
   */
  private void checkUniqueEndpoints(final List<Endpoint> endpoints) {
    final HashSet<String> protocolSet = CollectionLiterals.<String>newHashSet();
    final Consumer<Endpoint> _function = (Endpoint endpoint) -> {
      int _size = endpoint.getProtocols().size();
      ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, _size, true);
      for (final Integer i : _doubleDotLessThan) {
        {
          final ImportedProtocolAndDataFormat protocol = endpoint.getProtocols().get((i).intValue());
          String _name = protocol.getImport().getName();
          String _plus = (_name + "::");
          String _name_1 = protocol.getImportedProtocol().getName();
          String protocolId = (_plus + _name_1);
          DataFormat _dataFormat = protocol.getDataFormat();
          boolean _tripleNotEquals = (_dataFormat != null);
          if (_tripleNotEquals) {
            String _protocolId = protocolId;
            String _formatName = protocol.getDataFormat().getFormatName();
            String _plus_1 = ("/" + _formatName);
            protocolId = (_protocolId + _plus_1);
          }
          boolean _add = protocolSet.add(protocolId);
          final boolean isDuplicate = (!_add);
          if (isDuplicate) {
            StringConcatenation _builder = new StringConcatenation();
            _builder.append("Duplicate endpoint for protocol ");
            _builder.append(protocolId);
            this.error(_builder.toString(), endpoint, 
              ServicePackage.Literals.ENDPOINT__PROTOCOLS, (i).intValue());
          }
        }
      }
    };
    endpoints.forEach(_function);
  }
  
  /**
   * Convenience method to check uniqueness of endpoint addresses within a list of endpoints
   */
  private void checkUniqueEndpointAddresses(final List<Endpoint> endpoints, final String containerTypeName, final Function<Endpoint, List<String>> getEndpointContainerNameParts) {
    final HashMap<String, Map<String, Object>> uniqueAddressMap = CollectionLiterals.<String, Map<String, Object>>newHashMap();
    final Consumer<Endpoint> _function = (Endpoint endpoint) -> {
      int _size = endpoint.getAddresses().size();
      ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, _size, true);
      for (final Integer i : _doubleDotLessThan) {
        final Consumer<ImportedProtocolAndDataFormat> _function_1 = (ImportedProtocolAndDataFormat protocol) -> {
          final String address = endpoint.getAddresses().get((i).intValue());
          String _name = protocol.getImport().getName();
          String _plus = (_name + "::");
          String _name_1 = protocol.getImportedProtocol().getName();
          String protocolName = (_plus + _name_1);
          final DataFormat dataFormat = protocol.getDataFormat();
          if (((dataFormat != null) && (dataFormat.getFormatName() != null))) {
            String _protocolName = protocolName;
            String _formatName = dataFormat.getFormatName();
            String _plus_1 = ("/" + _formatName);
            protocolName = (_protocolName + _plus_1);
          }
          final String addressPrefixedByProtocol = (protocolName + address);
          final HashMap<String, Object> valueMap = CollectionLiterals.<String, Object>newHashMap();
          valueMap.put("protocol", protocolName);
          valueMap.put("endpoint", endpoint);
          final Map<String, Object> duplicate = uniqueAddressMap.putIfAbsent(addressPrefixedByProtocol, valueMap);
          Endpoint _xifexpression = null;
          if ((duplicate != null)) {
            Object _get = duplicate.get("endpoint");
            _xifexpression = ((Endpoint) _get);
          }
          final Endpoint duplicateEndpoint = _xifexpression;
          if (((duplicateEndpoint != null) && (duplicateEndpoint != endpoint))) {
            Object _get_1 = duplicate.get("protocol");
            final String duplicateProtocolName = ((String) _get_1);
            final List<String> duplicateContainerNameParts = getEndpointContainerNameParts.apply(duplicateEndpoint);
            final List<String> currentEndpointContainerNameParts = getEndpointContainerNameParts.apply(endpoint);
            final String relativeDuplicateName = QualifiedName.create(
              DdmmUtils.<Endpoint, ServiceModel>calculateRelativeQualifiedNameParts(duplicateEndpoint, duplicateContainerNameParts, ServiceModel.class, endpoint, currentEndpointContainerNameParts, ServiceModel.class)).toString();
            StringConcatenation _builder = new StringConcatenation();
            _builder.append("Address is already specified for protocol ");
            StringConcatenation _builder_1 = new StringConcatenation();
            _builder_1.append(duplicateProtocolName);
            _builder_1.append(" on ");
            _builder_1.append(containerTypeName);
            _builder_1.append(" ");
            String _plus_2 = (_builder.toString() + _builder_1);
            StringConcatenation _builder_2 = new StringConcatenation();
            _builder_2.append(relativeDuplicateName);
            String _plus_3 = (_plus_2 + _builder_2);
            this.error(_plus_3, endpoint, 
              ServicePackage.Literals.ENDPOINT__ADDRESSES, (i).intValue());
          }
        };
        endpoint.getProtocols().forEach(_function_1);
      }
    };
    endpoints.forEach(_function);
  }
}
