/**
 * generated by Xtext 2.12.0
 */
package de.fhdo.lemma.data.validation;

import com.google.common.base.Function;
import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import de.fhdo.lemma.data.ComplexType;
import de.fhdo.lemma.data.ComplexTypeImport;
import de.fhdo.lemma.data.Context;
import de.fhdo.lemma.data.DataField;
import de.fhdo.lemma.data.DataFieldFeature;
import de.fhdo.lemma.data.DataModel;
import de.fhdo.lemma.data.DataOperation;
import de.fhdo.lemma.data.DataOperationFeature;
import de.fhdo.lemma.data.DataOperationParameter;
import de.fhdo.lemma.data.DataPackage;
import de.fhdo.lemma.data.DataStructure;
import de.fhdo.lemma.data.DataStructureFeature;
import de.fhdo.lemma.data.Enumeration;
import de.fhdo.lemma.data.ImportedComplexType;
import de.fhdo.lemma.data.ListType;
import de.fhdo.lemma.data.PrimitiveType;
import de.fhdo.lemma.data.PrimitiveTypeConstants;
import de.fhdo.lemma.data.PrimitiveValue;
import de.fhdo.lemma.data.Type;
import de.fhdo.lemma.data.Version;
import de.fhdo.lemma.data.validation.AbstractDataDslValidator;
import de.fhdo.lemma.utils.LemmaUtils;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;

/**
 * This class contains validation rules for the Data DSL.
 * 
 * @author <a href="mailto:florian.rademacher@fh-dortmund.de">Florian Rademacher</a>
 */
@SuppressWarnings("all")
public class DataDslValidator extends AbstractDataDslValidator {
  /**
   * Check import aliases for uniqueness. Normally, this should be done by
   * DataDslNamesAreUniqueValidationHelper, but it does not react to.
   */
  @Check
  public void checkImportAlias(final DataModel dataModel) {
    final Function<ComplexTypeImport, String> _function = (ComplexTypeImport it) -> {
      return it.getName();
    };
    final Integer duplicateIndex = LemmaUtils.<ComplexTypeImport, String>getDuplicateIndex(dataModel.getComplexTypeImports(), _function);
    if (((duplicateIndex).intValue() == (-1))) {
      return;
    }
    final ComplexTypeImport duplicate = dataModel.getComplexTypeImports().get((duplicateIndex).intValue());
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("Duplicate import alias ");
    String _name = duplicate.getName();
    _builder.append(_name);
    this.error(_builder.toString(), duplicate, 
      DataPackage.Literals.COMPLEX_TYPE_IMPORT__NAME);
  }
  
  /**
   * Check that imported file is imported exactly once
   */
  @Check
  public void checkImportFileUniqueness(final DataModel dataModel) {
    final Function<ComplexTypeImport, String> _function = (ComplexTypeImport it) -> {
      return it.getImportURI();
    };
    final Integer duplicateIndex = LemmaUtils.<ComplexTypeImport, String>getDuplicateIndex(dataModel.getComplexTypeImports(), _function);
    if (((duplicateIndex).intValue() == (-1))) {
      return;
    }
    final ComplexTypeImport duplicate = dataModel.getComplexTypeImports().get((duplicateIndex).intValue());
    this.error("File is already being imported", duplicate, 
      DataPackage.Literals.COMPLEX_TYPE_IMPORT__IMPORT_URI);
  }
  
  /**
   * Check that imported file defines a data model
   */
  @Check
  public void checkImportType(final ComplexTypeImport complexTypeImport) {
    boolean _isImportOfType = LemmaUtils.<DataModel>isImportOfType(complexTypeImport.eResource(), complexTypeImport.getImportURI(), 
      DataModel.class);
    boolean _not = (!_isImportOfType);
    if (_not) {
      this.error("File does not contain a data model definition", complexTypeImport, 
        DataPackage.Literals.COMPLEX_TYPE_IMPORT__IMPORT_URI);
    }
  }
  
  /**
   * Check versions for unique names
   */
  @Check
  public void checkUniqueVersionNames(final DataModel dataModel) {
    final Function<Version, Object> _function = (Version it) -> {
      return it.getName();
    };
    final Function<Version, String> _function_1 = (Version it) -> {
      return it.getName();
    };
    this.<Version>checkUniqueNames(dataModel.getVersions(), "version", _function, _function_1, 
      DataPackage.Literals.VERSION__NAME);
  }
  
  /**
   * Check top-level contexts for unique names
   */
  @Check
  public void checkUniqueContextNames(final DataModel dataModel) {
    final Function<Context, Object> _function = (Context it) -> {
      return it.getName();
    };
    final Function<Context, String> _function_1 = (Context it) -> {
      return it.getName();
    };
    this.<Context>checkUniqueNames(dataModel.getContexts(), "context", _function, _function_1, 
      DataPackage.Literals.CONTEXT__NAME);
  }
  
  /**
   * Check top-level complex types for unique names
   */
  @Check
  public void checkUniqueTypeNames(final DataModel dataModel) {
    final Function<ComplexType, Object> _function = (ComplexType it) -> {
      return it.getName();
    };
    final Function<ComplexType, String> _function_1 = (ComplexType it) -> {
      return it.getName();
    };
    this.<ComplexType>checkUniqueNames(dataModel.getComplexTypes(), "complex type", _function, _function_1, 
      DataPackage.Literals.COMPLEX_TYPE__NAME);
  }
  
  /**
   * Check contexts defined in versions for unique names
   */
  @Check
  public void checkUniqueContextNames(final Version version) {
    final Function<Context, Object> _function = (Context it) -> {
      return it.getName();
    };
    final Function<Context, String> _function_1 = (Context it) -> {
      return it.getName();
    };
    this.<Context>checkUniqueNames(version.getContexts(), "context", _function, _function_1, 
      DataPackage.Literals.CONTEXT__NAME);
  }
  
  /**
   * Check complex types defined in versions for unique names
   */
  @Check
  public void checkUniqueTypeNames(final Version version) {
    final Function<ComplexType, Object> _function = (ComplexType it) -> {
      return it.getName();
    };
    final Function<ComplexType, String> _function_1 = (ComplexType it) -> {
      return it.getName();
    };
    this.<ComplexType>checkUniqueNames(version.getComplexTypes(), "complex type", _function, _function_1, 
      DataPackage.Literals.COMPLEX_TYPE__NAME);
  }
  
  /**
   * Check complex types defined in contexts for unique names
   */
  @Check
  public void checkUniqueTypeNames(final Context context) {
    final Function<ComplexType, Object> _function = (ComplexType it) -> {
      return it.getName();
    };
    final Function<ComplexType, String> _function_1 = (ComplexType it) -> {
      return it.getName();
    };
    this.<ComplexType>checkUniqueNames(context.getComplexTypes(), "complex type", _function, _function_1, 
      DataPackage.Literals.COMPLEX_TYPE__NAME);
  }
  
  /**
   * Check operation parameters for unique names
   */
  @Check
  public void checkUniqueParameterNames(final DataOperation operation) {
    final Function<DataOperationParameter, Object> _function = (DataOperationParameter it) -> {
      return it.getName();
    };
    final Function<DataOperationParameter, String> _function_1 = (DataOperationParameter it) -> {
      return it.getName();
    };
    this.<DataOperationParameter>checkUniqueNames(operation.getParameters(), "parameter", _function, _function_1, 
      DataPackage.Literals.DATA_OPERATION_PARAMETER__NAME);
  }
  
  /**
   * Generic helper to check a list of EObjects for unique names
   */
  private <T extends EObject> void checkUniqueNames(final List<T> objectsToCheck, final String objectKind, final Function<T, Object> getCompareValue, final Function<T, String> getDuplicateOutputString, final EStructuralFeature feature) {
    final Integer duplicateIndex = LemmaUtils.<T, Object>getDuplicateIndex(objectsToCheck, getCompareValue);
    if (((duplicateIndex).intValue() == (-1))) {
      return;
    }
    final T duplicate = objectsToCheck.get((duplicateIndex).intValue());
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("Duplicate ");
    _builder.append(objectKind);
    _builder.append(" ");
    String _apply = getDuplicateOutputString.apply(duplicate);
    _builder.append(_apply);
    this.error(_builder.toString(), duplicate, feature);
  }
  
  /**
   * Check data structure for unique names
   */
  @Check
  public void checkUniqueNames(final DataStructure dataStructure) {
    final int dataFieldCount = dataStructure.getDataFields().size();
    final ArrayList<String> uniqueNames = CollectionLiterals.<String>newArrayList();
    final Function1<DataField, String> _function = (DataField it) -> {
      return it.getName();
    };
    uniqueNames.addAll(ListExtensions.<DataField, String>map(dataStructure.getDataFields(), _function));
    final Function1<DataOperation, String> _function_1 = (DataOperation it) -> {
      return it.getName();
    };
    uniqueNames.addAll(ListExtensions.<DataOperation, String>map(dataStructure.getOperations(), _function_1));
    final Function<String, String> _function_2 = (String it) -> {
      return it;
    };
    final Integer duplicateIndex = LemmaUtils.<String, String>getDuplicateIndex(uniqueNames, _function_2);
    if (((duplicateIndex).intValue() > (-1))) {
      final boolean isOperation = ((duplicateIndex).intValue() >= dataFieldCount);
      if ((!isOperation)) {
        this.error("Duplicate structure component", 
          DataPackage.Literals.DATA_STRUCTURE__DATA_FIELDS, (duplicateIndex).intValue());
      } else {
        final int operationIndex = ((duplicateIndex).intValue() - dataFieldCount);
        this.error("Duplicate structure component", 
          DataPackage.Literals.DATA_STRUCTURE__OPERATIONS, operationIndex);
      }
    }
  }
  
  /**
   * Check data structure for unique features
   */
  @Check
  public void checkUniqueFeatures(final DataStructure dataStructure) {
    final Function<DataStructureFeature, DataStructureFeature> _function = (DataStructureFeature it) -> {
      return it;
    };
    final Integer duplicateIndex = LemmaUtils.<DataStructureFeature, DataStructureFeature>getDuplicateIndex(dataStructure.getFeatures(), _function);
    if (((duplicateIndex).intValue() > (-1))) {
      this.error("Duplicate feature", dataStructure, 
        DataPackage.Literals.DATA_STRUCTURE__FEATURES, (duplicateIndex).intValue());
    }
  }
  
  /**
   * Check "aggregate" feature constraints
   */
  @Check
  public void checkAggregateFeatureConstraints(final DataStructure dataStructure) {
    final int featureIndex = dataStructure.getFeatures().indexOf(DataStructureFeature.AGGREGATE);
    if ((featureIndex == (-1))) {
      return;
    }
    boolean _hasFeature = dataStructure.hasFeature(DataStructureFeature.ENTITY);
    boolean _not = (!_hasFeature);
    if (_not) {
      this.warning("Only entities should be aggregates", dataStructure, 
        DataPackage.Literals.DATA_STRUCTURE__FEATURES, featureIndex);
    }
    final Function1<DataField, EList<DataFieldFeature>> _function = (DataField it) -> {
      return it.getFeatures();
    };
    final Iterable<DataFieldFeature> effectiveDataFieldFeatures = Iterables.<DataFieldFeature>concat(ListExtensions.<DataField, EList<DataFieldFeature>>map(dataStructure.getEffectiveFields(), _function));
    final Function1<DataFieldFeature, Boolean> _function_1 = (DataFieldFeature it) -> {
      return Boolean.valueOf(Objects.equal(it, DataFieldFeature.PART));
    };
    boolean _exists = IterableExtensions.<DataFieldFeature>exists(effectiveDataFieldFeatures, _function_1);
    boolean _not_1 = (!_exists);
    if (_not_1) {
      this.warning("Aggregate should contain at least one part", dataStructure, 
        DataPackage.Literals.DATA_STRUCTURE__FEATURES, featureIndex);
    }
  }
  
  /**
   * Check "applicationService" feature constraints
   */
  @Check
  public void checkApplicationServiceFeatureConstraints(final DataStructure dataStructure) {
    this.checkServiceFeatureConstraints(dataStructure, DataStructureFeature.APPLICATION_SERVICE);
  }
  
  /**
   * Generic helper to check constraints of a certain peculiarity of the "service" feature
   */
  public void checkServiceFeatureConstraints(final DataStructure dataStructure, final DataStructureFeature serviceFeature) {
    final int featureIndex = dataStructure.getFeatures().indexOf(serviceFeature);
    if ((featureIndex == (-1))) {
      return;
    }
    boolean _hasAdditionalDomainFeatures = this.hasAdditionalDomainFeatures(dataStructure, serviceFeature);
    if (_hasAdditionalDomainFeatures) {
      this.warning("A service should not exhibit other domain features", dataStructure, 
        DataPackage.Literals.DATA_STRUCTURE__FEATURES, featureIndex);
    }
    boolean _isEmpty = dataStructure.getEffectiveFields().isEmpty();
    boolean _not = (!_isEmpty);
    if (_not) {
      this.warning("A service should only comprise operations", dataStructure, 
        DataPackage.Literals.DATA_STRUCTURE__FEATURES, featureIndex);
    }
    boolean _isEmpty_1 = dataStructure.getEffectiveOperations().isEmpty();
    if (_isEmpty_1) {
      this.warning("A service should comprise at least one operation", dataStructure, 
        DataPackage.Literals.DATA_STRUCTURE__FEATURES, featureIndex);
    }
  }
  
  /**
   * Helper to check if a data structure has also other domain-driven-design-related features than
   * a given one
   */
  private boolean hasAdditionalDomainFeatures(final DataStructure structure, final DataStructureFeature feature) {
    final Function1<DataStructureFeature, Boolean> _function = (DataStructureFeature it) -> {
      return Boolean.valueOf(structure.getAllDomainFeatures().contains(it));
    };
    final Iterable<DataStructureFeature> domainFeaturesOnStructure = IterableExtensions.<DataStructureFeature>filter(structure.getFeatures(), _function);
    return ((IterableExtensions.size(domainFeaturesOnStructure) > 1) || 
      (!IterableExtensions.<DataStructureFeature>exists(domainFeaturesOnStructure, ((Function1<DataStructureFeature, Boolean>) (DataStructureFeature it) -> {
        return Boolean.valueOf(Objects.equal(it, feature));
      }))));
  }
  
  /**
   * Check "domainEvent" feature constraints
   */
  @Check
  public void checkDomainEventFeatureConstraints(final DataStructure dataStructure) {
    final int featureIndex = dataStructure.getFeatures().indexOf(DataStructureFeature.DOMAIN_EVENT);
    if ((featureIndex == (-1))) {
      return;
    }
    boolean _hasFeature = dataStructure.hasFeature(DataStructureFeature.VALUE_OBJECT);
    boolean _not = (!_hasFeature);
    if (_not) {
      this.warning("Only value objects should be domain events", dataStructure, 
        DataPackage.Literals.DATA_STRUCTURE__FEATURES, featureIndex);
    }
  }
  
  /**
   * Check "domainService" feature constraints
   */
  @Check
  public void checkDomainServiceFeatureConstraints(final DataStructure dataStructure) {
    this.checkServiceFeatureConstraints(dataStructure, DataStructureFeature.DOMAIN_SERVICE);
  }
  
  /**
   * Check "entity" feature constraints
   */
  @Check
  public void checkEntityFeatureConstraints(final DataStructure dataStructure) {
    final int featureIndex = dataStructure.getFeatures().indexOf(DataStructureFeature.ENTITY);
    if ((featureIndex == (-1))) {
      return;
    }
    final Function1<DataField, EList<DataFieldFeature>> _function = (DataField it) -> {
      return it.getFeatures();
    };
    final Iterable<DataFieldFeature> dataFieldFeatures = Iterables.<DataFieldFeature>concat(ListExtensions.<DataField, EList<DataFieldFeature>>map(dataStructure.getDataFields(), _function));
    final Function1<DataOperation, EList<DataOperationFeature>> _function_1 = (DataOperation it) -> {
      return it.getFeatures();
    };
    final Function1<DataOperationFeature, Boolean> _function_2 = (DataOperationFeature it) -> {
      return Boolean.valueOf(Objects.equal(it, DataOperationFeature.IDENTIFIER));
    };
    final Iterable<DataOperationFeature> identifierOperations = IterableExtensions.<DataOperationFeature>filter(Iterables.<DataOperationFeature>concat(ListExtensions.<DataOperation, EList<DataOperationFeature>>map(dataStructure.getOperations(), _function_1)), _function_2);
    final Function1<DataFieldFeature, Boolean> _function_3 = (DataFieldFeature it) -> {
      return Boolean.valueOf(Objects.equal(it, DataFieldFeature.IDENTIFIER));
    };
    final boolean hasIdentifierFields = IterableExtensions.<DataFieldFeature>exists(dataFieldFeatures, _function_3);
    boolean _isEmpty = IterableExtensions.isEmpty(identifierOperations);
    final boolean hasIdentifierOperations = (!_isEmpty);
    if (((!hasIdentifierFields) && (!hasIdentifierOperations))) {
      this.warning(("At least one non-inherited field or operation should be an identifier for " + 
        "the entity"), dataStructure, DataPackage.Literals.DATA_STRUCTURE__FEATURES, featureIndex);
    } else {
      if ((hasIdentifierFields && hasIdentifierOperations)) {
        this.warning("Identifier fields and operations should not be mixed", dataStructure, 
          DataPackage.Literals.DATA_STRUCTURE__FEATURES, featureIndex);
      }
    }
    int _size = IterableExtensions.size(identifierOperations);
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      this.warning("Only one operation should be an identifier for the entity", dataStructure, 
        DataPackage.Literals.DATA_STRUCTURE__FEATURES, featureIndex);
    }
  }
  
  /**
   * Check "factory" feature constraints
   */
  @Check
  public void checkFactoryFeatureConstraints(final DataStructure dataStructure) {
    final int featureIndex = dataStructure.getFeatures().indexOf(DataStructureFeature.FACTORY);
    if ((featureIndex == (-1))) {
      return;
    }
    boolean _hasAdditionalDomainFeatures = this.hasAdditionalDomainFeatures(dataStructure, DataStructureFeature.FACTORY);
    if (_hasAdditionalDomainFeatures) {
      this.warning("A factory should not exhibit other domain features", dataStructure, 
        DataPackage.Literals.DATA_STRUCTURE__FEATURES, featureIndex);
    }
    final Function1<DataOperation, Boolean> _function = (DataOperation it) -> {
      boolean _or = false;
      if ((it.isHasNoReturnType() || 
        (!((it.getPrimitiveOrComplexReturnType() instanceof PrimitiveType) || 
          (it.getPrimitiveOrComplexReturnType() instanceof DataStructure))))) {
        _or = true;
      } else {
        boolean _xifexpression = false;
        Type _primitiveOrComplexReturnType = it.getPrimitiveOrComplexReturnType();
        if ((_primitiveOrComplexReturnType instanceof DataStructure)) {
          boolean _xblockexpression = false;
          {
            Type _primitiveOrComplexReturnType_1 = it.getPrimitiveOrComplexReturnType();
            final DataStructure dataStructureReturnType = ((DataStructure) _primitiveOrComplexReturnType_1);
            _xblockexpression = ((!dataStructureReturnType.hasFeature(DataStructureFeature.AGGREGATE)) && 
              (!dataStructureReturnType.hasFeature(DataStructureFeature.VALUE_OBJECT)));
          }
          _xifexpression = _xblockexpression;
        } else {
          _xifexpression = false;
        }
        _or = _xifexpression;
      }
      return Boolean.valueOf(_or);
    };
    final boolean hasOperationsWithWrongReturnTypes = IterableExtensions.<DataOperation>exists(dataStructure.getEffectiveOperations(), _function);
    if (hasOperationsWithWrongReturnTypes) {
      this.warning("Factory operations should return aggregates or value objects", dataStructure, 
        DataPackage.Literals.DATA_STRUCTURE__FEATURES, featureIndex);
    }
  }
  
  /**
   * Check "infrastructureService" feature constraints
   */
  @Check
  public void checkInfrastructureServiceFeatureConstraints(final DataStructure dataStructure) {
    this.checkServiceFeatureConstraints(dataStructure, DataStructureFeature.INFRASTRUCTURE_SERVICE);
  }
  
  /**
   * Check "repository" feature constraints
   */
  @Check
  public void checkRepositoryFeatureConstraints(final DataStructure dataStructure) {
    final int featureIndex = dataStructure.getFeatures().indexOf(DataStructureFeature.REPOSITORY);
    if ((featureIndex == (-1))) {
      return;
    }
    boolean _hasAdditionalDomainFeatures = this.hasAdditionalDomainFeatures(dataStructure, DataStructureFeature.REPOSITORY);
    if (_hasAdditionalDomainFeatures) {
      this.warning("A repository should not exhibit other domain features", dataStructure, 
        DataPackage.Literals.DATA_STRUCTURE__FEATURES, featureIndex);
    }
    boolean _isEmpty = dataStructure.getEffectiveOperations().isEmpty();
    if (_isEmpty) {
      this.warning("A repository should comprise at least one operation", dataStructure, 
        DataPackage.Literals.DATA_STRUCTURE__FEATURES, featureIndex);
    }
    final Function1<DataOperation, EList<DataOperationParameter>> _function = (DataOperation it) -> {
      return it.getParameters();
    };
    final Iterable<DataOperationParameter> allDataOperationParameters = Iterables.<DataOperationParameter>concat(ListExtensions.<DataOperation, EList<DataOperationParameter>>map(dataStructure.getEffectiveOperations(), _function));
    final Function1<DataOperationParameter, Boolean> _function_1 = (DataOperationParameter it) -> {
      boolean _switchResult = false;
      Type _effectiveType = it.getEffectiveType();
      boolean _matched = false;
      if (_effectiveType instanceof PrimitiveType) {
        _matched=true;
        _switchResult = false;
      }
      if (!_matched) {
        if (_effectiveType instanceof DataStructure) {
          _matched=true;
          boolean _xblockexpression = false;
          {
            Type _effectiveType_1 = it.getEffectiveType();
            final DataStructure parameterType = ((DataStructure) _effectiveType_1);
            _xblockexpression = ((!parameterType.hasFeature(DataStructureFeature.ENTITY)) && 
              (!parameterType.hasFeature(DataStructureFeature.VALUE_OBJECT)));
          }
          _switchResult = _xblockexpression;
        }
      }
      if (!_matched) {
        _switchResult = true;
      }
      return Boolean.valueOf(_switchResult);
    };
    final boolean handlesNotOnlyEntitiesOrValueObjects = IterableExtensions.<DataOperationParameter>exists(allDataOperationParameters, _function_1);
    if (handlesNotOnlyEntitiesOrValueObjects) {
      this.warning(("Complex typed parameters of repository operations should be entities or " + 
        "value objects"), dataStructure, 
        DataPackage.Literals.DATA_STRUCTURE__FEATURES, featureIndex);
    }
  }
  
  /**
   * Check "service" feature constraints
   */
  @Check
  public void checkServiceFeatureConstraints(final DataStructure dataStructure) {
    this.checkServiceFeatureConstraints(dataStructure, DataStructureFeature.SERVICE);
  }
  
  /**
   * Check "specification" feature constraints
   */
  @Check
  public void checkSpecificationFeatureConstraints(final DataStructure dataStructure) {
    final int featureIndex = dataStructure.getFeatures().indexOf(DataStructureFeature.SPECIFICATION);
    if ((featureIndex == (-1))) {
      return;
    }
    boolean _hasAdditionalDomainFeatures = this.hasAdditionalDomainFeatures(dataStructure, DataStructureFeature.SPECIFICATION);
    if (_hasAdditionalDomainFeatures) {
      this.warning("A specification should not exhibit other domain features", dataStructure, 
        DataPackage.Literals.DATA_STRUCTURE__FEATURES, featureIndex);
    }
    final Function1<DataOperation, Boolean> _function = (DataOperation it) -> {
      return Boolean.valueOf(it.hasFeature(DataOperationFeature.VALIDATOR));
    };
    boolean _exists = IterableExtensions.<DataOperation>exists(dataStructure.getEffectiveOperations(), _function);
    boolean _not = (!_exists);
    if (_not) {
      this.warning("A specification should comprise at least one validator operation", dataStructure, DataPackage.Literals.DATA_STRUCTURE__FEATURES, featureIndex);
    }
  }
  
  /**
   * Check "valueObject" feature constraints
   */
  @Check
  public void checkValueObjectFeatureConstraints(final DataStructure dataStructure) {
    final int featureIndex = dataStructure.getFeatures().indexOf(DataStructureFeature.VALUE_OBJECT);
    if ((featureIndex == (-1))) {
      return;
    }
    final List<DataStructureFeature> forbiddenFeatures = Collections.<DataStructureFeature>unmodifiableList(CollectionLiterals.<DataStructureFeature>newArrayList(DataStructureFeature.AGGREGATE, DataStructureFeature.APPLICATION_SERVICE, DataStructureFeature.DOMAIN_SERVICE, DataStructureFeature.ENTITY, DataStructureFeature.INFRASTRUCTURE_SERVICE, DataStructureFeature.REPOSITORY, DataStructureFeature.SERVICE, DataStructureFeature.SPECIFICATION));
    final Function1<DataStructureFeature, Boolean> _function = (DataStructureFeature it) -> {
      return Boolean.valueOf(forbiddenFeatures.contains(it));
    };
    boolean _exists = IterableExtensions.<DataStructureFeature>exists(dataStructure.getFeatures(), _function);
    if (_exists) {
      this.warning(("A value object should not be an aggregate, entity, repository, service, or " + 
        "specification"), dataStructure, 
        DataPackage.Literals.DATA_STRUCTURE__FEATURES, featureIndex);
    }
  }
  
  /**
   * Perform checks on data fields
   */
  @Check
  public void checkDataField(final DataField dataField) {
    if (((dataField.getEffectiveType() == null) && (!dataField.isHidden()))) {
      this.error("Field must have a type or be hidden", dataField, 
        DataPackage.Literals.DATA_FIELD__NAME);
      return;
    }
    PrimitiveValue _initializationValue = dataField.getInitializationValue();
    boolean _tripleNotEquals = (_initializationValue != null);
    if (_tripleNotEquals) {
      PrimitiveType _primitiveType = dataField.getPrimitiveType();
      boolean _tripleEquals = (_primitiveType == null);
      if (_tripleEquals) {
        this.error("Only primitively typed data fields can be initialized", dataField, 
          DataPackage.Literals.DATA_FIELD__NAME);
        return;
      } else {
        DataStructure _dataStructure = dataField.getDataStructure();
        boolean _tripleEquals_1 = (_dataStructure == null);
        if (_tripleEquals_1) {
          this.error("Only data fields within data structures can be initialized", dataField, 
            DataPackage.Literals.DATA_FIELD__NAME);
          return;
        } else {
          boolean _isOfType = dataField.getInitializationValue().isOfType(dataField.getPrimitiveType());
          boolean _not = (!_isOfType);
          if (_not) {
            StringConcatenation _builder = new StringConcatenation();
            _builder.append("Value is not of type ");
            String _typeName = dataField.getPrimitiveType().getTypeName();
            _builder.append(_typeName);
            _builder.append(" ");
            this.error(_builder.toString(), dataField, 
              DataPackage.Literals.DATA_FIELD__INITIALIZATION_VALUE);
            return;
          }
        }
      }
    }
    if ((((dataField.isHidden() && 
      dataField.isImmutable()) && 
      (dataField.getPrimitiveType() != null)) && 
      (dataField.getInitializationValue() == null))) {
      this.error("Hidden immutable fields need to be initialized", dataField, 
        DataPackage.Literals.DATA_FIELD__NAME);
      return;
    }
    final Function<DataFieldFeature, DataFieldFeature> _function = (DataFieldFeature it) -> {
      return it;
    };
    final Integer duplicateFeatureIndex = LemmaUtils.<DataFieldFeature, DataFieldFeature>getDuplicateIndex(dataField.getFeatures(), _function);
    if (((duplicateFeatureIndex).intValue() > (-1))) {
      this.error("Duplicate feature", dataField, 
        DataPackage.Literals.DATA_FIELD__FEATURES, (duplicateFeatureIndex).intValue());
      return;
    }
    final DataField equalSuperField = dataField.findEponymousSuperField();
    if (((equalSuperField == null) || equalSuperField.isHidden())) {
      Type _effectiveType = dataField.getEffectiveType();
      boolean _tripleEquals_2 = (_effectiveType == null);
      if (_tripleEquals_2) {
        this.error("Field must have a type", dataField, DataPackage.Literals.DATA_FIELD__NAME);
      }
    } else {
      String superQualifiedName = QualifiedName.create(equalSuperField.getQualifiedNameParts()).toString();
      Type _effectiveType_1 = dataField.getEffectiveType();
      boolean _tripleNotEquals_1 = (_effectiveType_1 != null);
      if (_tripleNotEquals_1) {
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("Field cannot redefine inherited field ");
        _builder_1.append(superQualifiedName);
        this.error(_builder_1.toString(), dataField, 
          DataPackage.Literals.DATA_FIELD__NAME);
      } else {
        boolean _isEmpty = dataField.getFeatures().isEmpty();
        boolean _not_1 = (!_isEmpty);
        if (_not_1) {
          this.error("Feature assignment is not allowed for inherited fields", dataField, 
            DataPackage.Literals.DATA_FIELD__FEATURES);
        } else {
          boolean _isImmutable = dataField.isImmutable();
          if (_isImmutable) {
            this.error("Inherited fields cannot be immutable", dataField, 
              DataPackage.Literals.DATA_FIELD__IMMUTABLE);
          }
        }
      }
    }
  }
  
  /**
   * Check "part" feature constraints
   */
  @Check
  public void checkPartFeatureConstraints(final DataField dataField) {
    final int featureIndex = dataField.getFeatures().indexOf(DataFieldFeature.PART);
    if ((featureIndex == (-1))) {
      return;
    }
    DataStructure _dataStructure = dataField.getDataStructure();
    boolean _tripleEquals = (_dataStructure == null);
    if (_tripleEquals) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("The \"part\" feature is only allowed on data structure fields");
      this.error(_builder.toString(), dataField, 
        DataPackage.Literals.DATA_FIELD__FEATURES, featureIndex);
      return;
    }
    Type _effectiveType = dataField.getEffectiveType();
    boolean _not = (!(_effectiveType instanceof DataStructure));
    if (_not) {
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("Only fields with structural type may exhibit the \"part\" feature");
      this.error(_builder_1.toString(), dataField, 
        DataPackage.Literals.DATA_FIELD__FEATURES, featureIndex);
      return;
    }
    boolean _hasFeature = dataField.getDataStructure().hasFeature(DataStructureFeature.AGGREGATE);
    boolean _not_1 = (!_hasFeature);
    if (_not_1) {
      this.warning("Parts should only be defined in aggregates", dataField, 
        DataPackage.Literals.DATA_FIELD__FEATURES, featureIndex);
    }
    Type _effectiveType_1 = dataField.getEffectiveType();
    final DataStructure fieldType = ((DataStructure) _effectiveType_1);
    if (((!fieldType.hasFeature(DataStructureFeature.ENTITY)) && 
      (!fieldType.hasFeature(DataStructureFeature.VALUE_OBJECT)))) {
      this.warning("Parts should be entities or value objects", dataField, 
        DataPackage.Literals.DATA_FIELD__FEATURES, featureIndex);
    }
    ImportedComplexType _importedComplexType = dataField.getImportedComplexType();
    final boolean fieldTypeIsImported = (_importedComplexType != null);
    if ((fieldTypeIsImported || 
      (!Objects.equal(fieldType.getClosestNamespace(), dataField.getDataStructure().getClosestNamespace())))) {
      this.warning("Parts should be defined in the same namespace as the aggregate", dataField, 
        DataPackage.Literals.DATA_FIELD__FEATURES, featureIndex);
    }
  }
  
  /**
   * Perform checks on data operations
   */
  @Check
  public void checkOperation(final DataOperation dataOperation) {
    final Function<DataOperationFeature, DataOperationFeature> _function = (DataOperationFeature it) -> {
      return it;
    };
    final Integer duplicateIndex = LemmaUtils.<DataOperationFeature, DataOperationFeature>getDuplicateIndex(dataOperation.getFeatures(), _function);
    if (((duplicateIndex).intValue() > (-1))) {
      this.error("Duplicate feature", dataOperation, 
        DataPackage.Literals.DATA_OPERATION__FEATURES, (duplicateIndex).intValue());
      return;
    }
    final DataOperation superOperation = dataOperation.findEponymousSuperOperation();
    String _xifexpression = null;
    if ((superOperation != null)) {
      _xifexpression = QualifiedName.create(superOperation.getQualifiedNameParts()).toString();
    } else {
      _xifexpression = null;
    }
    final String superOperationName = _xifexpression;
    final boolean superOperationIsHidden = ((superOperation != null) && superOperation.isHidden());
    final boolean thisIsInherited = (superOperation != null);
    final boolean thisIsHidden = dataOperation.isHidden();
    final boolean redefinitionAttempt = (thisIsInherited && (!superOperationIsHidden));
    final boolean operationTypesDiffer = (thisIsInherited && 
      (dataOperation.isHasNoReturnType() != superOperation.isHasNoReturnType()));
    if ((thisIsInherited && (!dataOperation.getFeatures().isEmpty()))) {
      this.error("Feature assignment is not allowed for inherited operations", dataOperation, 
        DataPackage.Literals.DATA_OPERATION__FEATURES);
      return;
    }
    if (redefinitionAttempt) {
      if ((!thisIsHidden)) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Operation cannot redefine operation ");
        _builder.append(superOperationName);
        _builder.append(" ");
        this.error(_builder.toString(), dataOperation, DataPackage.Literals.DATA_OPERATION__NAME);
        return;
      } else {
        if (operationTypesDiffer) {
          StringConcatenation _builder_1 = new StringConcatenation();
          _builder_1.append("or function) as ");
          _builder_1.append(superOperationName);
          String _plus = ("Hidden inherited operation must have the same operation type (procedure " + _builder_1);
          this.error(_plus, dataOperation, 
            DataPackage.Literals.DATA_OPERATION__NAME);
          return;
        } else {
          Type _primitiveOrComplexReturnType = dataOperation.getPrimitiveOrComplexReturnType();
          boolean _tripleNotEquals = (_primitiveOrComplexReturnType != null);
          if (_tripleNotEquals) {
            this.error("Hidden inherited operation must not specify a return type", dataOperation, 
              DataPackage.Literals.DATA_OPERATION__NAME);
            return;
          } else {
            boolean _isEmpty = dataOperation.getParameters().isEmpty();
            boolean _not = (!_isEmpty);
            if (_not) {
              this.error("Hidden inherited operation must not specify parameters", dataOperation, 
                DataPackage.Literals.DATA_OPERATION__NAME);
              return;
            }
          }
        }
      }
    }
    if ((dataOperation.isLacksReturnTypeSpecification() && ((!thisIsHidden) || (!thisIsInherited)))) {
      this.error("Operation must have a return type specification or be hidden", dataOperation, 
        DataPackage.Literals.DATA_OPERATION__NAME);
    }
  }
  
  /**
   * Check "closure" feature constraints
   */
  @Check
  public void checkClosureFeatureConstraints(final DataOperation dataOperation) {
    final int featureIndex = dataOperation.getFeatures().indexOf(DataOperationFeature.CLOSURE);
    if ((featureIndex == (-1))) {
      return;
    }
    if ((dataOperation.hasFeature(DataOperationFeature.IDENTIFIER) || 
      dataOperation.hasFeature(DataOperationFeature.VALIDATOR))) {
      this.warning("A closure should not be an identifier or validator", dataOperation, 
        DataPackage.Literals.DATA_OPERATION__FEATURES, featureIndex);
    }
    final boolean hasExactlyOneParameterAndReturnType = ((dataOperation.getParameters().size() == 1) && 
      (!dataOperation.isHasNoReturnType()));
    if ((!hasExactlyOneParameterAndReturnType)) {
      this.warning("A closure should take exactly one parameter and have a return type", dataOperation, DataPackage.Literals.DATA_OPERATION__FEATURES, featureIndex);
    }
    if (hasExactlyOneParameterAndReturnType) {
      final Type parameterType = dataOperation.getParameters().get(0).getEffectiveType();
      final Type returnType = dataOperation.getPrimitiveOrComplexReturnType();
      boolean _isEquivalent = this.isEquivalent(returnType, parameterType);
      boolean _not = (!_isEquivalent);
      if (_not) {
        this.warning("A closure should return a value of the same type as its parameter", dataOperation, DataPackage.Literals.DATA_OPERATION__FEATURES, featureIndex);
      }
    }
  }
  
  /**
   * Helper to check if type1 is equivalent with type2. In this context, equivalence means that
   * type1 is identical to type2, or that it is an extension of type2.
   */
  private boolean isEquivalent(final Type type1, final Type type2) {
    boolean _xifexpression = false;
    if (((type1 instanceof PrimitiveType) && (type2 instanceof PrimitiveType))) {
      String _typeName = ((PrimitiveType) type1).getTypeName();
      _xifexpression = Objects.equal(_typeName, ((PrimitiveType) type2));
    } else {
      boolean _xifexpression_1 = false;
      if (((type1 instanceof DataStructure) && (type2 instanceof DataStructure))) {
        boolean _xblockexpression = false;
        {
          final DataStructure dataStructure1 = ((DataStructure) type1);
          final DataStructure dataStructure2 = ((DataStructure) type2);
          _xblockexpression = (Objects.equal(dataStructure1.buildQualifiedName("."), dataStructure2.buildQualifiedName(".")) || 
            dataStructure1.isExtensionOf(dataStructure2));
        }
        _xifexpression_1 = _xblockexpression;
      } else {
        boolean _xifexpression_2 = false;
        if (((type1 instanceof ListType) && (type2 instanceof ListType))) {
          String _buildQualifiedName = ((ListType) type1).buildQualifiedName(".");
          String _buildQualifiedName_1 = ((ListType) type2).buildQualifiedName(".");
          _xifexpression_2 = Objects.equal(_buildQualifiedName, _buildQualifiedName_1);
        } else {
          boolean _xifexpression_3 = false;
          if (((type1 instanceof Enumeration) && (type2 instanceof Enumeration))) {
            String _name = ((Enumeration) type1).getName();
            String _name_1 = ((Enumeration) type2).getName();
            _xifexpression_3 = Objects.equal(_name, _name_1);
          } else {
            _xifexpression_3 = false;
          }
          _xifexpression_2 = _xifexpression_3;
        }
        _xifexpression_1 = _xifexpression_2;
      }
      _xifexpression = _xifexpression_1;
    }
    return _xifexpression;
  }
  
  /**
   * Check "sideEffectFree" feature constraints
   */
  @Check
  public void checkSideEffectFreeFeatureConstraints(final DataOperation dataOperation) {
    final int featureIndex = dataOperation.getFeatures().indexOf(DataOperationFeature.SIDE_EFFECT_FREE);
    if ((featureIndex == (-1))) {
      return;
    }
    boolean _isHasNoReturnType = dataOperation.isHasNoReturnType();
    if (_isHasNoReturnType) {
      this.warning("A side effect free operation should be a function", dataOperation, 
        DataPackage.Literals.DATA_OPERATION__FEATURES, featureIndex);
    }
  }
  
  /**
   * Check "validator" feature constraints
   */
  @Check
  public void checkValidatorFeatureConstraints(final DataOperation dataOperation) {
    final int featureIndex = dataOperation.getFeatures().indexOf(DataOperationFeature.VALIDATOR);
    if ((featureIndex == (-1))) {
      return;
    }
    boolean _hasFeature = dataOperation.getDataStructure().hasFeature(DataStructureFeature.SPECIFICATION);
    boolean _not = (!_hasFeature);
    if (_not) {
      this.warning("A validator operation should be defined within a specification", dataOperation, 
        DataPackage.Literals.DATA_OPERATION__FEATURES, featureIndex);
    }
    if (((dataOperation.isHasNoReturnType() || 
      (dataOperation.getPrimitiveReturnType() == null)) || 
      (!Objects.equal(dataOperation.getPrimitiveReturnType().getTypeName(), PrimitiveTypeConstants.BOOLEAN.getLiteral())))) {
      StringConcatenation _builder = new StringConcatenation();
      String _literal = PrimitiveTypeConstants.BOOLEAN.getLiteral();
      _builder.append(_literal);
      String _plus = ("A validator operation should return a value of type " + _builder);
      this.warning(_plus, dataOperation, 
        DataPackage.Literals.DATA_OPERATION__FEATURES, featureIndex);
    }
  }
  
  /**
   * Check "identifier" feature constraints
   */
  @Check
  public void checkIdentifierFeatureConstraints(final DataOperation dataOperation) {
    final int featureIndex = dataOperation.getFeatures().indexOf(DataOperationFeature.IDENTIFIER);
    if ((featureIndex == (-1))) {
      return;
    }
    boolean _hasFeature = dataOperation.hasFeature(DataOperationFeature.VALIDATOR);
    if (_hasFeature) {
      this.warning("An identifier should not be a validator", dataOperation, 
        DataPackage.Literals.DATA_OPERATION__FEATURES, featureIndex);
    }
  }
  
  /**
   * Check if an imported file exists
   */
  @Check
  public void checkImportFileExists(final ComplexTypeImport complexTypeImport) {
    boolean _importFileExists = LemmaUtils.importFileExists(complexTypeImport.eResource(), complexTypeImport.getImportURI());
    boolean _not = (!_importFileExists);
    if (_not) {
      this.error("File not found", complexTypeImport, 
        DataPackage.Literals.COMPLEX_TYPE_IMPORT__IMPORT_URI);
    }
  }
  
  /**
   * Check for cyclic inheritance relationships between data structures
   */
  @Check
  public void checkCyclicInheritance(final DataStructure dataStructure) {
    final Function<DataStructure, DataStructure> _function = (DataStructure it) -> {
      return it.getSuper();
    };
    boolean _hasCyclicInheritance = LemmaUtils.<DataStructure>hasCyclicInheritance(dataStructure, _function);
    if (_hasCyclicInheritance) {
      this.error("Cyclic inheritance detected", dataStructure, 
        DataPackage.Literals.COMPLEX_TYPE__NAME);
    }
  }
  
  /**
   * Check for cyclic imports (non-transitive)
   */
  @Check
  public void checkForCyclicImports(final ComplexTypeImport complexTypeImport) {
    final Function<DataModel, List<Resource>> _function = (DataModel it) -> {
      final Function1<ComplexTypeImport, Resource> _function_1 = (ComplexTypeImport it_1) -> {
        return EcoreUtil2.getResource(it_1.eResource(), it_1.getImportURI());
      };
      return ListExtensions.<ComplexTypeImport, Resource>map(it.getComplexTypeImports(), _function_1);
    };
    final Function<DataModel, List<Resource>> getImportedDataModelResources = _function;
    boolean _isCyclicImport = LemmaUtils.<ComplexTypeImport, DataModel>isCyclicImport(complexTypeImport, DataModel.class, getImportedDataModelResources);
    if (_isCyclicImport) {
      this.error("Cyclic import detected", complexTypeImport, 
        DataPackage.Literals.COMPLEX_TYPE_IMPORT__IMPORT_URI);
    }
  }
  
  /**
   * Check versions for non-emptyness
   */
  @Check
  public void checkVersionNotEmpty(final Version version) {
    if ((version.getContexts().isEmpty() && version.getComplexTypes().isEmpty())) {
      this.error("A version must define at least one context or complex type", version, 
        DataPackage.Literals.VERSION__NAME);
    }
  }
}
