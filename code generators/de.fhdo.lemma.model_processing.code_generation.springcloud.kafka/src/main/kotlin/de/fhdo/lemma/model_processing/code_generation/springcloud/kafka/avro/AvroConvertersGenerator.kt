package de.fhdo.lemma.model_processing.code_generation.springcloud.kafka.avro

import com.github.javaparser.StaticJavaParser
import com.github.javaparser.ast.Modifier
import com.github.javaparser.ast.Node
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration
import com.github.javaparser.ast.body.ConstructorDeclaration
import com.github.javaparser.ast.body.EnumDeclaration
import com.github.javaparser.ast.body.MethodDeclaration
import com.github.javaparser.ast.body.TypeDeclaration
import com.github.javaparser.ast.expr.Expression
import com.github.javaparser.ast.expr.SimpleName
import com.github.javaparser.ast.stmt.BlockStmt
import com.github.javaparser.ast.stmt.ExpressionStmt
import com.github.javaparser.ast.stmt.Statement
import com.github.javaparser.ast.type.ClassOrInterfaceType
import com.github.javaparser.ast.type.Type
import de.fhdo.lemma.data.PrimitiveTypeConstants
import de.fhdo.lemma.data.intermediate.IntermediateCollectionType
import de.fhdo.lemma.data.intermediate.IntermediateComplexType
import de.fhdo.lemma.data.intermediate.IntermediateDataField
import de.fhdo.lemma.data.intermediate.IntermediateDataStructure
import de.fhdo.lemma.data.intermediate.IntermediateEnumeration
import de.fhdo.lemma.data.intermediate.IntermediateImportedTechnologySpecificType
import de.fhdo.lemma.data.intermediate.IntermediatePrimitiveType
import de.fhdo.lemma.data.intermediate.IntermediateType
import de.fhdo.lemma.data.intermediate.IntermediateTypeKind
import de.fhdo.lemma.model_processing.code_generation.java_base.ast.ImportTargetElementType
import de.fhdo.lemma.model_processing.code_generation.java_base.ast.SerializationCharacteristic
import de.fhdo.lemma.model_processing.code_generation.java_base.ast.addSerializationCharacteristic
import de.fhdo.lemma.model_processing.code_generation.java_base.ast.appendStatement
import de.fhdo.lemma.model_processing.code_generation.java_base.ast.attributes
import de.fhdo.lemma.model_processing.code_generation.java_base.ast.setBody
import de.fhdo.lemma.model_processing.code_generation.java_base.instantiableClassName
import de.fhdo.lemma.model_processing.code_generation.java_base.languages.TypeMappingDescription
import de.fhdo.lemma.model_processing.code_generation.java_base.languages.getItemClassnamesAndImports
import de.fhdo.lemma.model_processing.code_generation.java_base.languages.getObjectWrapperMapping
import de.fhdo.lemma.model_processing.code_generation.java_base.languages.getTypeMapping
import de.fhdo.lemma.model_processing.code_generation.java_base.languages.typeArgumentObjectWrapperMapping
import de.fhdo.lemma.model_processing.code_generation.java_base.resolve
import de.fhdo.lemma.model_processing.code_generation.springcloud.kafka.addRelocatableImport
import de.fhdo.lemma.model_processing.code_generation.springcloud.kafka.findMethod
import de.fhdo.lemma.model_processing.code_generation.springcloud.kafka.getExistingGetter
import de.fhdo.lemma.model_processing.code_generation.springcloud.kafka.getExistingSetter
import de.fhdo.lemma.model_processing.utils.trimToSingleLine

private const val AVRO_CONVERTER_PREFIX = "avro"
private const val AVRO_DATE_TYPE = "java.time.Instant"
private val AVRO_DATE_TYPE_CONVERTER_IMPORTS = setOf("java.util.Date")
private const val AVRO_DATE_TYPE_CONVERTER_METHOD = "toInstant"
private const val AVRO_DATE_TYPE_CONVERTER_FUNCTION_REFERENCE = "Date::$AVRO_DATE_TYPE_CONVERTER_METHOD"
private const val AVRO_OBJECT = "avroObject"
private const val AVRO_ENTRY = "avroEntry"

private const val DOMAIN_CONVERTER_PREFIX = "domain"
private const val DOMAIN_DATE_TYPE = "java.util.Date"
private val DOMAIN_DATE_TYPE_CONVERTER_IMPORTS = setOf(DOMAIN_DATE_TYPE)
private const val DOMAIN_DATE_TYPE_CONVERTER_METHOD = "from"
private const val DOMAIN_DATE_TYPE_CONVERTER_FUNCTION_REFERENCE = "Date::$DOMAIN_DATE_TYPE_CONVERTER_METHOD"
private const val DOMAIN_DATE_TYPE_STATIC_CONVERTER = "Date.$DOMAIN_DATE_TYPE_CONVERTER_METHOD"
private const val DOMAIN_OBJECT = "domainObject"
private const val DOMAIN_ENTRY = "domainEntry"

/**
 * Generator for Avro conversion helpers. An Avro conversion helper is a class that gathers methods to create (i) Avro
 * generic records for schemas annotated on LEMMA structures with the AvroSchema aspect; and (ii) convert between Java
 * representations of LEMMA complex types and the corresponding classes generated by the Avro compiler from schemas
 * annotated on LEMMA structures.
 *
 * @author [Florian Rademacher](mailto:florian.rademacher@fh-dortmund.de)
 */
class AvroConvertersGenerator(private val domainPackage: String) {
    /**
     * Generate Avro and domain converters from the given [rootStructure], which is the LEMMA
     * [IntermediateDataStructure] that has an Avro schema annotated via the AvroSchema aspect.
     *
     * An Avro converter converts a domain object (i.e., an instance of a Java class generated from a LEMMA complex
     * type) into the corresponding Avro object (i.e., an instance of a Java class generated from the Avro schema of the
     * root structure). A domain converter performs the opposite conversion.
     */
    fun generateConverters(rootStructure: IntermediateDataStructure) {
        resetState()
        val targetClass = AvroConversionTypeManager.getOrCreateHelpersClass(domainPackage, rootStructure)
        targetClass.addRootStructureAvroConverters(rootStructure)
        targetClass.addRootStructureDomainConverters(rootStructure)
    }

    /**
     * Reset the state of this [AvroConvertersGenerator]
     */
    private fun resetState() {
        NestedConverterCallchains.reset()
        AbstractNestedConverterCall.reset()
    }

    /**
     * Generate [AbstractAvroConverter]s from the given [rootStructure] and add them to this
     * [ClassOrInterfaceDeclaration]
     */
    private fun ClassOrInterfaceDeclaration.addRootStructureAvroConverters(rootStructure: IntermediateDataStructure) {
        val createdConverters = mutableMapOf<String, AbstractAvroConverter>()
        addAvroConverter(rootStructure, rootStructure) { createdConverters[it.identifier] = it }
        createdConverters.values.forEach { it.generateBody() }
    }

    /**
     * Generate an [AbstractAvroConverter] for the given [complexType] in the [rootStructure]'s context (i.e., by
     * considering the annotated Avro schema) and add to this [ClassOrInterfaceDeclaration]. The [converterAddedToClass]
     * callback will be invoked when the converter got added to this [ClassOrInterfaceDeclaration].
     */
    private fun ClassOrInterfaceDeclaration.addAvroConverter(
        complexType: IntermediateComplexType,
        rootStructure: IntermediateDataStructure,
        converterAddedToClass: (AbstractAvroConverter)->Unit
    ) : Boolean {
        return try {
            val converter = when(complexType) {
                is IntermediateDataStructure -> StructureAvroConverter(this, complexType, rootStructure)
                is IntermediateEnumeration -> EnumerationAvroConverter(this, complexType, rootStructure)
                is IntermediateCollectionType -> CollectionTypeAvroConverter(this, complexType, rootStructure)
                else -> throw IllegalArgumentException("Unsupported modeled type ${complexType::class.java.name}")
            }

            // Generate the converter's declaration in this class and in the case of success, also derive all
            // information required for the converter's subsequent body generation. The latter step may result in
            // required nested converter calls, whose generation will then be triggered as a recursive call to this
            // function.
            if (converter.generateDeclaration(converterAddedToClass)) {
                converter.deriveBodyInformation()
                AbstractNestedConverterCall.generateRequiredConverters { nestedConverterCall ->
                    addAvroConverter(nestedConverterCall.complexType, rootStructure, converterAddedToClass)
                }
            }

            true
        } catch(ex: ConverterCreationException) {
            appendBlockComment("Missing Avro converter: ${ex.message}")
            false
        }
    }

    /**
     * Generate [AbstractDomainConverter]s from the given [rootStructure] and add them to this
     * [ClassOrInterfaceDeclaration]
     */
    private fun ClassOrInterfaceDeclaration.addRootStructureDomainConverters(rootStructure: IntermediateDataStructure) {
        val createdConverters = mutableMapOf<String, AbstractDomainConverter>()
        addDomainConverter(rootStructure, rootStructure) { createdConverters[it.identifier] = it }
        createdConverters.values.forEach { it.generateBody() }
    }

    /**
     * Generate an [AbstractDomainConverter] for the given [complexType] in the [rootStructure]'s context (i.e., by
     * considering the annotated Avro schema) and add to this [ClassOrInterfaceDeclaration]. The [converterAddedToClass]
     * callback will be invoked when the converter got added to this [ClassOrInterfaceDeclaration].
     */
    private fun ClassOrInterfaceDeclaration.addDomainConverter(
        complexType: IntermediateComplexType,
        rootStructure: IntermediateDataStructure,
        converterAddedToClass: (AbstractDomainConverter)->Unit
    ) : Boolean {
        return try {
            val converter = when(complexType) {
                is IntermediateDataStructure -> StructureDomainConverter(this, complexType, rootStructure)
                is IntermediateEnumeration -> EnumerationDomainConverter(this, complexType, rootStructure)
                is IntermediateCollectionType -> CollectionTypeDomainConverter(this, complexType, rootStructure)
                else -> throw IllegalArgumentException("Unsupported modeled type ${complexType::class.java.name}")
            }

            // Generate the converter's declaration in this class and in the case of success, also derive all
            // information required for the converter's subsequent body generation. The latter step may result in
            // required nested converter calls, whose generation will then be triggered as a recursive call to this
            // function.
            if (converter.generateDeclaration(converterAddedToClass)) {
                converter.deriveBodyInformation()
                AbstractNestedConverterCall.generateRequiredConverters { nestedConverterCall ->
                    addDomainConverter(nestedConverterCall.complexType, rootStructure, converterAddedToClass)
                }
            }

            true
        } catch(ex: ConverterCreationException) {
            appendBlockComment("Missing domain converter: ${ex.message}")
            false
        }
    }
}

/**
 * Abstract super class for all [MethodDeclaration]s in a given [clazz] that convert a domain/Avro object into a
 * corresponding Avro/domain object. An [AbstractConverter] always has a single input parameter called
 * [sourceObjectName] whose argument is the domain/Avro object which the converter translates into the corresponding
 * Avro/domain object.
 *
 * @author [Florian Rademacher](mailto:florian.rademacher@fh-dortmund.de)
 */
private abstract class AbstractConverter<out C: AbstractNestedConverterCall, out T: AbstractConverter<C, T>>(
    val clazz: ClassOrInterfaceDeclaration,
    val complexType: IntermediateComplexType,
    val rootStructure: IntermediateDataStructure,
    private val deriveConverterName: (IntermediateComplexType) -> String,
    val sourceObjectName: String,
    val receiverObjectName: String
) : MethodDeclaration() {
    lateinit var domainType: TypeDeclaration<*>
        private set
    lateinit var avroType: TypeDeclaration<*>
        private set
    lateinit var identifier: String
        private set

    /**
     * Create the declaration part of this [AbstractConverter] comprising its modifiers, return type, and signature in
     * the target [clazz]. The [converterAddedToClass] enables callers to pass a callback that gets invoked after the
     * declaration was added to [clazz]. The boolean return value of the method signals the caller itself whether the
     * declaration got added to [clazz]. Thus, in case [converterAddedToClass] gets invoked, the method will also return
     * true.
     */
    fun generateDeclaration(converterAddedToClass: (T)->Unit) : Boolean {
        /*
         * Inform implementers about the beginning of the declaration creation and enable them to stop declaration
         * creation when necessary
         */
        if (!startDeclarationCreation())
            return false

        /* Set the converter's modifier, name, and serialization characteristics */
        addModifier(Modifier.Keyword.PUBLIC)
        name = SimpleName(deriveConverterName(complexType))
        addSerializationCharacteristic(SerializationCharacteristic.REMOVE_ON_RELOCATION)

        /* Retrieve all typing information for the converter's declaration */
        domainType = findDomainType()
        avroType = findAvroType(rootStructure)
        val (returnType, returnTypeImports) = getReturnTypeNameAndImports()
        val (parameterType, parameterTypeImports) = getParameterTypeNameAndImports()

        /* Calculate the converter's identifier from information concerning its signature */
        identifier = calculateConverterIdentifier(clazz, nameAsString, parameterType)

        /* Abort if the class already comprises a method with the same signature as that of the converter */
        if (clazz.findMethod(nameAsString, parameterType) != null)
            return false

        /* Add return type and parameter to the converter's declaration */
        setType(returnType)
        addParameter(parameterType, sourceObjectName)

        /* Add the converter to the target class and propagate all type-related import statements */
        clazz.addMember(this)
        val typeImports = mutableSetOf<String>()
        typeImports.addAll(returnTypeImports)
        typeImports.addAll(parameterTypeImports)
        typeImports.forEach { addRelocatableImport(it, ImportTargetElementType.METHOD) }

        /*
         * Notify the companion object of AbstractNestedConverterCall that the converter was added to its class. The
         * companion object manages a list of nested converters required to be called from other converters. Since at
         * the time of the generation of the calling converters, nested converters may not yet exist (and their
         * generation could also fail), the object keeps track of all existent as well as not yet existent nested
         * converters and with the following notification we flag this converter as existent.
         */
        AbstractNestedConverterCall.converterCreated(this)

        /*
         * Invoke the passed callback and inform callers about the successful creation of this converter's declaration
         * within the target class
         */
        @Suppress("UNCHECKED_CAST")
        converterAddedToClass(this as T)
        return true
    }

    /*
     * Callback to inform implementers about the beginning of the declaration creation
     */
    open fun startDeclarationCreation() = true

    /**
     * Find the [TypeDeclaration] for the object that the converter treats as domain object. By default, this is the
     * Java class generated from the given [complexType].
     */
    protected open fun findDomainType() =
        AvroConversionTypeManager.getJavaTypeGeneratedFromModel(complexType)
            ?: throw DomainTypeNotFoundException(complexType)

    /**
     * Find the [TypeDeclaration] for the object that the converter treats as Avro object. The search for the
     * [TypeDeclaration] happens in the context of the [rootStructure] that specified the Avro schema from which the
     * [TypeDeclaration] was compiled. By default, the method returns the Java class of the same name as the previously
     * found [domainType].
     */
    protected open fun findAvroType(rootStructure: IntermediateDataStructure)
        = AvroConversionTypeManager.getJavaTypeCompiledFromSchemaOfRootStructure(rootStructure, domainType.nameAsString)
            ?: throw AvroTypeNotFoundException(rootStructure, domainType)

    /**
     * Get the name of the converter's return type and all related imports
     */
    protected abstract fun getReturnTypeNameAndImports() : Pair<String, Set<String>>

    /**
     * Get the names of the converter's parameter type and all related imports
     */
    protected abstract fun getParameterTypeNameAndImports() : Pair<String, Set<String>>

    /**
     * Derive information about the body of this [AbstractConverter]. Implementers can use this method to gather
     * information relevant to [generateBody]. In particular, the method allows identification of nested converter calls
     * in the form of  [AbstractNestedConverterCall] instances.
     */
    open fun deriveBodyInformation() {
        // NOOP
    }

    /**
     * Perform the actual generation of the body of this [AbstractConverter]
     */
    abstract fun generateBody()
}

/**
 * Abstract super class for [ExpressionStmt]s that constitute nested calls to [AbstractConverter]s from the bodies of
 * other [AbstractConverter]s.
 *
 * @author [Florian Rademacher](mailto:florian.rademacher@fh-dortmund.de)
 */
private abstract class AbstractNestedConverterCall(
    private val caller: AbstractConverter<AbstractNestedConverterCall, AbstractConverter<*, *>>,
    convertedTypeName: String,
    private val avroObjectName: String = AVRO_OBJECT,
    private val domainObjectName: String = DOMAIN_OBJECT,
    val complexType: IntermediateComplexType,
    deriveNestedConverterName: (IntermediateComplexType) -> String
) : ExpressionStmt() {
    /**
     * Companion object to manage all required nested converters and their existence
     */
    companion object {
        private val requiredNestedConverters = mutableMapOf<String, MutableList<AbstractNestedConverterCall>>()
        private val createdNestedConverters = mutableSetOf<String>()
        private val failedNestedConverters = mutableSetOf<String>()

        /**
         * Notify that the [newConverter] was added to its class
         */
        fun converterCreated(newConverter: AbstractConverter<AbstractNestedConverterCall, AbstractConverter<*, *>>)
            = converterCreated(newConverter.identifier)

        /**
         * Notify that the converter with the given [identifier] was added to its class
         */
        fun converterCreated(converterIdentifier: String)
            = createdNestedConverters.registerConverterDeclarationCreationAttempt(converterIdentifier, true)

        /**
         * Register the successful ([converterExists] = true) or failed ([converterExists] = false) attempt to create
         * the declaration of a nested converter within its target class
         */
        private fun MutableSet<String>.registerConverterDeclarationCreationAttempt(converterIdentifier: String,
            converterExists: Boolean) {
            val converterCalls = requiredNestedConverters[converterIdentifier]
            converterCalls?.forEach { it.converterExists = converterExists }
            requiredNestedConverters.remove(converterIdentifier)
            add(converterIdentifier)
        }

        /**
         * Generate all registered, yet required converters using the given [generator]
         */
        fun generateRequiredConverters(generator: (AbstractNestedConverterCall)->Boolean) {
            val generationCandidates = mutableListOf<AbstractNestedConverterCall>()
            requiredNestedConverters.entries.forEach { (identifier, calls) ->
                // We only need to generate the first call of the identifier. If its creation has already been
                // successful, we only inform all gathered calls to the converter about its state of existence.
                val generationCandidate = calls.first()
                if (!creationAlreadyAttempted(identifier))
                    generationCandidates.add(generationCandidate)
                else if (identifier in createdNestedConverters)
                    converterCreated(identifier)
                else
                    converterCreationFailed(identifier)
            }

            generationCandidates.forEach {
                if (generator(it))
                    converterCreated(it.identifier)
                else
                    converterCreationFailed(it.identifier)
            }
        }

        /**
         * Verify if the creation of the converter with the given [converterIdentifier] was already attempted
         */
        private fun creationAlreadyAttempted(converterIdentifier: String)
            = converterIdentifier in createdNestedConverters || converterIdentifier in failedNestedConverters

        /**
         * Notify that the creation of the converter with the given [converterIdentifier] failed
         */
        private fun converterCreationFailed(converterIdentifier: String)
            = failedNestedConverters.registerConverterDeclarationCreationAttempt(converterIdentifier, false)

        /**
         * Reset object state
         */
        fun reset() {
            requiredNestedConverters.clear()
            createdNestedConverters.clear()
            failedNestedConverters.clear()
        }
    }

    val converterName = deriveNestedConverterName(complexType)
    val identifier = calculateConverterIdentifier(caller.clazz, converterName, convertedTypeName)
    private var expressionInitialized = false
    var converterExists = false
        private set

    /**
     * Initialize this instance
     */
    init {
        if (!creationAlreadyAttempted(identifier)) {
            if (identifier !in requiredNestedConverters)
                requiredNestedConverters[identifier] = mutableListOf()

            @Suppress("LeakingThis")
            requiredNestedConverters[identifier]!!.add(this)
        }
    }

    /**
     * Version of [ExpressionStmt.getExpression] that allows downstream creation of an [Expression] instance by
     * implementers of [AbstractNestedConverterCall]
     */
    override fun getExpression() : Expression {
        initializeExpressionIfNecessary()
        return super.getExpression()
    }

    /**
     * Initialize the [Expression] of this [ExpressionStmt] instance by invoking the concrete implementation of
     * [buildConverterCallExpression] in subclasses
     */
    private fun initializeExpressionIfNecessary() {
        if (expressionInitialized)
            return

        expression = StaticJavaParser.parseExpression(buildConverterCallExpression(avroObjectName, domainObjectName))
        expressionInitialized = true
    }

    /**
     * Method for implementers to return the string representation of the expression that reifies an invocation of this
     * [AbstractNestedConverterCall]
     */
    protected abstract fun buildConverterCallExpression(avroObjectName: String, domainObjectName: String) : String

    /**
     * Version of [ExpressionStmt.replace] that fulfills the contract of [ExpressionStmt] in accordance with our version
     * of [getExpression]
     */
    override fun replace(node: Node?, replacementNode: Node?) : Boolean {
        initializeExpressionIfNecessary()
        return super.replace(node, replacementNode)
    }

    /**
     * Check if this nested converter call is valid
     */
    fun checkValidity() {
        if (!converterExists)
            throw ConverterDoesNotExistException(converterName)

        try {
            NestedConverterCallchains.tryAddCall(caller, this)
        } catch (ex: NestedConverterCallchains.LeadsToDirectRecursionException) {
            throw InvalidNestedConverterCallException(ex.message!!, ex)
        } catch (ex: NestedConverterCallchains.LeadsToRecursionException) {
            throw InvalidNestedConverterCallException(ex.message!!, ex)
        }
    }
}

/**
 * Exception to notify that a required [AbstractNestedConverterCall] does not exist.
 *
 * @author [Florian Rademacher](mailto:florian.rademacher@fh-dortmund.de)
 */
private class ConverterDoesNotExistException(converterName: String)
    : InvalidNestedConverterCallException("Required converter $converterName was not generated")

/**
 * Helper object to manage chains of [AbstractNestedConverterCall]s and detect recursive chains.
 *
 * @author [Florian Rademacher](mailto:florian.rademacher@fh-dortmund.de)
 */
private object NestedConverterCallchains {
    private val callchains = mutableMapOf<String, MutableList<String>>()

    /**
     * Try to add a call from the caller, i.e., an existing [AbstractConverter], to a required callee, i.e., a possibly
     * yet non-existent [AbstractNestedConverterCall]. The method throws a [LeadsToRecursionException] when the call
     * would result in a recursion between [caller] and [callee].
     */
    fun tryAddCall(caller: AbstractConverter<AbstractNestedConverterCall, AbstractConverter<*, *>>,
        callee: AbstractNestedConverterCall) {
        val callerIdentifier = caller.identifier
        val calleeIdentifier = callee.identifier
        checkForRecursion(callerIdentifier, calleeIdentifier)

        if (callerIdentifier !in callchains)
            callchains[callerIdentifier] = mutableListOf()
        callchains[callerIdentifier]!!.add(calleeIdentifier)
    }

    /**
     * Check for recursion when the [caller] would call the [callee] and throw a [LeadsToRecursionException] when a
     * recursion would occur
     */
    private fun checkForRecursion(caller: String, callee: String) {
        if (caller == callee)
            throw LeadsToDirectRecursionException(caller, callee)

        val calleeChain = callchains[callee] ?: return
        if (caller in calleeChain)
            throw LeadsToRecursionException(caller, callee)
    }

    /**
     * Exception to notify that a call would lead to a direct recursion
     */
    class LeadsToDirectRecursionException(caller: String, callee: String)
        : LeadsToRecursionException("Invocation of $callee by $caller is directly recursive and would result in an " +
            "infinite execution of $caller")

    /**
     * Exception to notify that a call would lead to an indirect recursion
     */
    open class LeadsToRecursionException(message: String) : Exception(message) {
        constructor(caller: String, callee: String) : this("Invocation of $callee by $caller is recursive and would " +
            "result in an infinite execution of $caller")
    }

    /**
     * Reset the object's state
     */
    fun reset() = callchains.clear()
}

/**
 * Wrapper [Exception] for all exceptions besides [ConverterDoesNotExistException] thrown by
 * [AbstractNestedConverterCall.checkValidity].
 *
 * @author [Florian Rademacher](mailto:florian.rademacher@fh-dortmund.de)
 */
private open class InvalidNestedConverterCallException : Exception {
    constructor(message: String) : super(message)
    constructor(message: String, cause: Throwable) : super(message, cause)
}

/**
 * Abstract super class for all [AbstractConverter]s in a given [clazz] that convert a domain object of type
 * [complexType] to a corresponding Avro object whose structure originates from an Avro schema annotated on the given
 * [rootStructure].
 *
 * @author [Florian Rademacher](mailto:florian.rademacher@fh-dortmund.de)
 */
private abstract class AbstractAvroConverter(
    clazz: ClassOrInterfaceDeclaration,
    complexType: IntermediateComplexType,
    rootStructure: IntermediateDataStructure
) : AbstractConverter<NestedAvroConverterCall, AbstractAvroConverter>(
    clazz,
    complexType,
    rootStructure,
    ::deriveAvroConverterName,
    DOMAIN_OBJECT,
    AVRO_OBJECT
) {
    private val avroObjectInitializationStatements = mutableListOf<Statement>()

    /**
     * Get the name of the converter's return type and all related imports. The default return type is the [avroType]
     * returned by [findAvroType]. Since Avro types have the same names as the domain types from whose schemas they were
     * generated, we must use the fully-qualified name of the Avro type as return type and thus don't need additional
     * imports.
     */
    override fun getReturnTypeNameAndImports() = avroType.fullyQualifiedName.get() to emptySet<String>()

    /**
     * Get the names of the converter's parameter type and all related imports. The default parameter type is the domain
     * type returned by [findDomainType]. Since [getReturnTypeNameAndImports] returns the fully-qualified name of the
     * Avro type that corresponds to the domain type, we import the domain type and use its simple name as parameter
     * type.
     */
    override fun getParameterTypeNameAndImports()
        = domainType.nameAsString to setOf(domainType.fullyQualifiedName.get())

    /*
     * Register a [Statement] to initialize the Avro object
     */
    fun registerAvroObjectInitializationStatement(statement: Statement) {
        avroObjectInitializationStatements.add(statement)
    }

    /**
     * Default implementation of [generateBody] that serializes collected [avroObjectInitializationStatements]
     */
    override fun generateBody() {
        /*
         * Gather valid initialization statements and add comments for invalid statements (and thus missing Avro setter
         * invocations)
         */
        val validStatements = mutableListOf<Statement>()
        avroObjectInitializationStatements.forEach {
            try {
                it.checkValidity()
                validStatements.add(it)
            } catch(ex: InvalidNestedConverterCallException) {
                appendBlockComment("\t-${ex.message!!}", "Missing Avro setter invocations:")
            }
        }

        /* Get the name of an instantiable version of the receiver object's type as well as corresponding imports */
        val (instantiableReceiverObjectType, instantiableObjectTypeImports) = getInstantiableReceiverObjectType()
        instantiableObjectTypeImports.forEach { addRelocatableImport(it, ImportTargetElementType.METHOD_BODY) }

        /**
         * Generate the actual body
         */
        if (validStatements.isNotEmpty()) {
            appendStatement("var $receiverObjectName = new $instantiableReceiverObjectType();")
            val body = body.get()
            wrapAvroObjectInitializationStatements(validStatements).statements.forEach { body.statements.add(it) }
            appendStatement("return $receiverObjectName;")
        } else
            appendStatement("return new $instantiableReceiverObjectType();")
    }

    /**
     * Determine the instantiable version of the receiver object's type as well as corresponding imports. For example,
     * the instantiable type for a receiver object of type "java.util.List" could be "java.util.ArrayList".
     */
    private fun getInstantiableReceiverObjectType() : Pair<String, Set<String>> {
        val avroTypeFullyQualifiedName = (avroType as ClassOrInterfaceDeclaration).fullyQualifiedName.get()
        return if (complexType is IntermediateCollectionType) {
                val instantiableTypeName = complexType.instantiableClassName
                val simpleTypeName = instantiableTypeName.substringAfterLast(".")
                "$simpleTypeName<$avroTypeFullyQualifiedName>" to setOf(instantiableTypeName)
            } else
                avroTypeFullyQualifiedName to emptySet()
    }

    /**
     * Wrap a list of Avro object initialization statements into a [BlockStmt]. This method enables implementers to
     * wrap the statements into another statement, e.g., a for-each-loop. Note that the [BlockStmt] itself will not be
     * added to the body of this [AbstractAvroConverter]. Instead, all statements clustered by the [BlockStmt] will be
     * added to this [AbstractAvroConverter]'s body and thus accompany possibly existing statements.
     */
    protected open fun wrapAvroObjectInitializationStatements(statements: List<Statement>) : BlockStmt {
        val statementContainer = BlockStmt()
        statementContainer.statements.addAll(statements)
        return statementContainer
    }
}

/**
 * Representation of a nested call to an [AbstractAvroConverter] performed by an executing [AbstractConverter].
 * [AbstractAvroConverter]s are executed as arguments to the parameters of Avro setters. Consequently, their call
 * expression consists of the invocation of the converter on the domain getter, whose return value shall be
 * converted, and the invocation of the Avro setter with the converter call as argument.
 *
 * @author [Florian Rademacher](mailto:florian.rademacher@fh-dortmund.de)
 */
private class NestedAvroConverterCall(
    caller: AbstractAvroConverter,
    complexType: IntermediateComplexType,
    private val avroSetter: MethodDeclaration,
    private val domainGetterCall: String,
    convertedDomainTypeName: String,
    avroObjectName: String = AVRO_OBJECT,
    domainObjectName: String = DOMAIN_OBJECT
) : AbstractNestedConverterCall(
    caller,
    convertedDomainTypeName,
    avroObjectName,
    domainObjectName,
    complexType,
    ::deriveAvroConverterName
) {
    constructor(
        caller: AbstractAvroConverter,
        complexType: IntermediateComplexType,
        avroSetter: MethodDeclaration,
        domainGetter: MethodDeclaration,
        avroObjectName: String = AVRO_OBJECT,
        domainObjectName: String = DOMAIN_OBJECT
    ) : this(
        caller,
        complexType,
        avroSetter,
        "$domainObjectName.${domainGetter.nameAsString}()",
        domainGetter.typeAsString,
        avroObjectName,
        domainObjectName
    )

    /**
     * Build the expression that calls the nested converter which is the invocation of the Avro setter on the Avro
     * object with a nested invocation of the converter on the domain getter
     */
    override fun buildConverterCallExpression(avroObjectName: String, domainObjectName: String): String {
        val converterCall = "$converterName($domainGetterCall)"
        return "$avroObjectName.${avroSetter.nameAsString}($converterCall)"
    }
}

/**
 * Derive the name of an [AbstractAvroConverter] from the given [complexType].
 *
 * @author [Florian Rademacher](mailto:florian.rademacher@fh-dortmund.de)
 */
private fun deriveAvroConverterName(complexType: IntermediateComplexType)
    = AVRO_CONVERTER_PREFIX + complexType.name.capitalize()

/**
 * Calculate the identifier for an [AbstractConverter] from its [converterClass], [converterName], and
 * [parameterTypeName].
 *
 * @author [Florian Rademacher](mailto:florian.rademacher@fh-dortmund.de)
 */
private fun calculateConverterIdentifier(converterClass: ClassOrInterfaceDeclaration, converterName: String,
    parameterTypeName: String)
    = "${converterClass.fullyQualifiedName.get()}.$converterName($parameterTypeName)"

/**
 * Check whether this [Statement] is valid to be used in the bodies of [AbstractConverter]s.
 *
 * @author [Florian Rademacher](mailto:florian.rademacher@fh-dortmund.de)
 */
private fun Statement.checkValidity() = (this as? AbstractNestedConverterCall)?.checkValidity() ?: Unit

/**
 * Append the given [commentString] to the block comment of this [Node], preceding it with the [introduction] string in
 * case the [introduction] string is not empty and the block comment does not start with the [introduction] string.
 *
 * @author [Florian Rademacher](mailto:florian.rademacher@fh-dortmund.de)
 */
private fun Node.appendBlockComment(commentString: String, introduction: String = "") {
    if (!comment.isPresent)
        setBlockComment("$introduction\n$commentString")
    else {
        var extendedComment = comment.get().content

        if (extendedComment.isNotEmpty())
            extendedComment += "\n"
        else if (introduction.isNotEmpty())
            extendedComment += "$introduction\n"

        extendedComment += commentString
        setBlockComment(extendedComment)
    }
}

/**
 * Abstract super class for all [MethodDeclaration]s in a given [clazz] that convert an Avro object to a corresponding
 * domain object of type [complexType].
 *
 * @author [Florian Rademacher](mailto:florian.rademacher@fh-dortmund.de)
 */
private abstract class AbstractDomainConverter(
    clazz: ClassOrInterfaceDeclaration,
    complexType: IntermediateComplexType,
    rootStructure: IntermediateDataStructure
) : AbstractConverter<NestedDomainConverterCall, AbstractDomainConverter>(clazz, complexType, rootStructure, ::deriveDomainConverterName,
    AVRO_OBJECT, DOMAIN_OBJECT) {
    private var fallbackConstructor: ConstructorDeclaration? = null
    private lateinit var fieldInitializingConstructors: Map<ConstructorDeclaration, List<IntermediateDataField>>
    private val fieldInitializingConstructorsArguments
        = mutableMapOf<ConstructorDeclaration, List<StatementAndImports>>()

    /**
     * Get the names of the [AbstractDomainConverter]'s return type and all imports that the return type requires. The
     * default return type for an [AbstractDomainConverter] is the domain type returned by [findDomainType]. Since
     * [getParameterTypeNameAndImports] returns the fully-qualified name of the Avro type that corresponds to the domain
     * type (and thus has the same simple name as the domain type), we import the domain type and use its simple name as
     * return type. This behavior is consistent with [AbstractAvroConverter] so that domain types always get imported to
     * use their simple names for type references, while Avro types don't get imported and their references are always
     * fully qualified.
     */
    override fun getReturnTypeNameAndImports() = domainType.nameAsString to setOf(domainType.fullyQualifiedName.get())

    /**
     * Get the names of the [AbstractDomainConverter]'s parameter type and all imports that the parameter type requires.
     * The default parameter type for an [AbstractDomainConverter] is the Avro type returned by [findAvroType]. Since
     * Avro types have the same names as the domain types from whose schemas they were generated, we use the fully
     * qualified name of the Avro type as parameter type and thus don't need additional import statements.
     */
    override fun getParameterTypeNameAndImports() = avroType.fullyQualifiedName.get() to emptySet<String>()

    /**
     * Calculate the converter's identifier
     */
    // TODO: Remove?
    //override fun calculateIdentifier() = calculateConverterIdentifier(clazz, nameAsString,
    //    parameters.first().typeAsString)

    protected fun findDomainTypeConstructors(
        searchDomainType: TypeDeclaration<*> = domainType,
        relevantFields: List<IntermediateDataField>,
        searchAvroType: TypeDeclaration<*> = avroType,
        constructorArgumentValueSource: String = sourceObjectName
    ) {
        fallbackConstructor = (searchDomainType as ClassOrInterfaceDeclaration).findEmptyPublicConstructor()
        fieldInitializingConstructors = findDataFieldConstructors(searchDomainType, relevantFields)

        for ((constructor, initializedFields) in fieldInitializingConstructors) {
            val statementsAndImports = constructor.buildFieldInitializingArgumentStatements(
                    searchAvroType,
                    initializedFields,
                    constructorArgumentValueSource
                )
            if (statementsAndImports.isNotEmpty())
                fieldInitializingConstructorsArguments[constructor] = statementsAndImports
        }
    }

    private fun ClassOrInterfaceDeclaration.findEmptyPublicConstructor()
        = constructors.firstOrNull { it.hasModifier(Modifier.Keyword.PUBLIC) && it.parameters.isEmpty() }

    private fun findDataFieldConstructors(searchDomainType: TypeDeclaration<*>,
        relevantFields: List<IntermediateDataField>) : Map<ConstructorDeclaration, List<IntermediateDataField>> {
        val relevantFieldsByName = relevantFields.associateBy { it.name }
        val domainClass = searchDomainType as ClassOrInterfaceDeclaration
        val relevantDomainAttributes = domainClass.attributes
            .filter { it.nameAsString in relevantFieldsByName }
            .associate { it.nameAsString to it.type }

        val constructors = mutableMapOf<ConstructorDeclaration, List<IntermediateDataField>>()
        domainClass.constructors.forEach {
            val initializedFields = it.initializedFields(relevantFieldsByName, relevantDomainAttributes)
            if (initializedFields.isNotEmpty())
                constructors[it] = initializedFields
        }
        return constructors
    }

    private fun ConstructorDeclaration.initializedFields(relevantFields: Map<String, IntermediateDataField>,
        correspondingRelevantAttributes: Map<String, Type>) : List<IntermediateDataField> {
        val initializedFields = mutableListOf<IntermediateDataField>()

        for (parameter in parameters) {
            val initializedAttributeType = correspondingRelevantAttributes[parameter.nameAsString]
            if (initializedAttributeType == null || parameter.type != initializedAttributeType)
                return emptyList()

            initializedFields.add(relevantFields[parameter.nameAsString]!!)
        }

        return initializedFields
    }

    private fun ConstructorDeclaration.buildFieldInitializingArgumentStatements(
        searchAvroType: TypeDeclaration<*>,
        initializedFields: List<IntermediateDataField>,
        sourceObjectName: String
    ) : List<StatementAndImports> {
        val statementsAndImports = mutableListOf<StatementAndImports>()

        for (field in initializedFields) {
            val (avroGetter, avroGetterModelReturnType) = try {
                    field.findAvroGetter(searchAvroType)
                } catch(ex: IllegalStateException) {
                    return emptyList()
                }

            val (domainConstructorArgumentStatement, domainConstructorArgumentStatementImports)
                = buildFieldInitializingArgumentStatement(avroGetter, avroGetterModelReturnType, field,
                    sourceObjectName)

            statementsAndImports.add(domainConstructorArgumentStatement to domainConstructorArgumentStatementImports)
        }

        return statementsAndImports
    }

    /**
     * Search the getter method, whose parameter type corresponds to the Java type of this [IntermediateDataField], in
     * the [avroType]. The method returns the getter's [MethodDeclaration] and the *resolved* [IntermediateType] of this
     * [IntermediateDataField].
     */
    private fun IntermediateDataField.findAvroGetter(searchAvroType: TypeDeclaration<*>)
        : Pair<MethodDeclaration, IntermediateType> {
        val avroClass = searchAvroType as ClassOrInterfaceDeclaration
        val getterAndType = avroClass.findAvroGetter(rootStructure, this)
        if (getterAndType == null) {
            val avroClassName = avroClass.fullyQualifiedName.get()
            val rootStructureName = rootStructure.qualifiedName
            val definingComplexTypeName = if (dataStructure != null)
                    dataStructure.qualifiedName
                else
                    collectionType.qualifiedName
            throw IllegalStateException("Avro class $avroClassName compiled from schema of modeled structure " +
                "$rootStructureName does not comprise a getter for field $name of type ${type.name} defined in " +
                "complex type $definingComplexTypeName")
        }

        return getterAndType
    }

    protected fun buildFieldInitializingArgumentStatement(
        avroGetter: MethodDeclaration,
        avroGetterModelReturnType: IntermediateType,
        initializedField: IntermediateDataField,
        sourceObjectName: String
    ) = when {
            avroGetterModelReturnType is IntermediateCollectionType &&
                avroGetterModelReturnType.isPrimitiveCollection ->
                fieldInitializingArgumentStatementForPrimitiveCollection(avroGetter, avroGetterModelReturnType,
                    sourceObjectName)

            avroGetterModelReturnType is IntermediateComplexType ->
                fieldInitializingArgumentStatementForComplexType(avroGetter, avroGetterModelReturnType,
                    sourceObjectName)

            /*else -> throw IllegalArgumentException("Error while building call statement for Avro setter " +
                "${avroSetter.nameAsString}: The setter's modeled parameter type " +
                "${avroSetterParameterModelType.name} is not supported")*/

            else -> fieldInitializingArgumentStatementWithDirectAvroGetterCall(avroGetter, initializedField,
                sourceObjectName)
        }

    private fun fieldInitializingArgumentStatementForPrimitiveCollection(
        avroGetter: MethodDeclaration,
        avroGetterModelReturnType: IntermediateCollectionType,
        sourceObjectName: String
    ) : Pair<Statement, Set<String>> {
        val (itemConversionExpression, itemConversionExpressionImports)
            = avroGetterModelReturnType.getExpressionForPrimitiveCollectionItemConversion(
                    avroGetter.type as ClassOrInterfaceType,
                    DOMAIN_DATE_TYPE_CONVERTER_FUNCTION_REFERENCE,
                    DOMAIN_DATE_TYPE_CONVERTER_IMPORTS
                )

        val domainConstructorArgumentExpression = if (itemConversionExpression.isNotEmpty())
                "$sourceObjectName.${avroGetter.nameAsString}().$itemConversionExpression"
            else
                "$sourceObjectName.${avroGetter.nameAsString}()"

        val domainConstructorArgumentStatement = ExpressionStmt()
        domainConstructorArgumentStatement.expression = StaticJavaParser
            .parseExpression(domainConstructorArgumentExpression)
        return domainConstructorArgumentStatement to itemConversionExpressionImports
    }

    private fun fieldInitializingArgumentStatementForComplexType(
        avroGetter: MethodDeclaration,
        avroGetterModelReturnType: IntermediateComplexType,
        sourceObjectName: String
    ) : Pair<Statement, Set<String>> {
        require(
            avroGetterModelReturnType !is IntermediateCollectionType ||
            !avroGetterModelReturnType.isPrimitiveCollection
        ) {
            "Function does not support the creation of statements for domain constructor arguments from modeled " +
            "primitive collections like + ${avroGetterModelReturnType.qualifiedName}"
        }

        return NestedDomainConverterCall(this, avroGetterModelReturnType, avroGetter, sourceObjectName) to emptySet()
    }

    private fun fieldInitializingArgumentStatementWithDirectAvroGetterCall(
        avroGetter: MethodDeclaration,
        initializedField: IntermediateDataField,
        sourceObjectName: String
    ) : Pair<Statement, Set<String>> {
        var domainConstructorArgumentExpression = "$sourceObjectName.${avroGetter.nameAsString}()"
        val imports = mutableSetOf<String>()

        if (initializedField.originalType.name == PrimitiveTypeConstants.DATE.literal) {
            val fullyQualifiedJavaDateType = initializedField.type.getTypeMapping()!!.getMappedTypeFullyQualifiedName()
            if (fullyQualifiedJavaDateType == DOMAIN_DATE_TYPE && avroGetter.typeAsString == AVRO_DATE_TYPE) {
                domainConstructorArgumentExpression = DOMAIN_DATE_TYPE_STATIC_CONVERTER +
                    "($domainConstructorArgumentExpression)"
                imports.add(fullyQualifiedJavaDateType)
            }
        }

        val domainConstructorArgumentStatement = ExpressionStmt()
        domainConstructorArgumentStatement.expression = StaticJavaParser
            .parseExpression(domainConstructorArgumentExpression)
        return domainConstructorArgumentStatement to imports
    }

    protected fun prepareConverterForDomainConstructorCall() : String? {
        val applicableConstructorAndArguments = getInitializingConstructorAndArguments()
        if (applicableConstructorAndArguments == null) {
            appendStatement("return null;")
            setBlockComment("Domain converter returns null because ${domainType.fullyQualifiedName.get()} neither " +
                "has constructors compatible to the getters in ${avroType.fullyQualifiedName.get()} nor has it a " +
                "default constructor")
            return null
        }

        val (constructor, arguments, imports) = applicableConstructorAndArguments
        imports.forEach { addRelocatableImport(it, ImportTargetElementType.METHOD_BODY) }
        val constructorParameters = arguments.joinToString(", ") { it.toString().removeSuffix(";") }
        return "new ${constructor.nameAsString}($constructorParameters)"
    }

    private fun getInitializingConstructorAndArguments() : ConstructorInvocationInformation? {
        val fieldInitializingConstructorsByCoverage = fieldInitializingConstructors.entries
            .sortedByDescending { (_, initializedFields) -> initializedFields.size }
            .map { it.key }

        fieldInitializingConstructorsByCoverage.forEach {
            val arguments = fieldInitializingConstructorsArguments[it]
            val allArgumentsValid = arguments?.all { it.first.isValid() } ?: false
            if (allArgumentsValid)
                return ConstructorInvocationInformation(it, arguments!!)
        }

        return if (fallbackConstructor != null) {
                setBlockComment("Domain converter invokes default constructor because there are no constructors in " +
                    "${domainType.fullyQualifiedName.get()} with parameters being compatible to the getters in " +
                    avroType.fullyQualifiedName.get())
                ConstructorInvocationInformation(fallbackConstructor!!)
            } else
                null
    }

    private class ConstructorInvocationInformation(val constructor: ConstructorDeclaration,
        statementsAndImports: List<StatementAndImports> = emptyList()
    ) {
        val statements = statementsAndImports.map { it.first }.toList()
        val imports = statementsAndImports.map { it.second }.flatten().toSet()

        operator fun component1() = constructor
        operator fun component2() = statements
        operator fun component3() = imports
    }
}

/**
 * Representation of a nested call to an [AbstractDomainConverter] performed by an executing [AbstractConverter].
 * [AbstractDomainConverter]s are executed as arguments to the parameters of domain class' constructors. Consequently,
 * their call expression is an immediate invocation of the converter on the Avro getter whose return value shall be
 * converted.
 *
 * @author [Florian Rademacher](mailto:florian.rademacher@fh-dortmund.de)
 */
private class NestedDomainConverterCall(
    caller: AbstractDomainConverter,
    complexType: IntermediateComplexType,
    private val avroGetterCall: String,
    converterAvroTypeName: String,
    avroObjectName: String = AVRO_OBJECT,
    domainObjectName: String = DOMAIN_OBJECT
) : AbstractNestedConverterCall(
    caller,
    converterAvroTypeName,
    avroObjectName,
    domainObjectName,
    complexType,
    ::deriveDomainConverterName
) {
    constructor(
        caller: AbstractDomainConverter,
        complexType: IntermediateComplexType,
        avroGetter: MethodDeclaration,
        avroObjectName: String = AVRO_OBJECT,
        domainObjectName: String = DOMAIN_OBJECT
    ) : this(
        caller,
        complexType,
        "$avroObjectName.${avroGetter.nameAsString}()",
        avroGetter.typeAsString,
        avroObjectName,
        domainObjectName
    )

    /**
     * Build the expression that calls the nested converter which is the invocation of the converter on the Avro object
     * and its getter
     */
    override fun buildConverterCallExpression(avroObjectName: String, domainObjectName: String)
        = "$converterName($avroGetterCall)"
}

/**
 * Derive the name of an [AbstractDomainConverter] from the given [complexType].
 *
 * @author [Florian Rademacher](mailto:florian.rademacher@fh-dortmund.de)
 */
private fun deriveDomainConverterName(complexType: IntermediateComplexType)
    = DOMAIN_CONVERTER_PREFIX + complexType.name.capitalize()

/**
 * Exception to notify problems with the creation of [AbstractConverter]s.
 *
 * @author [Florian Rademacher](mailto:florian.rademacher@fh-dortmund.de)
 */
private open class ConverterCreationException(message: String) : Exception(message)

/**
 * Specialized [ConverterCreationException] to notify that the [TypeDeclaration] generated from an
 * [IntermediateComplexType] could not be found.
 *
 * @author [Florian Rademacher](mailto:florian.rademacher@fh-dortmund.de)
 */
private class DomainTypeNotFoundException(complexType: IntermediateComplexType)
    : ConverterCreationException("Domain type for modeled complex type ${complexType.qualifiedName} was not generated")

/**
 * Specialized [ConverterCreationException] to notify that the [TypeDeclaration] generated from the Avro schema of an
 * [IntermediateDataStructure], i.e., the schema's root structure, and corresponding to the [TypeDeclaration] of a
 * domain type could not be found.
 *
 * @author [Florian Rademacher](mailto:florian.rademacher@fh-dortmund.de)
 */
private class AvroTypeNotFoundException(rootStructure: IntermediateDataStructure, domainType: TypeDeclaration<*>)
    : ConverterCreationException("Avro type corresponding to generated domain type " +
        "${domainType.fullyQualifiedName.get()} was not compiled from the Avro schema assigned to the modeled root " +
        "structure ${rootStructure.qualifiedName}")

/**
 * [AbstractAvroConverter] realization to translate [IntermediateDataStructure]s into corresponding Avro objects. The
 * basic strategy is to identify each setter of the Avro object whose parameter type either immediately corresponds to
 * the return type of a domain getter or, otherwise, register the need for an [AbstractNestedConverterCall] to convert
 * the getter's return type into the setter's parameter type. In case the converter invoked by the
 * [AbstractNestedConverterCall] got created during converter creation, it is manifested as part of this
 * [StructureAvroConverter] upon the generation of its body. The data fields of the given [structure] prescribe the
 * Avro setters and domain getters to search for. Furthermore, fields' names act as heuristic to match an Avro setter
 * with a domain getter because types alone are not sufficient in this case as they not necessarily contribute to the
 * semantics of the field. For example, two fields "firstname" and "zipCode" may both be of type String, yet they have
 * a different meaning in the application.
 *
 * @author [Florian Rademacher](mailto:florian.rademacher@fh-dortmund.de)
 */
private class StructureAvroConverter(
    clazz: ClassOrInterfaceDeclaration,
    private val structure: IntermediateDataStructure,
    rootStructure: IntermediateDataStructure
) : AbstractAvroConverter(clazz, structure, rootStructure) {
    /**
     * Derive body information
     */
    override fun deriveBodyInformation() {
        for (field in structure.avroRelevantFields()) {
            val domainGetter = try {
                    field.findDomainGetter()
                } catch(ex: IllegalStateException) {
                    appendBlockComment("\t-${ex.message!!}", "Missing Avro setter invocations:")
                    continue
                }

            val (avroSetter, avroSetterModelParameterType) = try {
                    field.findAvroSetter()
                } catch(ex: IllegalStateException) {
                    appendBlockComment("\t-${ex.message!!}", "Missing Avro setter invocations:")
                    continue
                }

            val (avroSetterCallStatement, avroSetterCallStatementImports) = buildAvroSetterCallStatement(
                    avroSetter,
                    avroSetterModelParameterType,
                    domainGetter
                )

            registerAvroObjectInitializationStatement(avroSetterCallStatement)
            avroSetterCallStatementImports.forEach { addRelocatableImport(it, ImportTargetElementType.METHOD_BODY) }
        }
    }

    /**
     * Search the getter method, whose parameter corresponds to the Java type of this [IntermediateDataField], in the
     * [domainType].
     */
    private fun IntermediateDataField.findDomainGetter() : MethodDeclaration {
        val domainClass = domainType as ClassOrInterfaceDeclaration
        val getter = domainClass.getExistingGetter(this)
        if (getter == null) {
            val domainClassName = domainClass.fullyQualifiedName.get()
            throw IllegalStateException("Generated domain class $domainClassName does not comprise a getter for " +
                "field $name of type ${type.name} defined in modeled structure ${structure.qualifiedName}")
        }

        return getter
    }

    /**
     * Search the setter method, whose return type corresponds to the Java type of this [IntermediateDataField], in the
     * [avroType]. The method returns the setter's [MethodDeclaration] and the *resolved* [IntermediateType] of this
     * [IntermediateDataField].
     */
    private fun IntermediateDataField.findAvroSetter() : Pair<MethodDeclaration, IntermediateType> {
        val avroClass = avroType as ClassOrInterfaceDeclaration
        val setterAndType = avroClass.findAvroSetter(rootStructure, this)
        if (setterAndType == null) {
            val avroClassName = avroClass.fullyQualifiedName.get()
            val rootStructureName = rootStructure.qualifiedName
            throw IllegalStateException("Avro class $avroClassName compiled from schema of modeled structure " +
                "$rootStructureName does not comprise a setter for field $name of type ${type.name} defined in " +
                "modeled structure ${structure.qualifiedName}")
        }

        return setterAndType
    }

    /**
     * Build the statement to invoke the given [avroSetter]. The statement clusters the invocation of the [domainGetter]
     * as a parameter for the [avroSetter] which might require the nested invocation of another Avro setter. The method
     * returns the [Statement] together with a set of imports possibly required to execute the [Statement].
     */
    private fun buildAvroSetterCallStatement(
        avroSetter: MethodDeclaration,
        avroSetterModelParameterType: IntermediateType,
        domainGetter: MethodDeclaration
    ) = when {
            avroSetterModelParameterType is IntermediateCollectionType &&
                avroSetterModelParameterType.isPrimitiveCollection ->
                avroSetterCallStatementForPrimitiveCollection(avroSetter, avroSetterModelParameterType, domainGetter)

            avroSetterModelParameterType is IntermediateComplexType ->
                avroSetterCallStatementForComplexType(avroSetter, avroSetterModelParameterType, domainGetter)

            /*else -> throw IllegalArgumentException("Error while building call statement for Avro setter " +
                "${avroSetter.nameAsString}: The setter's modeled parameter type " +
                "${avroSetterModelParameterType.name} is not supported")*/

            else -> avroSetterCallStatementWithDirectDomainGetterCall(avroSetter, domainGetter)
        }

    /**
     * Build the statement to invoke the given [avroSetter] whose parameter type corresponds to an unstructured
     * primitive [IntermediateCollectionType] in the input LEMMA model. The method returns the [Statement] together with
     * a set of imports possibly required to execute the [Statement].
     */
    private fun avroSetterCallStatementForPrimitiveCollection(
        avroSetter: MethodDeclaration,
        avroSetterModelParameterType: IntermediateCollectionType,
        domainGetter: MethodDeclaration
    ) : Pair<Statement, Set<String>> {
        val (itemConversionExpression, itemConversionExpressionImports)
            = avroSetterModelParameterType.getExpressionForPrimitiveCollectionItemConversion(
                    avroSetter.parameters.first().type as ClassOrInterfaceType,
                    AVRO_DATE_TYPE_CONVERTER_FUNCTION_REFERENCE,
                    AVRO_DATE_TYPE_CONVERTER_IMPORTS
                )

        val domainGetterExpression = if (itemConversionExpression.isNotEmpty())
                "$sourceObjectName.${domainGetter.nameAsString}().$itemConversionExpression"
            else
                "$sourceObjectName.${domainGetter.nameAsString}()"
        val avroSetterStatement = "$receiverObjectName.${avroSetter.nameAsString}($domainGetterExpression);"

        return StaticJavaParser.parseStatement(avroSetterStatement) to itemConversionExpressionImports
    }

    /**
     * Build the statement to invoke the given [avroSetter] whose parameter type corresponds to an
     * [IntermediateComplexType] that is not an unstructured primitive [IntermediateCollectionType]. The method returns
     * the [Statement] together with a set of imports possibly required to execute the [Statement].
     */
    private fun avroSetterCallStatementForComplexType(
        avroSetter: MethodDeclaration,
        avroSetterModelParameterType: IntermediateComplexType,
        domainGetter: MethodDeclaration
    ) : Pair<Statement, Set<String>> {
        require(
            avroSetterModelParameterType !is IntermediateCollectionType ||
            !avroSetterModelParameterType.isPrimitiveCollection
        ) {
            "Function does not support Avro call statement creation for modeled primitive collections like " +
            avroSetterModelParameterType.qualifiedName
        }

        return NestedAvroConverterCall(this, avroSetterModelParameterType, avroSetter, domainGetter) to emptySet()
    }

    /**
     * Build the statement to invoke the given [avroSetter] with the call to the domain getter as the setter's argument.
     * The method returns the [Statement] together with a set of imports possibly required to execute the [Statement].
     */
    private fun avroSetterCallStatementWithDirectDomainGetterCall(
        avroSetter: MethodDeclaration,
        domainGetter: MethodDeclaration
    ) : Pair<Statement, Set<String>> {
        var domainGetterCall = "$sourceObjectName.${domainGetter.nameAsString}()"
        val avroSetterForDate = avroSetter.parameters.first().typeAsString == AVRO_DATE_TYPE
        val domainGetterAlreadyReturnsAvroDate = domainGetter.typeAsString == AVRO_DATE_TYPE
        if (avroSetterForDate && !domainGetterAlreadyReturnsAvroDate)
            domainGetterCall += ".$AVRO_DATE_TYPE_CONVERTER_METHOD()"

        val avroSetterCall = "$receiverObjectName.${avroSetter.nameAsString}($domainGetterCall);"
        return StaticJavaParser.parseStatement(avroSetterCall) to emptySet()
    }
}

/**
 * Get the fields being relevant to Avro conversion from this [IntermediateDataStructure]. Note that the definition of
 * "relevance" in this case must conform to the Eclipse plugin with which we convert [IntermediateDataStructure]s to
 * Avro schemas.
 *
 * @author [Florian Rademacher](mailto:florian.rademacher@fh-dortmund.de)
 */
private fun IntermediateDataStructure.avroRelevantFields() = dataFields.filter { !it.isHidden }

/**
 * Find a setter in this [ClassOrInterfaceDeclaration] that maps to the given [field]'s Avro type, which was possibly
 * compiled from the schema of the given [rootStructure]. The result of this function is the [Pair] of the setter's
 * [MethodDeclaration] and the *resolved* [IntermediateType] of the [field], or null if the invocation of
 * [findAvroMethod] itself failed.
 *
 * @author [Florian Rademacher](mailto:florian.rademacher@fh-dortmund.de)
 */
private fun ClassOrInterfaceDeclaration.findAvroSetter(rootStructure: IntermediateDataStructure,
    field: IntermediateDataField)
    = findAvroMethod(rootStructure, field, ClassOrInterfaceDeclaration::getExistingSetter)

/**
 * Find a method in this [ClassOrInterfaceDeclaration] that deals with the Avro type of the given [field]. The type may
 * have been compiled from the Avro schema of the given [rootStructure]. The [search] function specifies what "dealing
 * with the Avro type actually means". For instance, the searched method may return a value of the Avro type or specify
 * a parameter of the Avro type.
 *
 * The result of this function is the [Pair] of the found [MethodDeclaration] and the *resolved* [IntermediateType] of
 * the [field], or null in case not method was found by [search] or resolving the [IntermediateType] wasn't successful.
 *
 * @author [Florian Rademacher](mailto:florian.rademacher@fh-dortmund.de)
 */
private fun ClassOrInterfaceDeclaration.findAvroMethod(
    rootStructure: IntermediateDataStructure,
    field: IntermediateDataField,
    search: ClassOrInterfaceDeclaration.(String, String)->MethodDeclaration?
) : Pair<MethodDeclaration, IntermediateType>? {
    val type = when {
        field.type is IntermediateComplexType -> (field.type as IntermediateComplexType).resolve()
        field.type is IntermediateImportedTechnologySpecificType
            && field.type.kind == IntermediateTypeKind.PRIMITIVE -> field.originalType
        else -> field.type
    }
    val typeMapping = type.getTypeMapping() ?: return null

    val avroTypeNames = type.getCorrespondingAvroTypeNames(typeMapping, rootStructure)
    if (avroTypeNames.isEmpty())
        return null

    val method = avroTypeNames.mapToFirstNonNull { search(field.name, it) }
    return if (method != null)
            method to type
        else
            null
}

/**
 * Get the first non-null result from applying [transform] to the elements of this [Iterable].
 *
 * @author [Florian Rademacher](mailto:florian.rademacher@fh-dortmund.de)
 */
private inline fun <I, T> Iterable<I>.mapToFirstNonNull(transform: (I) -> T?): T? {
    for (element in this) {
        val result = transform(element)
        if (result != null)
            return result
    }

    return null
}

/**
 * Retrieve the fully-qualified Avro type names that correspond to this [IntermediateType].
 *
 * @author [Florian Rademacher](mailto:florian.rademacher@fh-dortmund.de)
 */
private fun IntermediateType.getCorrespondingAvroTypeNames(typeMapping: TypeMappingDescription,
    rootStructure: IntermediateDataStructure)
    = when (this) {
        is IntermediateEnumeration -> getCorrespondingAvroTypeNames(rootStructure)
        is IntermediateDataStructure -> getCorrespondingAvroTypeNames(rootStructure)
        is IntermediateImportedTechnologySpecificType -> getCorrespondingAvroTypeNames(typeMapping)
        is IntermediateCollectionType -> getCorrespondingAvroTypeNames(rootStructure)
        is IntermediatePrimitiveType -> getCorrespondingAvroTypeNames(typeMapping)
        else -> throw IllegalArgumentException("Unsupported type kind ${javaClass.name}")
    }

/**
 * Retrieve the fully-qualified Avro type names that correspond to this [IntermediateEnumeration].
 *
 * @author [Florian Rademacher](mailto:florian.rademacher@fh-dortmund.de)
 */
private fun IntermediateEnumeration.getCorrespondingAvroTypeNames(rootStructure: IntermediateDataStructure)
    : Set<String> {
    val compiledType = AvroConversionTypeManager.getJavaTypeCompiledFromSchemaOfRootStructure(rootStructure, name)
    return if (compiledType != null)
            setOf(compiledType.fullyQualifiedName.get())
        else
            emptySet()
}

/**
 * Retrieve the fully-qualified Avro type names that correspond to this [IntermediateDataStructure].
 *
 * @author [Florian Rademacher](mailto:florian.rademacher@fh-dortmund.de)
 */
private fun IntermediateDataStructure.getCorrespondingAvroTypeNames(rootStructure: IntermediateDataStructure)
    : Set<String> {
    val compiledType = AvroConversionTypeManager.getJavaTypeCompiledFromSchemaOfRootStructure(rootStructure, name)
    return if (compiledType != null)
            setOf(compiledType.fullyQualifiedName.get())
        else
            emptySet()
}

/**
 * Retrieve the fully-qualified Avro type names that correspond to this [IntermediateImportedTechnologySpecificType].
 *
 * @author [Florian Rademacher](mailto:florian.rademacher@fh-dortmund.de)
 */
private fun IntermediateImportedTechnologySpecificType.getCorrespondingAvroTypeNames(
    typeMapping: TypeMappingDescription
) = if (typeMapping.getImports().isNotEmpty())
        // The type mapping for the technology-specific type may specify imports when it is a type from a technology
        // model recognized by the Java Base Generator, e.g., java.util.Date.
        setOf(typeMapping.getMappedTypeFullyQualifiedName())
    else
        setOf(typeMapping.mappedTypeName)

/**
 * Get the fully-qualified name of the mapped type of this [TypeMappingDescription].
 *
 * @author [Florian Rademacher](mailto:florian.rademacher@fh-dortmund.de)
 */
private fun TypeMappingDescription.getMappedTypeFullyQualifiedName()
    = getImports().first {
        val importedClassSimpleName = it.substringAfterLast(".")
        mappedTypeName.startsWith(importedClassSimpleName)
    }

/**
 * Retrieve the fully-qualified Avro type names that correspond to this [IntermediateCollectionType].
 *
 * @author [Florian Rademacher](mailto:florian.rademacher@fh-dortmund.de)
 */
private fun IntermediateCollectionType.getCorrespondingAvroTypeNames(rootStructure: IntermediateDataStructure)
    : Set<String> {
    val typeInfo = typeInfo()
    val typeArgumentName = if (isPrimitiveCollection)
            // Avro always generates fully-qualified names, even for boxed types like "Integer"
            typeInfo.typeArgumentQualifiedName
        else
            // In case the collection type is not primitive, i.e., it contains at least one named data field, search for
            // the type argument as a Java type compiled from the Avro schema of the root structure. This approach is
            // correct because the Eclipse plugin for Avro schema generation maps LEMMA collection types to their own
            // record types which are then compiled by Avro to Java classes.
            AvroConversionTypeManager
                .getJavaTypeCompiledFromSchemaOfRootStructure(rootStructure, name)
                ?.fullyQualifiedName
                ?.get()

    return if (typeArgumentName == "java.util.Date")
            setOf("${typeInfo.collectionTypeQualifiedName}<$AVRO_DATE_TYPE>")
        else if (typeArgumentName != null)
            setOf("${typeInfo.collectionTypeQualifiedName}<$typeArgumentName>")
        else
            emptySet()
}

/**
 * Gather information about this [IntermediateCollectionType].
 *
 * @author [Florian Rademacher](mailto:florian.rademacher@fh-dortmund.de)
 */
private fun IntermediateCollectionType.typeInfo() : CollectionTypeInfo {
    val (itemClassnames, _) = getItemClassnamesAndImports()
    // FIXME: Currently, we do not support collection types which require more than one type argument, e.g., maps
    require(itemClassnames.size == 1) {
        "Modeled collection type $qualifiedName requires more than one Java item class which is currently not " +
        "supported for Avro converter generation"
    }

    val typeMapping = getTypeMapping()!!

    val collectionTypeQualifiedName = typeMapping.getMappedTypeFullyQualifiedName()

    val typeArgumentObjectWrapperMapping = typeArgumentObjectWrapperMapping()
    val typeArgumentQualifiedName = typeArgumentObjectWrapperMapping?.fullyQualifiedMappedTypeName
        ?: typeMapping.getImports().first {
            val simpleTypeName = it.substringAfterLast(".")
            itemClassnames.first().startsWith(simpleTypeName)
        }

    return CollectionTypeInfo(
        typeMapping.mappedTypeName,
        // TODO If we are the only user of TypeMappingDescription.fullyQualifiedMappedTypeName, remove it from the JBG
        //typeMapping.fullyQualifiedMappedTypeName!!,
        collectionTypeQualifiedName.substringAfterLast("."),
        collectionTypeQualifiedName,
        typeArgumentQualifiedName.substringAfterLast("."),
        typeArgumentQualifiedName,
        typeArgumentObjectWrapperMapping != null,
        typeMapping.getImports()
    )
}

/**
 * Data class to store the following information about [IntermediateCollectionType]s:
 *      - Simple name
 *      - Simple name of the corresponding Java Collection type, e.g., "List"
 *      - Fully-qualified name of the corresponding Java Collection type, e.g., "java.util.List"
 *      - Simple name of the corresponding Java type argument, e.g., "Integer"
 *      - Fully-qualified name of the corresponding Java type argument, e.g., "java.lang.Integer"
 *      - Flag whether the type argument is a primitive boxed type like "Integer"
 *      - All imports of the collection type's [TypeMappingDescription]
 *
 * @author [Florian Rademacher](mailto:florian.rademacher@fh-dortmund.de)
 */
private data class CollectionTypeInfo(
    val simpleName: String,
    val collectionTypeSimpleName: String,
    val collectionTypeQualifiedName: String,
    val typeArgumentSimpleName: String,
    val typeArgumentQualifiedName: String,
    val typeArgumentIsPrimitiveBoxedType: Boolean,
    val imports: Set<String>
)

/**
 * Retrieve the fully-qualified Avro type names that correspond to this [IntermediatePrimitiveType].
 *
 * @author [Florian Rademacher](mailto:florian.rademacher@fh-dortmund.de)
 */
private fun IntermediatePrimitiveType.getCorrespondingAvroTypeNames(typeMapping: TypeMappingDescription)
    = if (name == PrimitiveTypeConstants.DATE.literal)
            setOf(AVRO_DATE_TYPE)
        else if (typeMapping.getImports().isNotEmpty())
            // The type mapping for the primitive type may specify imports when LEMMA treats the type as primitive while
            // in Java it is not a primitive built-in type and not part of the "java.lang" package
            setOf(typeMapping.getMappedTypeFullyQualifiedName())
        else
            // The Java representation of the primitive type is either a built-in primitive type, e.g., "int", or its
            // boxed object representation, e.g., "Integer". Since Avro always uses fully-qualified type names, we also
            // return the fully-qualified version of boxed types, e.g., "java.lang.Integer".
            setOf(typeMapping.mappedTypeName, "java.lang.${getObjectWrapperMapping().mappedTypeName}")

/**
 * Get the expression to convert items of this primitive [IntermediateCollectionType] into instances of the type
 * argument of the given [conversionTargetCollectionType], including the imports required by the expression. The
 * conversion will effectively be done by involving a call to the [converterFunctionReference]. In case no conversion is
 * necessary, the function returns an empty string together with an empty set of imports.
 *
 * @author [Florian Rademacher](mailto:florian.rademacher@fh-dortmund.de)
 */
private fun IntermediateCollectionType.getExpressionForPrimitiveCollectionItemConversion(
    conversionTargetCollectionType: ClassOrInterfaceType,
    converterFunctionReference: String,
    converterFunctionImports: Set<String>
) : Pair<String, Set<String>> {
    require(isPrimitiveCollection) { "Collection type $qualifiedName is not a primitive collection type" }

    // Currently, we only require to convert between Avro's date type (e.g., "java.time.Instant") and the Java
    // representation of LEMMA's built-in primitive date type (e.g., "java.util.Date")
    val javaTypeArgument = conversionTargetCollectionType.typeArguments.get().first().asString()
    val javaTypeArgumentIsAvroDate = javaTypeArgument == AVRO_DATE_TYPE

    val collectionTypeInfo = typeInfo()
    val collectionTypeJavaTypeArgument = collectionTypeInfo.typeArgumentQualifiedName
    val collectionTypeJavaTypeArgumentIsAvroDate = collectionTypeJavaTypeArgument == AVRO_DATE_TYPE

    if (!javaTypeArgumentIsAvroDate || collectionTypeJavaTypeArgumentIsAvroDate)
        return "" to emptySet()

    // Build the actual conversion expression which is invokable on the Java instance for this list type and maps all
    // clustered items into the desired target instances using the given converter function reference
    try {
        val (factoryMethod, factoryMethodImports) = getCollectorsFactoryMethod()
        val expression = "stream().map($converterFunctionReference).collect(Collectors.$factoryMethod())"
        val imports = factoryMethodImports.toMutableSet()
        imports.addAll(converterFunctionImports)
        return expression to imports
    } catch (ex: IllegalArgumentException) {
        throw PrimitiveCollectionItemConversionExpressionPreparationException(ex.message!!)
    }
}

/**
 * Get the name of the factory method in java.util.stream.Collectors for the [instantiableClassName] of this
 * [IntermediateCollectionType] and all imports required for the method's invocation.
 *
 * @author [Florian Rademacher](mailto:florian.rademacher@fh-dortmund.de)
 */
private fun IntermediateCollectionType.getCollectorsFactoryMethod() : Pair<String, Set<String>> {
    val method = when (val classname = instantiableClassName) {
        "java.util.ArrayList", "java.util.LinkedList" -> "toList"
        "java.util.HashSet" -> "toSet"
        else -> throw IllegalArgumentException("Collection type $classname does not have a factory method in " +
            "java.util.stream.Collectors")
    }

    return method to setOf("java.util.stream.Collectors")
}

private class PrimitiveCollectionItemConversionExpressionPreparationException(message: String) : Exception(message)

private class EnumerationAvroConverter(
    clazz: ClassOrInterfaceDeclaration,
    enumeration: IntermediateEnumeration,
    rootStructure: IntermediateDataStructure
) : AbstractAvroConverter(clazz, enumeration, rootStructure) {
    override fun generateBody() = generateEnumerationConverterBody(
            domainType as EnumDeclaration,
            targetEnumeration = avroType as EnumDeclaration,
            getTargetEnumerationName = { it.fullyQualifiedName.get() }
        )
}

private fun AbstractConverter<AbstractNestedConverterCall, AbstractConverter<*, *>>.generateEnumerationConverterBody(
    sourceEnumeration: EnumDeclaration,
    getSourceEnumerationName: (EnumDeclaration)->String = EnumDeclaration::getNameAsString,
    targetEnumeration: EnumDeclaration,
    getTargetEnumerationName: (EnumDeclaration)->String = EnumDeclaration::getNameAsString
) {
    require(sourceEnumeration != targetEnumeration) {
        "Source enumeration and target enumeration must be different but are both " +
        sourceEnumeration.fullyQualifiedName.get()
    }

    val (sharedLiterals, missingSourceLiterals, missingTargetLiterals) = diffLiterals(sourceEnumeration,
        targetEnumeration)

    val sourceEnumerationName = getSourceEnumerationName(sourceEnumeration)
    val targetEnumerationName = getTargetEnumerationName(targetEnumeration)
    if (sharedLiterals.isEmpty()) {
        setBody("""throw new UnsupportedOperationException("$sourceEnumerationName and $targetEnumerationName do """ +
            """not share any eponymous literals")""")
        setBlockComment("Consider overriding this method which always throws an exception upon invocation")
        return
    }

    val caseStatements = sharedLiterals.joinToString("\n") { "case $it: result = $targetEnumerationName.$it; break;" }
    val defaultStatement = """
            default: throw new IllegalArgumentException("Unrecognized literal in conversion of " +
                $sourceObjectName.getClass().getName() + ": " + $sourceObjectName);
        """.trimToSingleLine(true)
    setBody(StaticJavaParser.parseStatement(
        """{
            |$targetEnumerationName result;
            |switch($sourceObjectName) {
            |   $caseStatements
            |   $defaultStatement
            |}
            |return result;
        }""".trimMargin()) as BlockStmt)

    if (missingSourceLiterals.isNotEmpty())
        appendBlockComment("""
                |The method will fail for the following literals of $sourceEnumerationName:
                |${missingSourceLiterals.joinToString("\n") { "\t-$it" }}
                |Consider overriding the method if one or more of these literals require conversion.
            """.trimMargin())

    if (missingTargetLiterals.isNotEmpty())
        appendBlockComment("""
                |These $targetEnumerationName literals do not have corresponding $sourceEnumerationName literals:"
                |${missingTargetLiterals.joinToString("\n") { "\t-$it" }}
                |Consider overriding the method if one or more of these literals require conversion.
            """.trimMargin())
}

private fun diffLiterals(sourceEnumeration: EnumDeclaration, targetEnumeration: EnumDeclaration) : LiteralsDiff {
    val sourceLiterals = sourceEnumeration.entries.map { it.nameAsString }.toSet()
    val targetLiterals = targetEnumeration.entries.map { it.nameAsString }.toSet()
    val sharedLiterals = sourceLiterals.filter { it in targetLiterals }.toSet()

    return LiteralsDiff(
        sharedLiterals,
        sourceLiterals.filter { it !in sharedLiterals }.toSet(),
        targetLiterals.filter { it !in sharedLiterals }.toSet()
    )
}

private data class LiteralsDiff(val sharedLiterals: Set<String>, val missingSourceLiterals: Set<String>,
    val missingTargetLiterals: Set<String>)

private class CollectionTypeAvroConverter(
    clazz: ClassOrInterfaceDeclaration,
    private val collectionType: IntermediateCollectionType,
    rootStructure: IntermediateDataStructure,
    private val sourceObjectEntryName: String = DOMAIN_ENTRY,
    private val receiverObjectEntryName: String = AVRO_ENTRY
) : AbstractAvroConverter(clazz, collectionType, rootStructure) {
    private val delegate = CollectionTypeConverterDelegate(collectionType)

    override fun startDeclarationCreation() = super.startDeclarationCreation() && delegate.startDeclarationCreation()

    override fun findDomainType() = delegate.findDomainType()

    override fun findAvroType(rootStructure: IntermediateDataStructure) = delegate.findAvroType(rootStructure)

    override fun getReturnTypeNameAndImports() = delegate.getCollectionType(avroType, true)

    override fun getParameterTypeNameAndImports() = delegate.getCollectionType(domainType)

    override fun deriveBodyInformation() {
        for (field in collectionType.dataFields) {
            val domainGetter = try {
                    field.findDomainGetter()
                } catch(ex: IllegalStateException) {
                    appendBlockComment("\t-${ex.message!!}", "Missing Avro setter invocations:")
                    continue
                }

            val (avroSetter, avroSetterModelParameterType) = try {
                    field.findAvroSetter()
                } catch(ex: IllegalStateException) {
                    appendBlockComment("\t-${ex.message!!}", "Missing Avro setter invocations:")
                    continue
                }

            val avroSetterCallStatement = buildAvroSetterCallStatement(avroSetter, avroSetterModelParameterType,
                domainGetter)

            registerAvroObjectInitializationStatement(avroSetterCallStatement)
        }
    }

    private fun IntermediateDataField.findDomainGetter() : MethodDeclaration? {
        val domainClass = domainType as ClassOrInterfaceDeclaration
        val getter = domainClass.getExistingGetter(this)
        // A compound item domain class will have a getter. However, for a list of a single complex typed field there
        // is no getter to search for in the domain class. Instead, the object of the domain entry itself is the source
        // of information to set for the Avro class.
        if (getter == null && delegate.domainTypeIsCompoundItemClass) {
            val domainClassName = domainClass.fullyQualifiedName.get()
            throw IllegalStateException("Generated domain class $domainClassName does not comprise a getter for " +
                "field $name of type ${type.name} defined in modeled collection type ${collectionType.qualifiedName}")
        }

        return getter
    }

    private fun IntermediateDataField.findAvroSetter() : Pair<MethodDeclaration, IntermediateType> {
        val avroClass = avroType as ClassOrInterfaceDeclaration
        val setterAndType = avroClass.findAvroSetter(rootStructure, this)
        if (setterAndType == null) {
            val avroClassName = avroClass.fullyQualifiedName.get()
            val rootStructureName = rootStructure.qualifiedName
            throw IllegalStateException("Avro class $avroClassName compiled from schema of modeled structure " +
                "$rootStructureName does not comprise a setter for field $name of type ${type.name} defined in " +
                "modeled collection type ${collectionType.qualifiedName}")
        }

        return setterAndType
    }

    private fun buildAvroSetterCallStatement(
        avroSetter: MethodDeclaration,
        avroSetterModelParameterType: IntermediateType,
        domainGetter: MethodDeclaration?
    ) = if (avroSetterModelParameterType is IntermediateComplexType)
            avroSetterCallStatementForComplexType(avroSetter, avroSetterModelParameterType, domainGetter)
        else
            avroSetterCallStatementWithDirectDomainGetterCall(avroSetter, domainGetter)

    private fun avroSetterCallStatementForComplexType(
        avroSetter: MethodDeclaration,
        avroSetterModelParameterType: IntermediateComplexType,
        domainGetter: MethodDeclaration?
    ) = if (domainGetter != null)
                NestedAvroConverterCall(this, avroSetterModelParameterType, avroSetter, domainGetter,
                    receiverObjectEntryName, sourceObjectEntryName)
            else
                // A compound item domain class will have a getter. However, for a list of a single complex typed field there
                // is no getter to search for in the domain class. Instead, the object of the domain entry itself is the source
                // of information to set for the Avro class.
                NestedAvroConverterCall(this, avroSetterModelParameterType, avroSetter, sourceObjectEntryName,
                    domainType.nameAsString, receiverObjectEntryName, sourceObjectEntryName)

    private fun avroSetterCallStatementWithDirectDomainGetterCall(
        avroSetter: MethodDeclaration,
        domainGetter: MethodDeclaration?
    ) : Statement {
        var domainGetterCall = if (domainGetter != null)
                "$sourceObjectEntryName.${domainGetter.nameAsString}()"
            else
                sourceObjectEntryName
        val domainGetterAlreadyReturnsAvroDate = if (domainGetter != null)
                domainGetter.typeAsString == AVRO_DATE_TYPE
            else
                domainType.fullyQualifiedName.isPresent && domainType.fullyQualifiedName.get() == AVRO_DATE_TYPE

        val avroSetterForDate = avroSetter.parameters.first().typeAsString == AVRO_DATE_TYPE
        if (avroSetterForDate && !domainGetterAlreadyReturnsAvroDate)
            domainGetterCall += ".$AVRO_DATE_TYPE_CONVERTER_METHOD()"

        val avroSetterCall = "$receiverObjectEntryName.${avroSetter.nameAsString}($domainGetterCall);"
        return StaticJavaParser.parseStatement(avroSetterCall)
    }

    override fun wrapAvroObjectInitializationStatements(statements: List<Statement>) : BlockStmt {
        val forEachStatement = StaticJavaParser.parseStatement(
            """
                |for (var $sourceObjectEntryName : $sourceObjectName) {
                |   var $receiverObjectEntryName = new ${avroType.fullyQualifiedName.get()}();
                |   ${statements.joinToString("\n") { it.toString() }}
                |   $receiverObjectName.add($receiverObjectEntryName);
                |}   
            """.trimMargin())

        val statementContainer = BlockStmt()
        statementContainer.statements.add(forEachStatement)
        return statementContainer
    }
}

private class CollectionTypeConverterDelegate(private val collectionType: IntermediateCollectionType) {
    lateinit var collectionTypeInfo: CollectionTypeInfo
        private set
    var domainTypeIsCompoundItemClass = false
        private set

    fun startDeclarationCreation() : Boolean {
        if (collectionType.isPrimitiveCollection)
            return false

        try {
            collectionTypeInfo = collectionType.typeInfo()
        } catch (ex: IllegalArgumentException) {
            throw ConverterCreationException(ex.message!!)
        }

        return true
    }

    fun findDomainType() : TypeDeclaration<*> {
        // Try to get compound item class generated for modeled collection type (see CollectionTypeHandler)
        val compoundItemType = AvroConversionTypeManager.getJavaTypeGeneratedFromModel(collectionType)
        return if (compoundItemType != null) {
            domainTypeIsCompoundItemClass = true
            compoundItemType
        } else if (collectionTypeInfo.typeArgumentIsPrimitiveBoxedType)
            StaticJavaParser.parseTypeDeclaration("class ${collectionTypeInfo.typeArgumentSimpleName} {}")
        else {
            // Collection type must be structured because it is not a primitive collection (see
            // startDeclarationCreation()). Collection has one field with a complex type because it has no compound item
            // argument (i.e., more than one field).
            val modeledComplexItemType = collectionType.dataFields.first().type as IntermediateComplexType
            AvroConversionTypeManager.getJavaTypeGeneratedFromModel(modeledComplexItemType)
                ?: throw DomainItemTypeNotFoundException(collectionType, modeledComplexItemType)
        }
    }

    fun findAvroType(rootStructure: IntermediateDataStructure)
        = AvroConversionTypeManager.getJavaTypeCompiledFromSchemaOfRootStructure(rootStructure, collectionType.name)
            ?: throw AvroCollectionTypeNotFoundException(rootStructure, collectionType)

    fun getCollectionType(type: TypeDeclaration<*>, useFullyQualifiedTypeArgumentName: Boolean = false)
        : Pair<String, Set<String>> {
        val typeArgumentName = if (useFullyQualifiedTypeArgumentName)
                type.fullyQualifiedName.get()
            else
                type.nameAsString
        val typeName = "${collectionTypeInfo.collectionTypeSimpleName}<$typeArgumentName>"
        return typeName to collectionTypeInfo.imports
    }
}

private class DomainItemTypeNotFoundException(
    modeledCollectionType: IntermediateCollectionType,
    modeledItemType: IntermediateComplexType
) : ConverterCreationException("Domain type for item type ${modeledItemType.name} of modeled collection type " +
    "${modeledCollectionType.qualifiedName} was not generated")

private class AvroCollectionTypeNotFoundException(
    rootStructure: IntermediateDataStructure,
    modeledCollectionType: IntermediateCollectionType
) : ConverterCreationException("Avro type corresponding to modeled collection type " +
        "${modeledCollectionType.qualifiedName} was not compiled from the Avro schema assigned to the modeled root " +
        "structure ${rootStructure.qualifiedName}")

// TODO: Add comment with basic strategy explanation as for StructureAvroConverter
private class StructureDomainConverter(
    clazz: ClassOrInterfaceDeclaration,
    private val structure: IntermediateDataStructure,
    rootStructure: IntermediateDataStructure
) : AbstractDomainConverter(clazz, structure, rootStructure) {
    override fun deriveBodyInformation() = findDomainTypeConstructors(relevantFields = structure.avroRelevantFields())

    override fun generateBody() {
        val constructorCallExpression = prepareConverterForDomainConstructorCall()
        if (constructorCallExpression != null)
            appendStatement("return $constructorCallExpression;")
    }
}

/**
 * Find a getter in this [ClassOrInterfaceDeclaration] that maps to the given [field]'s Avro type, which was possibly
 * compiled from the schema of the given [rootStructure]. The result of this function is the [Pair] of the getter's
 * [MethodDeclaration] and the *resolved* [IntermediateType] of the [field], or null if the invocation of
 * [findAvroMethod] itself failed.
 *
 * @author [Florian Rademacher](mailto:florian.rademacher@fh-dortmund.de)
 */
private fun ClassOrInterfaceDeclaration.findAvroGetter(rootStructure: IntermediateDataStructure,
    field: IntermediateDataField)
    = findAvroMethod(rootStructure, field, ClassOrInterfaceDeclaration::getExistingGetter)

private typealias StatementAndImports = Pair<Statement, Set<String>>

/**
 * Get the validity of this [Statement] according to [checkValidity] as a Boolean value
 *
 * @author [Florian Rademacher](mailto:florian.rademacher@fh-dortmund.de)
 */
private fun Statement.isValid() = try {
        checkValidity()
        true
    } catch(ex: InvalidNestedConverterCallException) {
        false
    }

private class EnumerationDomainConverter(
    clazz: ClassOrInterfaceDeclaration,
    enumeration: IntermediateEnumeration,
    rootStructure: IntermediateDataStructure
) : AbstractDomainConverter(clazz, enumeration, rootStructure) {
    override fun generateBody() = generateEnumerationConverterBody(
            avroType as EnumDeclaration,
            { it.fullyQualifiedName.get() },
            domainType as EnumDeclaration
        )
}

private class CollectionTypeDomainConverter(
    clazz: ClassOrInterfaceDeclaration,
    private val collectionType: IntermediateCollectionType,
    rootStructure: IntermediateDataStructure,
    private val sourceObjectEntryName: String = AVRO_ENTRY
) : AbstractDomainConverter(clazz, collectionType, rootStructure) {
    private val delegate = CollectionTypeConverterDelegate(collectionType)
    private var directEntryInitializationStatement: Statement? = null
    private var directEntryInitializationStatementImports: Set<String>? = null

    override fun startDeclarationCreation() = super.startDeclarationCreation() && delegate.startDeclarationCreation()

    override fun findDomainType() = delegate.findDomainType()

    override fun findAvroType(rootStructure: IntermediateDataStructure) = delegate.findAvroType(rootStructure)

    override fun getReturnTypeNameAndImports() = delegate.getCollectionType(domainType)

    override fun getParameterTypeNameAndImports() = delegate.getCollectionType(avroType, true)

    override fun deriveBodyInformation() {
        if (delegate.domainTypeIsCompoundItemClass)
            findDomainTypeConstructors(relevantFields = collectionType.dataFields,
                constructorArgumentValueSource = sourceObjectEntryName)
        else
            deriveBodyInformationForSingleComplexTypeCollectionTypeArgument()
    }

    private fun deriveBodyInformationForSingleComplexTypeCollectionTypeArgument() {
        // There can only be one field because otherwise we would have a compound item collection given that we don't
        // support collection types with more than one type argument (e.g., maps) yet (the previous call to
        // IntermediateCollectionType.typeInfo() in CollectionTypeConverterDelegate.startDeclarationCreation() fails for
        // such cases with an IllegalArgumentException)
        val (avroGetter, avroGetterModelParameterType) = try {
                collectionType.findAvroGetterFromSingleComplexTypeField()
            } catch(ex: IllegalStateException) {
                setBlockComment(ex.message!!)
                return
            }

        val statementAndImports = buildFieldInitializingArgumentStatement(avroGetter, avroGetterModelParameterType,
            collectionType.dataFields.first(), sourceObjectEntryName)
        directEntryInitializationStatement = statementAndImports.first
        directEntryInitializationStatementImports = statementAndImports.second
    }

    private fun IntermediateCollectionType.findAvroGetterFromSingleComplexTypeField()
        : Pair<MethodDeclaration, IntermediateType> {
        val field = dataFields.first()
        val avroClass = avroType as ClassOrInterfaceDeclaration
        val getterAndType = avroClass.findAvroGetter(rootStructure, field)
        if (getterAndType == null) {
            val avroClassName = avroClass.fullyQualifiedName.get()
            val rootStructureName = rootStructure.qualifiedName
            throw IllegalStateException("Domain converter does not return an initialized domain object because the " +
                "Avro class $avroClassName compiled from the schema of the modeled structure $rootStructureName does " +
                "not comprise a getter for field ${field.name} of type ${field.type.name} defined in modeled " +
                "collection type $qualifiedName")
        }

        return getterAndType
    }

    override fun generateBody() {
        val domainObjectEntryExpression = if (delegate.domainTypeIsCompoundItemClass)
                prepareConverterForDomainConstructorCall()
            else
                prepareConverterForSingleComplexTypeCollectionTypeArgument()

        if (domainObjectEntryExpression == null)
            return

        val instantiableType = collectionType.instantiableClassName
        addRelocatableImport(instantiableType, ImportTargetElementType.METHOD_BODY)
        val instantiableSimpleType = instantiableType.substringAfterLast(".")
        val domainCollectionInstantiationExpression = "new $instantiableSimpleType<${domainType.nameAsString}>()"

        setBody(StaticJavaParser.parseStatement(
            """{
                |var $receiverObjectName = $domainCollectionInstantiationExpression;
                |for (var $sourceObjectEntryName : $sourceObjectName)
                |   $receiverObjectName.add($domainObjectEntryExpression);
                |return $receiverObjectName;   
            }""".trimMargin()) as BlockStmt)
    }

    private fun prepareConverterForSingleComplexTypeCollectionTypeArgument() : String? {
        require (!delegate.domainTypeIsCompoundItemClass) {
            "Domain type must not be a compound item class for the Java representation of the modeled collection " +
            "type ${collectionType.qualifiedName}"
        }

        return try {
            directEntryInitializationStatement!!.checkValidity()
            directEntryInitializationStatementImports!!.forEach {
                addRelocatableImport(it, ImportTargetElementType.METHOD_BODY)
            }
            directEntryInitializationStatement!!.toString().removeSuffix(";")
        } catch(ex: InvalidNestedConverterCallException) {
            setBlockComment("Domain converter returns null for the following reason: ${ex.message!!}")
            appendStatement("return null;")
            null
        }
    }
}