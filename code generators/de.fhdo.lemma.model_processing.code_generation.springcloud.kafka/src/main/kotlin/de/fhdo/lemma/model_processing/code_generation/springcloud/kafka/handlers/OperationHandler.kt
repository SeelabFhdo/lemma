package de.fhdo.lemma.model_processing.code_generation.springcloud.kafka.handlers

import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration
import com.github.javaparser.ast.body.MethodDeclaration
import de.fhdo.lemma.model_processing.code_generation.java_base.genlets.GenletCodeGenerationHandlerI
import de.fhdo.lemma.model_processing.code_generation.java_base.genlets.GenletCodeGenerationHandlerResult
import de.fhdo.lemma.model_processing.code_generation.java_base.handlers.CodeGenerationHandler
import de.fhdo.lemma.model_processing.code_generation.java_base.hasAspect
import de.fhdo.lemma.model_processing.code_generation.springcloud.kafka.forKafkaTechnology
import de.fhdo.lemma.model_processing.code_generation.springcloud.kafka.hasParametersOfCommunicationType
import de.fhdo.lemma.service.intermediate.IntermediateOperation
import de.fhdo.lemma.technology.CommunicationType

/**
 * Code generation handler for IntermediateOperation instances.
 *
 * @author [Florian Rademacher](mailto:florian.rademacher@fh-dortmund.de)
 */
@CodeGenerationHandler
internal class OperationHandler
    : GenletCodeGenerationHandlerI<IntermediateOperation, MethodDeclaration, ClassOrInterfaceDeclaration> {
    override fun handlesEObjectsOfInstance() = IntermediateOperation::class.java
    override fun generatesNodesOfInstance() = MethodDeclaration::class.java

    /**
     * Execution logic of the handler
     */
    override fun execute(eObject: IntermediateOperation, node: MethodDeclaration, context: ClassOrInterfaceDeclaration?)
        : GenletCodeGenerationHandlerResult<MethodDeclaration>? {
        // If the operation is a Kafka or Avro Participant and does not have synchronous parameters, it will be removed
        // from the context Java class. That is, because the Java Base Generator generates methods for asynchronous
        // operations. However, for Kafka the methods become event sending or listener callback methods within their own
        // Spring services. Consequently, their counterparts generated by the Java Base Generator are superfluous. In
        // case the operation has synchronous parameters, we do not remove it, but let the Java Base Generator handle
        // it. Note that at this point in processing time, all possibly existing asynchronous parameters were removed
        // already by KafkaGenerator.processIntermediateOperation(). Consequently, the Java Base Generator will only be
        // confronted with existing synchronous parameters if any.
        val allParticipantAspectNames = setOf("Participant", "AvroParticipant").forKafkaTechnology()
        if (eObject.hasAspect(*allParticipantAspectNames.toTypedArray()) &&
            !eObject.hasParametersOfCommunicationType(CommunicationType.SYNCHRONOUS))
            context!!.members.remove(node)
        return null
    }
}