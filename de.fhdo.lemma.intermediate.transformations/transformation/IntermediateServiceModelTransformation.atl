-- @path Service=/de.fhdo.lemma.servicedsl.metamodel/model/ServiceViewpointModel.xcore
-- @path Intermediate=/de.fhdo.lemma.service.intermediate.metamodel/model/IntermediateServiceModel.xcore

-- Author: Florian Rademacher
-- E-mail: florian.rademacher@fh-dortmund.de

module IntermediateServiceModelTransformation;
create OUT : Intermediate from IN : Service;

-- Helpers for managing created import instances ---------------------------------------------------
--- Helper to store created IntermediateImport instances. It maps the name of imports to the created
--- instances and hence enables, e.g., to identify a target IntermediateImport instance from the
--- name of a source Import instance.
helper def : createdImports : Map(String, Intermediate!IntermediateImport) = Map{};

--- Called helper rule to add a created IntermediateImport instance to the helper map of created
--- IntermediateImport instances. Note that we cannot use a "normal" helper here, because we need to
--- assign the helper map to itself to populate it.
rule CreatedImport(createdImport : Intermediate!IntermediateImport) {
    do {
        thisModule.createdImports <- thisModule.createdImports
            ->including(createdImport.name, createdImport);
    }
}

--- Convenience helper to get a created IntermediateImport instance from a given source Import
--- instance
helper def : getCreatedImport(sourceImport : Service!Import)
    : Intermediate!IntermediateImport = thisModule.createdImports->get(sourceImport.name)
;
----------------------------------------------------------------------------------------------------

-- Helpers for managing created intermediate technology instances ----------------------------------
--- Helper to store created IntermediateTechnology instances. It maps the import name of the
--- technology and the qualified name of the microservice to which it is assigned to the created
--- instances and hence enables.
helper def : createdTechnologies : Map(String, Intermediate!IntermediateTechnology) = Map{};

--- Called helper rule to add a created IntermediateTechnology instance to the helper map of created
--- IntermediateTechnology instances. Note that we cannot use a "normal" helper here, because we
--- need to assign the helper map to itself to populate it.
rule CreatedTechnology(createdTechnology : Intermediate!IntermediateTechnology) {
    do {
        thisModule.createdTechnologies <- thisModule.createdTechnologies
            ->including(createdTechnology.microservice.qualifiedName
                            .concat('::')
                            .concat(createdTechnology.import.name),
                        createdTechnology);
    }
}

--- Convenience helper to get a created IntermediateTechnology instance from source Microservice and
--- Import
helper def : getCreatedTechnology(microservice : Service!Microservice, import : Service!Import)
    : Intermediate!IntermediateTechnology =
    let technologyIdentifier : String = microservice.qualifiedName.concat('::').concat(import.name)
    in
    thisModule.createdTechnologies->get(technologyIdentifier)
;
----------------------------------------------------------------------------------------------------

-- Helpers for managing created microservice instances ---------------------------------------------
--- Helper to store created IntermediateMicroservice instances. It maps the qualified name of
--- microservices to the created instances and hence enables, e.g., to identify a target
--- IntermediateMicroservice instance from the qualified name of a source Microservice instance.
helper def : createdMicroservices : Map(String, Intermediate!IntermediateMicroservice) = Map{};

--- Called helper rule to add a created IntermediateMicroservice instance to the helper map of
--- created IntermediateMicroservice instances. Note that we cannot use a "normal" helper here,
--- because we need to assign the helper map to itself to populate it.
rule CreatedMicroservice(createdMicroservice : Intermediate!IntermediateMicroservice) {
    do {
        thisModule.createdMicroservices <- thisModule.createdMicroservices
            ->including(createdMicroservice.qualifiedName, createdMicroservice);
    }
}

--- Convenience helper to get a created IntermediateMicroservice instance from a given source
--- Microservice instance
helper def : getCreatedMicroservice(sourceMicroservice : Service!Microservice)
    : Intermediate!IntermediateMicroservice =
    thisModule.createdMicroservices->get(sourceMicroservice.buildQualifiedName('.'))
;
----------------------------------------------------------------------------------------------------

-- Helpers for managing created interface instances ------------------------------------------------
--- Helper to store created IntermediateInterface instances
helper def : createdInterfaces : Map(String, Intermediate!IntermediateInterface) = Map{};

--- Called helper rule to add a created IntermediateInterface instance to the helper map of
--- created IntermediateInterface instances
rule CreatedInterface(createdInterface : Intermediate!IntermediateInterface) {
    do {
        thisModule.createdInterfaces <- thisModule.createdInterfaces
            ->including(createdInterface.qualifiedName, createdInterface);
    }
}

--- Convenience helper to get a created IntermediateInterface instance from a given source
--- Interface instance
helper def : getCreatedInterface(sourceInterface : Service!Interface)
    : Intermediate!IntermediateInterface =
    thisModule.createdInterfaces->get(sourceInterface.buildQualifiedName('.'))
;
----------------------------------------------------------------------------------------------------

-- Helpers for managing created operation instances ------------------------------------------------
--- Helper to store created IntermediateOperation instances
helper def : createdOperations : Map(String, Intermediate!IntermediateOperation) = Map{};

--- Called helper rule to add a created IntermediateOperation instance to the helper map of
--- created IntermediateOperation instances
rule CreatedOperation(createdOperation : Intermediate!IntermediateOperation) {
    do {
        thisModule.createdOperations <- thisModule.createdOperations
            ->including(createdOperation.qualifiedName, createdOperation);
    }
}

--- Convenience helper to get a created IntermediateOperation instance from a given source
--- Operation instance
helper def : getCreatedOperation(sourceOperation : Service!Operation)
    : Intermediate!IntermediateOperation =
    thisModule.createdOperations->get(sourceOperation.buildQualifiedName('.'))
;
----------------------------------------------------------------------------------------------------

-- Helpers for managing created referred operation instances----------------------------------------
--- Helper to store created IntermediateReferredOperation instances
helper def : createdReferredOperations : Map(String, Intermediate!IntermediateReferredOperation)
    = Map{}
;

--- Called helper rule to add a created IntermediateReferredOperation instance to the helper map of
--- created IntermediateReferredOperation instances
rule CreatedReferredOperation(
    createdReferredOperation : Intermediate!IntermediateReferredOperation) {
    do {
        thisModule.createdReferredOperations <- thisModule.createdReferredOperations
            ->including(createdReferredOperation.qualifiedNameInReferringInterface,
                createdReferredOperation);
    }
}

--- Convenience helper to get a created IntermediateReferredOperation instance from a given source
--- ReferredOperation instance
helper def : getCreatedReferredOperation(sourceReferredOperation : Service!ReferredOperation)
    : Intermediate!IntermediateReferredOperation =
    thisModule.createdReferredOperations->get(sourceReferredOperation.buildQualifiedName('.'))
;
----------------------------------------------------------------------------------------------------

-- Helpers for managing created parameter instances-------------------------------------------------
--- Helper to store created IntermediateParameter instances
helper def : createdParameters : Map(String, Intermediate!IntermediateParameter) = Map{};

--- Called helper rule to add a created IntermediateParameter instance to the helper map of created
--- IntermediateParameter instances
rule CreatedParameter(createdParameter : Intermediate!IntermediateParameter) {
    do {
        thisModule.createdParameters <- thisModule.createdParameters
            ->including(createdParameter.qualifiedName, createdParameter);
    }
}

--- Convenience helper to get a created IntermediateParameter instance from a given source Parameter
--- instance
helper def : getCreatedParameter(sourceParameter : Service!Parameter)
    : Intermediate!IntermediateParameter =
    thisModule.createdParameters->get(sourceParameter.buildQualifiedName('.'))
;
----------------------------------------------------------------------------------------------------

-- Helpers for managing created mapped field instances----------------------------------------------
--- Helper to store created IntermediateMappedField instances
helper def : createdMappedFields : Map(String, Intermediate!IntermediateMappedField)
    = Map{};

--- Called helper rule to add a created IntermediateMappedField instance to the helper map of
--- created IntermediateMappedField instances
rule CreatedMappedField(createdMappedField : Intermediate!IntermediateMappedField) {
    do {
        thisModule.createdMappedFields <- thisModule.createdMappedFields
            ->including(createdMappedField.qualifiedName, createdMappedField);
    }
}

--- Convenience helper to get a created IntermediateMappedField instance from a given source
--- MappedField instance
helper def : getCreatedMappedField(sourceMappedField : Service!MappedField)
    : Intermediate!IntermediateMappedField =
    thisModule.createdMappedFields->get(sourceMappedField.buildQualifiedName('.', true))
;
----------------------------------------------------------------------------------------------------

--- Helper to retrieve a reference to the input model
helper def : inputModel() : Service!ServiceModel =
    Service!ServiceModel.allInstances().first()
;

--- Rule to generate the root of the target intermediate service model
unique lazy rule IntermediateServiceModel {
    from
        s : Service!ServiceModel
    to
        t : Intermediate!IntermediateServiceModel(
            sourceModelUri <- thisModule.inputModel().t_modelUri,
            imports <- Sequence{},
            microservices <- Sequence{}
        )
}

--- Transform a source Import to a target IntermediateImport
rule IntermediateImport {
    from
        i : Service!Import
    to
        t : Intermediate!IntermediateImport(
            name <- i.name,
            importUri <- i.importURI,
            -- Note that normally this would be a direct mapping between the source and the target
            -- importType. However, the XMI serlializer seems to be bugged. See the comments in the
            -- metamodel on why here the name of the import type is used instead.
            importTypeName <- thisModule.getImportTypeName(i)
        )
    do {
        -- Assign created target instance to the list of imports under the model root
        thisModule.IntermediateServiceModel().imports <- thisModule.IntermediateServiceModel()
            .imports->append(t);

        -- Populate helper of created IntermediateImport instances
        thisModule.CreatedImport(t);
    }
}

--- Helper to get the name of an import type without preceding hash sign ('#')
helper def : getImportTypeName(import : Service!Import) : String =
    let
        rawImportTypeName : String = import.importType.toString()
    in
    if (rawImportTypeName.startsWith('#')) then
        rawImportTypeName.substring(2, rawImportTypeName.size())
    else
        rawImportTypeName
    endif
;

--- Transform a source Microservice, to a target IntermediateMicroservice
rule IntermediateMicroservice {
    from
        m : Service!Microservice
    to
        i : Intermediate!IntermediateMicroservice(
            sourceModelUri <- if (not m.t_sourceModelUri.oclIsUndefined()) then
                    m.t_sourceModelUri
                else
                    thisModule.IntermediateServiceModel().sourceModelUri
                endif,
            name <- m.name,
            version <- m.version,
            qualifiedName <- m.buildQualifiedName('.'),
            type <- m.type.toString(),
            visibility <- m.effectiveVisibility.toString(),
            effectivelyImplemented <- m.effectivelyImplemented,
            -- Assign model root to target instance
            serviceModel <- thisModule.IntermediateServiceModel()
        )
    do {
        -- Create intermediate technologies
        for (technology in m.technologyReferences->collect(r | r.technology)) {
            thisModule.IntermediateTechnology(technology, i);
        }

        -- Assign created target instance to the list of microservices under the model root. This
        -- completes the binary association IntermediateServiceModel.microservices <-->
        -- IntermediateMicroservice.serviceModel
        thisModule.IntermediateServiceModel().microservices <- thisModule
            .IntermediateServiceModel().microservices->append(i);

        -- Create effective protocol specifications
        if (not m.t_effectiveProtocolSpecifications().oclIsUndefined())
            for (specification in m.t_effectiveProtocolSpecifications()) {
                i.protocols <- i.protocols->append(
                    thisModule.IntermediateProtocolSpecification(specification->get('protocol'),
                        specification->get('dataFormat'))
                );
            }

        thisModule.CreatedMicroservice(i);
    }
}

--- Called rule to generate IntermediateTechnology instances
rule IntermediateTechnology(sourceTechnology : Service!Technology,
    targetMicroservice : Intermediate!IntermediateMicroservice) {
    to
        t : Intermediate!IntermediateTechnology(
            name <- sourceTechnology.name,
            import <- thisModule.getCreatedImport(sourceTechnology),
            microservice <- targetMicroservice
        )
    do {
        if (targetMicroservice.technologies.oclIsUndefined())
            targetMicroservice.technologies = Sequence{};
        targetMicroservice.technologies <- targetMicroservice.technologies->append(t);

        thisModule.CreatedTechnology(t);
    }
}

--- Transform a source Interface to a target IntermediateInterface
rule IntermediateInterface {
    from
        i : Service!Interface
    to
        t : Intermediate!IntermediateInterface(
            name <- i.name,
            version <- i.version,
            qualifiedName <- i.buildQualifiedName('.'),
            visibility <- i.effectiveVisibility.toString(),
            notImplemented <- i.notImplemented,
            microservice <- thisModule.getCreatedMicroservice(i.microservice)
        )
    do {
        t.hasImplementedOperations <- i.operations->exists(o | not o.notImplemented);

        if (not i.t_effectiveProtocolSpecifications().oclIsUndefined())
            for (specification in i.t_effectiveProtocolSpecifications()) {
                t.protocols <- t.protocols->append(
                    thisModule.IntermediateProtocolSpecification(specification->get('protocol'),
                        specification->get('dataFormat'))
                );
            }

        t.microservice.interfaces <- t.microservice.interfaces->append(t);

        thisModule.CreatedInterface(t);
    }
}

--- Transform a source Operation to a target IntermediateOperation
rule IntermediateOperation {
    from
        o : Service!Operation
    to
        i : Intermediate!IntermediateOperation(
            name <- o.name,
            qualifiedName <- o.buildQualifiedName('.'),
            visibility <- o.effectiveVisibility.toString(),
            notImplemented <- o.notImplemented,
            interface <- thisModule.getCreatedInterface(o.interface)
        )
    do {
        if (not o.apiOperationComment.oclIsUndefined())
            i.apiOperationComment <- thisModule.IntermediateApiOperationComment(o, i);

        if (not o.t_effectiveProtocolSpecifications().oclIsUndefined())
            for (specification in o.t_effectiveProtocolSpecifications()) {
                i.protocols <- i.protocols->append(
                    thisModule.IntermediateProtocolSpecification(specification->get('protocol'),
                        specification->get('dataFormat'))
                );
            }

        i.interface.operations <- i.interface.operations->append(i);

        thisModule.CreatedOperation(i);
    }
}

--- Called rule to create an IntermediateApiOperationComment
rule IntermediateApiOperationComment(sourceOperation : Service!Operation,
    targetOperation : Intermediate!IntermediateOperation) {
    using {
        sourceComment : Service!ApiOperationComment = sourceOperation.apiOperationComment;
    }
    to
        i : Intermediate!IntermediateApiOperationComment(
            comment <- sourceComment.comment,
            operation <- targetOperation
        )
    do {
        i;
    }
}

--- Transform a source ReferredOperation to a target IntermediateReferredOperation
rule IntermediateReferredOperation {
    from
        r : Service!ReferredOperation
    to
        i : Intermediate!IntermediateReferredOperation(
            nameInReferringInterface <- r.operation.name,
            qualifiedNameInReferringInterface <- r.buildQualifiedName('.'),
            operation <- thisModule.getCreatedOperation(r.operation),
            referringInterface <- thisModule.getCreatedInterface(r.interface)
        )
    do {
        if (not r.t_effectiveProtocolSpecifications().oclIsUndefined())
            for (specification in r.t_effectiveProtocolSpecifications()) {
                i.protocols <- i.protocols->append(
                    thisModule.IntermediateProtocolSpecification(specification->get('protocol'),
                        specification->get('dataFormat'))
                );
            }

        i.referringInterface.referredOperations <- i.referringInterface
            .referredOperations->append(i);

        thisModule.CreatedReferredOperation(i);
    }
}

--- Transform a source Parameter to a target IntermediateParameter
rule IntermediateParameter {
    from
        p : Service!Parameter
    using {
        hasComment : Boolean = if (not p.operation.apiOperationComment.oclIsUndefined()) then
                p.operation.apiOperationComment.parameterComments
                    ->exists(c | c.parameter.name = p.name)
            else
                false
            endif;
    }
    to
        i : Intermediate!IntermediateParameter(
            name <- p.name,
            qualifiedName <- p.buildQualifiedName('.'),
            exchangePattern <- p.exchangePattern.toString(),
            communicationType <- p.communicationType.toString(),
            communicatesFault <- p.communicatesFault,
            optional <- p.optional
        )
    do {
        if (hasComment)
            thisModule.IntermediateApiParameterComment(p, i);

        -- Set initializing operation
        if (not p.initializedByOperation.oclIsUndefined()) {
            i.initializedByOperation <- thisModule
                .CreateOperationReference(p.initializedByOperation);
            i.initializedByOperation.initializedParameter <- i;
        }

        -- Set original type for parameter (original type got overwritten in mapping model)
        if (not p.originalPrimitiveType.oclIsUndefined())
            i.originalType <- thisModule.BuiltinPrimitiveIntermediateType(p.originalPrimitiveType);
        else if (not p.originalImportedType.oclIsUndefined())
            if (p.originalImportedType.type.oclIsKindOf(Service!ComplexType))
                i.originalType <- thisModule.DataModelIntermediateType(p.originalImportedType);

        -- Create intermediate type for parameter
        if (thisModule.hasDefaultPrimitiveTechnologySpecificType(p)) {
            i.type <- thisModule.TechnologySpecificPrimitiveIntermediateType(p);

            -- Original type was not overwritten in mapping model, so set it here
            if (i.originalType.oclIsUndefined())
                i.originalType <- thisModule.BuiltinPrimitiveIntermediateType(p.primitiveType);
        } else if (thisModule.hasTechnologySpecificType(p)) {
            i.type <- thisModule.TechnologySpecificIntermediateType(p.importedType,
                p.operation.interface.microservice.t_typeDefinitionTechnology.name);

            -- Original type is equal to type (no mapping and type was explicitly set to
            -- technology-specific one by modeler)
            if (i.originalType.oclIsUndefined())
                i.originalType <- thisModule.TechnologySpecificIntermediateType(p.importedType,
                    p.operation.interface.microservice.t_typeDefinitionTechnology.name);
        } else if (not p.primitiveType.oclIsUndefined()) {
            i.type <- thisModule.BuiltinPrimitiveIntermediateType(p.primitiveType);

            -- Original type is equal to type (no mapping and type is built-in primitive)
            if (i.originalType.oclIsUndefined())
                i.originalType <- thisModule.BuiltinPrimitiveIntermediateType(p.primitiveType);
        } else if (not p.importedType.oclIsUndefined())
            if (p.importedType.type.oclIsKindOf(Service!ComplexType)) {
                i.type <- thisModule.DataModelIntermediateType(p.importedType);

                -- Original type is equal to type (no mapping and imported type from data model)
                if (i.originalType.oclIsUndefined())
                    i.originalType <- thisModule.DataModelIntermediateType(p.importedType);
            }

        -- Link parameter to operation
        i.operation <- thisModule.getCreatedOperation(p.operation);
        i.operation.parameters <- i.operation.parameters->append(i);

        -- Store created parameter for subsequent referencing
        thisModule.CreatedParameter(i);
    }
}

--- Called rule to create an IntermediateApiParameterComment
rule IntermediateApiParameterComment(sourceParameter : Service!Parameter,
    targetParameter : Intermediate!IntermediateParameter) {
    using {
        sourceOperation : Service!Operation = sourceParameter.operation;
        sourceOperationComment : Service!ApiOperationComment = sourceOperation.apiOperationComment;
        sourceComment : Service!ApiParameterComment = sourceOperationComment.parameterComments
            ->any(c | c.parameter.name = sourceParameter.name);
        targetOperationComment : Intermediate!IntermediateApiOperationComment
            = thisModule.getCreatedOperation(sourceOperation).apiOperationComment;
    }
    to
        i : Intermediate!IntermediateApiParameterComment(
            comment <- sourceComment.comment,
            required <- sourceComment.required,
            parameter <- targetParameter
        )
    do {
        targetOperationComment.parameterComments <-
            targetOperationComment.parameterComments->append(i);

        i;
    }
}

--- Check if a parameter has a primitive type for which a default technology-specific primitive type
--- exists in the technology of the microservice (if any)
helper def : hasDefaultPrimitiveTechnologySpecificType(p : Service!Parameter) : Boolean =
    let microservice : Service!Microservice = p.operation.interface.microservice
    in
    if (microservice.t_typeDefinitionTechnologyImport.oclIsUndefined()
        or microservice.t_typeDefinitionTechnology.oclIsUndefined()) then
        false
    else if (p.primitiveType.oclIsUndefined()) then
        false
    else if (thisModule.findDefaultTechnologySpecificPrimitiveType(p.primitiveType,
        microservice.t_typeDefinitionTechnology).oclIsUndefined()) then
        false
    else
        true
    endif
    endif
    endif
;

--- Create an intermediate type that represents a technology-specific primitive type
rule TechnologySpecificPrimitiveIntermediateType(p : Service!Parameter) {
    to
        i : Intermediate!IntermediateImportedTechnologySpecificType(
            name <- thisModule.findDefaultTechnologySpecificPrimitiveType(
                        p.primitiveType,
                        p.operation.interface.microservice.t_typeDefinitionTechnology
                    ).name,
            qualifiedName <- p.operation.interface.microservice.t_typeDefinitionTechnology.name
                                .concat('.')
                                .concat(
                                    thisModule.findDefaultTechnologySpecificPrimitiveType(
                                        p.primitiveType,
                                        p.operation.interface.microservice
                                            .t_typeDefinitionTechnology
                                    ).buildQualifiedName('.')
                                ),
            origin <- #TECHNOLOGY,
            kind <- #PRIMITIVE,
            import <- thisModule.getCreatedImport(
                p.operation.interface.microservice.t_typeDefinitionTechnologyImport
            )
        )
    do {
        i;
    }
}

--- Helper to check if a parameter has a technology-specific type
helper def : hasTechnologySpecificType(p : Service!Parameter) : Boolean =
    if (p.importedType.oclIsUndefined()) then
        false
    else
        let type : Service!Type = p.importedType.type
        in
        type.oclIsTypeOf(Service!TechnologySpecificPrimitiveType)
            or type.oclIsTypeOf(Service!TechnologySpecificCollectionType)
            or type.oclIsTypeOf(Service!TechnologySpecificDataStructure)
    endif
;

--- Create an intermediate type for a parameter type that was imported from a technoplogy model and
--- explicitly assigned to the parameter
rule TechnologySpecificIntermediateType(importedType : Service!ImportedType,
    technologyName : String) {
    to
        i : Intermediate!IntermediateImportedTechnologySpecificType(
            name <- importedType.type.name,
            qualifiedName <- technologyName
                                .concat('.')
                                .concat(importedType.type.buildQualifiedName('.')),
            origin <- #TECHNOLOGY,
            kind <- thisModule.getTypeKind(importedType.type),
            import <- thisModule.getCreatedImport(importedType.import)
        )
    do {
        i;
    }
}

--- Helper to find the default technology-specific primitive type for a given built-in primitive
--- type and a technology
helper def : findDefaultTechnologySpecificPrimitiveType(primitiveType : Service!PrimitiveType,
    technology : Service!Technology) : Service!TechnologySpecificPrimitiveType =
    technology.primitiveTypes->any(t |
        t.default = true and
        t.basicBuiltinPrimitiveTypes->exists(b | b.typeName = primitiveType.typeName)
    )
;

--- Create an intermediate type for a built-in primitive
rule BuiltinPrimitiveIntermediateType(primitiveType : Service!PrimitiveType) {
    to
        i : Intermediate!IntermediatePrimitiveType(
            name <- primitiveType.typeName,
            size <- primitiveType.typeSize,
            origin <- #BUILTIN,
            kind <- #PRIMITIVE
        )
    do {
        i;
    }
}

--- Called rule to create an intermediate type for complex types being imported from a data model
rule DataModelIntermediateType(importedType : Service!ImportedType) {
    to
        i : Intermediate!IntermediateImportedComplexType(
            name <- importedType.type.name,
            qualifiedName <- importedType.type.buildQualifiedName('.'),
            origin <- #DATA_MODEL,
            kind <- thisModule.getTypeKind(importedType.type),
            import <- thisModule.getCreatedImport(importedType.import)
        )
    do {
        i;
    }
}

--- Helper to determine a type's kind
helper def : getTypeKind(type : Service!Type) : Intermediate!IntermediateTypeKind =
    if (type.oclIsKindOf(Service!TechnologySpecificPrimitiveType)
        or type.oclIsKindOf(Service!PrimitiveType)) then
        #PRIMITIVE
    else if (type.oclIsKindOf(Service!TechnologySpecificCollectionType)) then
        #COLLECTION
    else if (type.oclIsKindOf(Service!TechnologySpecificDataStructure)) then
        #STRUCTURE
    else if (type.oclIsKindOf(Service!ComplexType)) then
        if (type.isStructure) then
            #STRUCTURE
        else if (type.isPrimitiveCollection or type.isStructuredCollection) then
            #COLLECTION
        else if (type.isEnumeration) then
            #ENUMERATION
        else
            OclUndefined
        endif
        endif
        endif
    else
        OclUndefined
    endif
    endif
    endif
    endif
;

--- Called rule to generate IntermediateProtocolSpecification instances
rule IntermediateProtocolSpecification(protocol : Service!Protocol,
    dataFormat : Service!DataFormat) {
    to
        s : Intermediate!IntermediateProtocolSpecification(
            communicationType <- protocol.communicationType.toString(),
            protocol <- protocol.name,
            dataFormat <- dataFormat.formatName
        )
    do {
        s;
    }
}

--- Create an IntermediateEndpoint from a source ImportedProtocolAndDataFormat instance. The
--- IntermediateEndpoint instance is a simplification of the ImportedProtocolAndDataFormat concept.
--- It does not encapsulate imported protocol information in a reusable way.
rule IntermediateEndpoint {
    from
        p : Service!ImportedProtocolAndDataFormat
            -- Only transform instances whose endpoint feature is not empty, i.e., which are not
            -- part of a ProtocolSpecification
            (not p.endpoint.oclIsUndefined() and
                if (not p.endpoint.oclIsUndefined())
                then
                    (not p.endpoint.microservice.oclIsUndefined()) or
                    (not p.endpoint.interface.oclIsUndefined()) or
                    (not p.endpoint.operation.oclIsUndefined()) or
                    (not p.endpoint.referredOperation.oclIsUndefined())
                else
                    false
                endif
            )
    to
        i : Intermediate!IntermediateEndpoint(
            communicationType <- p.importedProtocol.communicationType.toString(),
            protocol <- p.importedProtocol.name,
            addresses <- p.endpoint.addresses
        )
    do {
        -- Endpoint belongs to Microservice
        if (not p.endpoint.microservice.oclIsUndefined()) {
            i.microservice <- thisModule.getCreatedMicroservice(p.endpoint.microservice);
            i.microservice.endpoints <- i.microservice.endpoints->append(i);
            i.technology <- thisModule.getCreatedTechnology(i.microservice, p.import);
        -- Endpoint belongs to Interface
        } else if (not p.endpoint.interface.oclIsUndefined()) {
            i.interface <- thisModule.getCreatedInterface(p.endpoint.interface);
            i.interface.endpoints <- i.interface.endpoints->append(i);
            i.technology <- thisModule.getCreatedTechnology(i.interface.microservice, p.import);
        -- Endpoint belongs to Operation
        } else if (not p.endpoint.operation.oclIsUndefined()) {
            i.operation <- thisModule.getCreatedOperation(p.endpoint.operation);
            i.operation.endpoints <- i.operation.endpoints->append(i);
            i.technology <- thisModule.getCreatedTechnology(i.operation.interface.microservice,
                p.import);
        -- Endpoint belongs to ReferredOperation
        } else if (not p.endpoint.referredOperation.oclIsUndefined()) {
            i.referredOperation <- thisModule
                .getCreatedReferredOperation(p.endpoint.referredOperation);
            i.referredOperation.endpoints <- i.referredOperation.endpoints->append(i);
            i.technology <- thisModule.getCreatedTechnology(
                i.referredOperation.referringInterface.microservice,
                p.import
            );
        }

        if (not p.dataFormat.oclIsUndefined())
            i.dataFormat <- p.dataFormat.formatName;
        else {
            -- If no data format was specified for the endpoint, the newly created
            -- IntermediateEndpoint gets the default format of the protocol assigned
            if (not p.importedProtocol.defaultFormat.oclIsUndefined())
                i.dataFormat <- p.importedProtocol.defaultFormat.formatName;
            else
                -- If no default format for the protocol exists, we create an endpoint for each
                -- data format of the protocol
                i.dataFormat <- p.importedProtocol.dataFormats->first().formatName;
                for (dataFormat in p.importedProtocol.dataFormats
                        ->subSequence(2, p.importedProtocol.dataFormats->size())) {
                    thisModule.CopyIntermediateEndpoint(i, dataFormat);
                }
        }
    }
}

--- Called rule to create a default IntermediateEndpoint instance from the given values and for the
--- given target (i.e., a microservice, interface, operation, or referred operation). Note, that a
--- default IntermediateEndpoint instance does not exhibit the addresses feature. It is in the
--- responsibility of the generator to deduce sensible, possibly technology-dependent default
--- addresses for the respective microservice.
rule DefaultIntermediateEndpoint(protocol : Service!Protocol,
    dataFormat : Service!DataFormat, import : Service!Import, target : OclAny) {
    to
        e : Intermediate!IntermediateEndpoint(
            communicationType <- protocol.communicationType.toString(),
            protocol <- protocol.name,
            dataFormat <- dataFormat.formatName
        )
    do {
        if (target.oclIsTypeOf(Intermediate!IntermediateMicroservice)) {
            e.microservice <- target;
            e.microservice.endpoints <- e.microservice.endpoints->append(e);
            e.technology <- thisModule.getCreatedTechnology(e.microservice, import);
        } else if (target.oclIsTypeOf(Intermediate!IntermediateInterface)) {
            e.interface <- target;
            e.interface.endpoints <- e.interface.endpoints->append(e);
            e.technology <- thisModule.getCreatedTechnology(e.interface.microservice, import);
        } else if (target.oclIsTypeOf(Intermediate!IntermediateOperation)) {
            e.operation <- target;
            e.operation.endpoints <- e.operation.endpoints->append(e);
            e.technology <- thisModule.getCreatedTechnology(
                e.operation.interface.microservice,
                import
            );
        } else if (target.oclIsTypeOf(Intermediate!IntermediateReferredOperation)) {
            e.referredOperation <- target;
            e.referredOperation.endpoints <- e.referredOperation.endpoints->append(e);
            e.technology <- thisModule.getCreatedTechnology(
                e.referredOperation.referringInterface.microservice,
                import
            );
        }

        e;
    }
}

--- Called rule to copy an IntermediateEndpoint but with a different data format
rule CopyIntermediateEndpoint(baseEndpoint : Intermediate!IntermediateEndpoint,
    dataFormat : Service!DataFormat) {
    to
        e : Intermediate!IntermediateEndpoint(
            communicationType <- baseEndpoint.communicationType.toString(),
            protocol <- baseEndpoint.protocol,
            dataFormat <- dataFormat.formatName,
            addresses <- baseEndpoint.addresses
        )
    do {
        if (not baseEndpoint.microservice.oclIsUndefined()) {
            e.microservice <- baseEndpoint.microservice;
            baseEndpoint.microservice.endpoints <- baseEndpoint.microservice.endpoints->append(e);
        } else if (not baseEndpoint.interface.oclIsUndefined()) {
            e.interface <- baseEndpoint.interface;
            baseEndpoint.interface.endpoints <- baseEndpoint.interface.endpoints->append(e);
        } else if (not baseEndpoint.operation.oclIsUndefined()) {
            e.operation <- baseEndpoint.operation;
            baseEndpoint.operation.endpoints <- baseEndpoint.operation.endpoints->append(e);
        } else if (not baseEndpoint.referredOperation.oclIsUndefined()) {
            e.referredOperation <- baseEndpoint.referredOperation;
            baseEndpoint.referredOperation.endpoints <- baseEndpoint.referredOperation
                .endpoints->append(e);
        }
    }
}

--- Create a MicroserviceReference from a PossiblyImportedMicroservice instance
rule MicroserviceReference {
    from
        m : Service!PossiblyImportedMicroservice
    to
        r : Intermediate!MicroserviceReference(
            name <- m.microservice.name,
            version <- m.microservice.version,
            qualifiedName <- m.microservice.buildQualifiedName('.'),
            -- PossiblyImportedMicroservice instances are currently only used for specifying
            -- required Microservices
            requiringMicroservice <- thisModule.getCreatedMicroservice(m.requiringMicroservice)
        )
    do {
        -- In case the Microservice is actually imported, set the flag and the import name, i.e.,
        -- its alias that eventually points to the source model of the Microservice.
        if (not m.import.oclIsUndefined()) {
            r.imported <- true;
            r.import <- thisModule.getCreatedImport(m.import);
        -- Otherwise, associate the instance of the local IntermediateMicroservice
        } else
            r.localMicroservice <- thisModule.getCreatedMicroservice(m.microservice);

        thisModule.getCreatedMicroservice(m.requiringMicroservice).requiredMicroservices <-
            thisModule.getCreatedMicroservice(m.requiringMicroservice)
                .requiredMicroservices->append(r);
    }
}

--- Create an InterfaceReference from a PossiblyImportedInterface instance
rule InterfaceReference {
    from
        i : Service!PossiblyImportedInterface
    to
        t : Intermediate!InterfaceReference(
            name <- i.interface.name,
            version <- i.interface.version,
            qualifiedName <- i.interface.buildQualifiedName('.'),
            -- PossiblyImportedInterface instances are currently only used for specifying required
            -- Interfaces on Microservices
            requiringMicroservice <- thisModule.getCreatedMicroservice(i.requiringMicroservice)
        )
    do {
        if (not i.import.oclIsUndefined()) {
            t.imported <- true;
            t.import <- thisModule.getCreatedImport(i.import);
        } else
            t.localInterface <- thisModule.getCreatedInterface(i.interface);

        thisModule.getCreatedMicroservice(i.requiringMicroservice).requiredInterfaces <-
            thisModule.getCreatedMicroservice(i.requiringMicroservice).requiredInterfaces->append(t);
    }
}

--- Create an OperationReference from a PossiblyImportedOperation instance that is associated with
--- a Microservice as a required operation
rule OperationReference {
    from
        o : Service!PossiblyImportedOperation (not o.requiringMicroservice.oclIsUndefined())
    using {
        -- Instead of the "to" part we create the target instance in the "using" part. This enables
        -- us to bundle the creation logic for an OperationReference in a reusable called rule
        i : Intermediate!OperationReference
            = thisModule.CreateOperationReference(o);
    }
    do {
        i.requiringMicroservice <- thisModule.getCreatedMicroservice(o.requiringMicroservice);
        thisModule.getCreatedMicroservice(o.requiringMicroservice).requiredOperations <-
            thisModule.getCreatedMicroservice(o.requiringMicroservice).requiredOperations->append(i);
    }
}

--- Called helper rule to create an OperationReference
rule CreateOperationReference(sourceOperation : Service!PossiblyImportedOperation) {
    to
        i : Intermediate!OperationReference(
            name <- sourceOperation.operation.name,
            qualifiedName <- sourceOperation.operation.buildQualifiedName('.')
        )
    do {
        if (not sourceOperation.import.oclIsUndefined()) {
            i.imported <- true;
            i.import <- thisModule.getCreatedImport(sourceOperation.import);
        } else
            i.localOperation <- thisModule.getCreatedOperation(sourceOperation.operation);

        i;
    }
}

--- Create an IntermediateImportedAspect from an ImportedServiceAspect instance
rule IntermediateImportedAspect {
    from
        a : Service!ImportedServiceAspect (
            -- Filter aspects belonging to mapped elements of data models, and thus become parts of
            -- intermediate data models instead of intermediate service models
            if (not a.mappedComplexType.oclIsUndefined() or
                not a.mappedDataOperation.oclIsUndefined() or
                not a.mappedDataOperationReturnType.oclIsUndefined() or
                not a.mappedDataOperationParameter.oclIsUndefined()) then
                false
            -- Aspects of mapped fields are only handled if they are assigned to the fields in the
            -- context of a parameter. Aspects of mapped fields belonging to mapped complex types
            -- are reflected in intermediate data models (not intermediate service models).
            else if (not a.mappedField.oclIsUndefined()) then
                not a.mappedField.parameter.oclIsUndefined()
            else
                true
            endif
            endif
        )
    to
        i : Intermediate!IntermediateImportedAspect(
            name <- a.importedAspect.name,
            qualifiedName <- a.importedAspect.buildQualifiedName('.', true, false),
            import <- thisModule.getCreatedImport(a.import)
        )
    do {
        -- Aspect features
        for (feature in a.importedAspect.features) {
            i.featureNames <- i.featureNames.append(feature.toString());
        }

        -- Create properties of aspect and link them with the aspect
        for (property in a.importedAspect.properties) {
            i.properties <- i.properties->append(
                thisModule.IntermediateAspectProperty(property, i)
            );
        }

        -- Create values of aspect and link them with the aspect. Therefore, we consider both, the
        -- syntactically shorter initialization of a single property aspect and the "normal" case of
        -- "named" property initialization. Independent of how the aspect and its values were
        -- specified, we map an aspect value to a an IntermediateAspectPropertyValue instance.
        if (not a.singlePropertyValue.oclIsUndefined())
            thisModule.IntermediateAspectPropertyValue(a.singlePropertyValue, i,
                i.properties->first());
        else
            for (value in a.values) {
                thisModule.IntermediateAspectPropertyValue(value.value, i,
                    i.properties->any(p | p.name = value.property.name));
            }

        -- Link created aspect to the corresponding target element
        if (not a.microservice.oclIsUndefined())
            thisModule.getCreatedMicroservice(a.microservice).aspects <-
                thisModule.getCreatedMicroservice(a.microservice).aspects->append(i);
        else if (not a.interface.oclIsUndefined())
            thisModule.getCreatedInterface(a.interface).aspects <-
                thisModule.getCreatedInterface(a.interface).aspects->append(i);
        else if (not a.operation.oclIsUndefined())
            thisModule.getCreatedOperation(a.operation).aspects <-
                thisModule.getCreatedOperation(a.operation).aspects->append(i);
        else if (not a.referredOperation.oclIsUndefined())
            thisModule.getCreatedReferredOperation(a.referredOperation).aspects <-
                thisModule.getCreatedReferredOperation(a.referredOperation).aspects->append(i);
        else if (not a.parameter.oclIsUndefined())
            thisModule.getCreatedParameter(a.parameter).aspects <-
                thisModule.getCreatedParameter(a.parameter).aspects->append(i);
        else if (not a.mappedField.oclIsUndefined()) {
            -- If the aspect is defined as part of a mapped field in a parameter, we append the
            -- aspect to the field aspects of the parameter. If the aspect is the first aspect for
            -- the mapped field, we first create a new instance of DataFieldAspects and assign it to
            -- the parameter.
            if (thisModule.getFieldAspects(a.mappedField).oclIsUndefined())
                thisModule.getCreatedParameter(a.mappedField.parameter).fieldAspects <-
                    thisModule.getCreatedParameter(a.mappedField.parameter).fieldAspects->append(
                        thisModule.DataFieldAspects(a.mappedField)
                    );

            thisModule.getFieldAspects(a.mappedField).aspects <-
                thisModule.getFieldAspects(a.mappedField).aspects->append(i);
        }

        i;
    }
}

--- Find DataFieldAspects instance corresponding to a mapped field and the parameter in which
--- context is was specified
helper def : getFieldAspects(mappedField : Service!MappedField) : Intermediate!DataFieldAspects =
    thisModule.getCreatedParameter(mappedField.parameter).fieldAspects
        ->any(a | a.qualifiedName = mappedField.buildQualifiedName('.', false))
;

--- Called rule to create a DataFieldAspects instance from a MappedField instance
rule DataFieldAspects(mappedField : Service!MappedField) {
    to
        i : Intermediate!DataFieldAspects(
            name <- mappedField.name,
            qualifiedName <- mappedField.buildQualifiedName('.', false),
            aspects <- Sequence{},
            parameter <- thisModule.getCreatedParameter(mappedField.parameter)
        )
    do {
        i;
    }
}

--- Called rule to create an IntermediateAspectProperty instance
rule IntermediateAspectProperty(sourceProperty : Service!TechnologySpecificProperty,
    aspect : Intermediate!IntermediateImportedAspect) {
    to
        i : Intermediate!IntermediateAspectProperty(
            name <- sourceProperty.name,
            type <- sourceProperty.type.typeName,
            aspect <- aspect
        )
    do {
        for (feature in sourceProperty.features) {
            i.featureNames <- i.featureNames.append(feature.toString());
        }

        if (not sourceProperty.defaultValue.oclIsUndefined())
            i.defaultValue <- sourceProperty.defaultValue.valueAsString();

        aspect.properties <- aspect.properties->append(i);
        i;
    }
}

--- Called rule to create an IntermediateAspectPropertyValue instance
rule IntermediateAspectPropertyValue(sourceValue : Service!PrimitiveValue,
    aspect : Intermediate!IntermediateImportedAspect,
    property : Intermediate!IntermediateAspectProperty) {
    to
        i : Intermediate!IntermediateAspectPropertyValue(
            value <- sourceValue.valueAsString(),
            aspect <- aspect,
            property <- property
        )
    do {
        aspect.propertyValues->append(i);
        i;
    }
}